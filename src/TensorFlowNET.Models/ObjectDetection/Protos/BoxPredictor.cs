// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: object_detection/protos/box_predictor.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Models.ObjectDetection.Protos {

  /// <summary>Holder for reflection information generated from object_detection/protos/box_predictor.proto</summary>
  public static partial class BoxPredictorReflection {

    #region Descriptor
    /// <summary>File descriptor for object_detection/protos/box_predictor.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static BoxPredictorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CitvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9ib3hfcHJlZGljdG9yLnByb3Rv",
            "EhdvYmplY3RfZGV0ZWN0aW9uLnByb3Rvcxopb2JqZWN0X2RldGVjdGlvbi9w",
            "cm90b3MvaHlwZXJwYXJhbXMucHJvdG8ikAMKDEJveFByZWRpY3RvchJZChtj",
            "b252b2x1dGlvbmFsX2JveF9wcmVkaWN0b3IYASABKAsyMi5vYmplY3RfZGV0",
            "ZWN0aW9uLnByb3Rvcy5Db252b2x1dGlvbmFsQm94UHJlZGljdG9ySAASUAoX",
            "bWFza19yY25uX2JveF9wcmVkaWN0b3IYAiABKAsyLS5vYmplY3RfZGV0ZWN0",
            "aW9uLnByb3Rvcy5NYXNrUkNOTkJveFByZWRpY3RvckgAEkcKEnJmY25fYm94",
            "X3ByZWRpY3RvchgDIAEoCzIpLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLlJm",
            "Y25Cb3hQcmVkaWN0b3JIABJzCil3ZWlnaHRfc2hhcmVkX2NvbnZvbHV0aW9u",
            "YWxfYm94X3ByZWRpY3RvchgEIAEoCzI+Lm9iamVjdF9kZXRlY3Rpb24ucHJv",
            "dG9zLldlaWdodFNoYXJlZENvbnZvbHV0aW9uYWxCb3hQcmVkaWN0b3JIAEIV",
            "ChNib3hfcHJlZGljdG9yX29uZW9mIoQEChlDb252b2x1dGlvbmFsQm94UHJl",
            "ZGljdG9yEj4KEGNvbnZfaHlwZXJwYXJhbXMYASABKAsyJC5vYmplY3RfZGV0",
            "ZWN0aW9uLnByb3Rvcy5IeXBlcnBhcmFtcxIRCgltaW5fZGVwdGgYAiABKAUS",
            "EQoJbWF4X2RlcHRoGAMgASgFEiMKG251bV9sYXllcnNfYmVmb3JlX3ByZWRp",
            "Y3RvchgEIAEoBRITCgt1c2VfZHJvcG91dBgFIAEoCBIgChhkcm9wb3V0X2tl",
            "ZXBfcHJvYmFiaWxpdHkYBiABKAISEwoLa2VybmVsX3NpemUYByABKAUSFQoN",
            "Ym94X2NvZGVfc2l6ZRgIIAEoBRIfChdhcHBseV9zaWdtb2lkX3RvX3Njb3Jl",
            "cxgJIAEoCBIiChpjbGFzc19wcmVkaWN0aW9uX2JpYXNfaW5pdBgKIAEoAhIV",
            "Cg11c2VfZGVwdGh3aXNlGAsgASgIEmoKGGJveF9lbmNvZGluZ3NfY2xpcF9y",
            "YW5nZRgMIAEoCzJILm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLkNvbnZvbHV0",
            "aW9uYWxCb3hQcmVkaWN0b3IuQm94RW5jb2RpbmdzQ2xpcFJhbmdlGjEKFUJv",
            "eEVuY29kaW5nc0NsaXBSYW5nZRILCgNtaW4YASABKAISCwoDbWF4GAIgASgC",
            "IpkFCiVXZWlnaHRTaGFyZWRDb252b2x1dGlvbmFsQm94UHJlZGljdG9yEj4K",
            "EGNvbnZfaHlwZXJwYXJhbXMYASABKAsyJC5vYmplY3RfZGV0ZWN0aW9uLnBy",
            "b3Rvcy5IeXBlcnBhcmFtcxIjChtudW1fbGF5ZXJzX2JlZm9yZV9wcmVkaWN0",
            "b3IYBCABKAUSDQoFZGVwdGgYAiABKAUSEwoLa2VybmVsX3NpemUYByABKAUS",
            "FQoNYm94X2NvZGVfc2l6ZRgIIAEoBRIiChpjbGFzc19wcmVkaWN0aW9uX2Jp",
            "YXNfaW5pdBgKIAEoAhITCgt1c2VfZHJvcG91dBgLIAEoCBIgChhkcm9wb3V0",
            "X2tlZXBfcHJvYmFiaWxpdHkYDCABKAISHgoWc2hhcmVfcHJlZGljdGlvbl90",
            "b3dlchgNIAEoCBIVCg11c2VfZGVwdGh3aXNlGA4gASgIEmYKD3Njb3JlX2Nv",
            "bnZlcnRlchgQIAEoDjJNLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLldlaWdo",
            "dFNoYXJlZENvbnZvbHV0aW9uYWxCb3hQcmVkaWN0b3IuU2NvcmVDb252ZXJ0",
            "ZXISdgoYYm94X2VuY29kaW5nc19jbGlwX3JhbmdlGBEgASgLMlQub2JqZWN0",
            "X2RldGVjdGlvbi5wcm90b3MuV2VpZ2h0U2hhcmVkQ29udm9sdXRpb25hbEJv",
            "eFByZWRpY3Rvci5Cb3hFbmNvZGluZ3NDbGlwUmFuZ2UaMQoVQm94RW5jb2Rp",
            "bmdzQ2xpcFJhbmdlEgsKA21pbhgBIAEoAhILCgNtYXgYAiABKAIiKwoOU2Nv",
            "cmVDb252ZXJ0ZXISDAoISURFTlRJVFkQABILCgdTSUdNT0lEEAEi/QMKFE1h",
            "c2tSQ05OQm94UHJlZGljdG9yEjwKDmZjX2h5cGVycGFyYW1zGAEgASgLMiQu",
            "b2JqZWN0X2RldGVjdGlvbi5wcm90b3MuSHlwZXJwYXJhbXMSEwoLdXNlX2Ry",
            "b3BvdXQYAiABKAgSIAoYZHJvcG91dF9rZWVwX3Byb2JhYmlsaXR5GAMgASgC",
            "EhUKDWJveF9jb2RlX3NpemUYBCABKAUSPgoQY29udl9oeXBlcnBhcmFtcxgF",
            "IAEoCzIkLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLkh5cGVycGFyYW1zEh4K",
            "FnByZWRpY3RfaW5zdGFuY2VfbWFza3MYBiABKAgSIgoabWFza19wcmVkaWN0",
            "aW9uX2NvbnZfZGVwdGgYByABKAUSGQoRcHJlZGljdF9rZXlwb2ludHMYCCAB",
            "KAgSEwoLbWFza19oZWlnaHQYCSABKAUSEgoKbWFza193aWR0aBgKIAEoBRIn",
            "Ch9tYXNrX3ByZWRpY3Rpb25fbnVtX2NvbnZfbGF5ZXJzGAsgASgFEiAKGG1h",
            "c2tzX2FyZV9jbGFzc19hZ25vc3RpYxgMIAEoCBIgChhzaGFyZV9ib3hfYWNy",
            "b3NzX2NsYXNzZXMYDSABKAgSJAocY29udm9sdmVfdGhlbl91cHNhbXBsZV9t",
            "YXNrcxgOIAEoCCLiAQoQUmZjbkJveFByZWRpY3RvchI+ChBjb252X2h5cGVy",
            "cGFyYW1zGAEgASgLMiQub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuSHlwZXJw",
            "YXJhbXMSHwoXbnVtX3NwYXRpYWxfYmluc19oZWlnaHQYAiABKAUSHgoWbnVt",
            "X3NwYXRpYWxfYmluc193aWR0aBgDIAEoBRINCgVkZXB0aBgEIAEoBRIVCg1i",
            "b3hfY29kZV9zaXplGAUgASgFEhMKC2Nyb3BfaGVpZ2h0GAYgASgFEhIKCmNy",
            "b3Bfd2lkdGgYByABKAViBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorflow.Models.ObjectDetection.Protos.HyperparamsReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictor), global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictor.Parser, new[]{ "ConvolutionalBoxPredictor", "MaskRcnnBoxPredictor", "RfcnBoxPredictor", "WeightSharedConvolutionalBoxPredictor" }, new[]{ "BoxPredictorOneof" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor), global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor.Parser, new[]{ "ConvHyperparams", "MinDepth", "MaxDepth", "NumLayersBeforePredictor", "UseDropout", "DropoutKeepProbability", "KernelSize", "BoxCodeSize", "ApplySigmoidToScores", "ClassPredictionBiasInit", "UseDepthwise", "BoxEncodingsClipRange" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor.Types.BoxEncodingsClipRange), global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor.Types.BoxEncodingsClipRange.Parser, new[]{ "Min", "Max" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor), global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Parser, new[]{ "ConvHyperparams", "NumLayersBeforePredictor", "Depth", "KernelSize", "BoxCodeSize", "ClassPredictionBiasInit", "UseDropout", "DropoutKeepProbability", "SharePredictionTower", "UseDepthwise", "ScoreConverter", "BoxEncodingsClipRange" }, null, new[]{ typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.ScoreConverter) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.BoxEncodingsClipRange), global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.BoxEncodingsClipRange.Parser, new[]{ "Min", "Max" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.MaskRCNNBoxPredictor), global::Tensorflow.Models.ObjectDetection.Protos.MaskRCNNBoxPredictor.Parser, new[]{ "FcHyperparams", "UseDropout", "DropoutKeepProbability", "BoxCodeSize", "ConvHyperparams", "PredictInstanceMasks", "MaskPredictionConvDepth", "PredictKeypoints", "MaskHeight", "MaskWidth", "MaskPredictionNumConvLayers", "MasksAreClassAgnostic", "ShareBoxAcrossClasses", "ConvolveThenUpsampleMasks" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RfcnBoxPredictor), global::Tensorflow.Models.ObjectDetection.Protos.RfcnBoxPredictor.Parser, new[]{ "ConvHyperparams", "NumSpatialBinsHeight", "NumSpatialBinsWidth", "Depth", "BoxCodeSize", "CropHeight", "CropWidth" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration proto for box predictor. See core/box_predictor.py for details.
  /// </summary>
  public sealed partial class BoxPredictor : pb::IMessage<BoxPredictor> {
    private static readonly pb::MessageParser<BoxPredictor> _parser = new pb::MessageParser<BoxPredictor>(() => new BoxPredictor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BoxPredictor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BoxPredictor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BoxPredictor(BoxPredictor other) : this() {
      switch (other.BoxPredictorOneofCase) {
        case BoxPredictorOneofOneofCase.ConvolutionalBoxPredictor:
          ConvolutionalBoxPredictor = other.ConvolutionalBoxPredictor.Clone();
          break;
        case BoxPredictorOneofOneofCase.MaskRcnnBoxPredictor:
          MaskRcnnBoxPredictor = other.MaskRcnnBoxPredictor.Clone();
          break;
        case BoxPredictorOneofOneofCase.RfcnBoxPredictor:
          RfcnBoxPredictor = other.RfcnBoxPredictor.Clone();
          break;
        case BoxPredictorOneofOneofCase.WeightSharedConvolutionalBoxPredictor:
          WeightSharedConvolutionalBoxPredictor = other.WeightSharedConvolutionalBoxPredictor.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BoxPredictor Clone() {
      return new BoxPredictor(this);
    }

    /// <summary>Field number for the "convolutional_box_predictor" field.</summary>
    public const int ConvolutionalBoxPredictorFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor ConvolutionalBoxPredictor {
      get { return boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.ConvolutionalBoxPredictor ? (global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor) boxPredictorOneof_ : null; }
      set {
        boxPredictorOneof_ = value;
        boxPredictorOneofCase_ = value == null ? BoxPredictorOneofOneofCase.None : BoxPredictorOneofOneofCase.ConvolutionalBoxPredictor;
      }
    }

    /// <summary>Field number for the "mask_rcnn_box_predictor" field.</summary>
    public const int MaskRcnnBoxPredictorFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.MaskRCNNBoxPredictor MaskRcnnBoxPredictor {
      get { return boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.MaskRcnnBoxPredictor ? (global::Tensorflow.Models.ObjectDetection.Protos.MaskRCNNBoxPredictor) boxPredictorOneof_ : null; }
      set {
        boxPredictorOneof_ = value;
        boxPredictorOneofCase_ = value == null ? BoxPredictorOneofOneofCase.None : BoxPredictorOneofOneofCase.MaskRcnnBoxPredictor;
      }
    }

    /// <summary>Field number for the "rfcn_box_predictor" field.</summary>
    public const int RfcnBoxPredictorFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RfcnBoxPredictor RfcnBoxPredictor {
      get { return boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.RfcnBoxPredictor ? (global::Tensorflow.Models.ObjectDetection.Protos.RfcnBoxPredictor) boxPredictorOneof_ : null; }
      set {
        boxPredictorOneof_ = value;
        boxPredictorOneofCase_ = value == null ? BoxPredictorOneofOneofCase.None : BoxPredictorOneofOneofCase.RfcnBoxPredictor;
      }
    }

    /// <summary>Field number for the "weight_shared_convolutional_box_predictor" field.</summary>
    public const int WeightSharedConvolutionalBoxPredictorFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor WeightSharedConvolutionalBoxPredictor {
      get { return boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.WeightSharedConvolutionalBoxPredictor ? (global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor) boxPredictorOneof_ : null; }
      set {
        boxPredictorOneof_ = value;
        boxPredictorOneofCase_ = value == null ? BoxPredictorOneofOneofCase.None : BoxPredictorOneofOneofCase.WeightSharedConvolutionalBoxPredictor;
      }
    }

    private object boxPredictorOneof_;
    /// <summary>Enum of possible cases for the "box_predictor_oneof" oneof.</summary>
    public enum BoxPredictorOneofOneofCase {
      None = 0,
      ConvolutionalBoxPredictor = 1,
      MaskRcnnBoxPredictor = 2,
      RfcnBoxPredictor = 3,
      WeightSharedConvolutionalBoxPredictor = 4,
    }
    private BoxPredictorOneofOneofCase boxPredictorOneofCase_ = BoxPredictorOneofOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BoxPredictorOneofOneofCase BoxPredictorOneofCase {
      get { return boxPredictorOneofCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearBoxPredictorOneof() {
      boxPredictorOneofCase_ = BoxPredictorOneofOneofCase.None;
      boxPredictorOneof_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BoxPredictor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BoxPredictor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConvolutionalBoxPredictor, other.ConvolutionalBoxPredictor)) return false;
      if (!object.Equals(MaskRcnnBoxPredictor, other.MaskRcnnBoxPredictor)) return false;
      if (!object.Equals(RfcnBoxPredictor, other.RfcnBoxPredictor)) return false;
      if (!object.Equals(WeightSharedConvolutionalBoxPredictor, other.WeightSharedConvolutionalBoxPredictor)) return false;
      if (BoxPredictorOneofCase != other.BoxPredictorOneofCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.ConvolutionalBoxPredictor) hash ^= ConvolutionalBoxPredictor.GetHashCode();
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.MaskRcnnBoxPredictor) hash ^= MaskRcnnBoxPredictor.GetHashCode();
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.RfcnBoxPredictor) hash ^= RfcnBoxPredictor.GetHashCode();
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.WeightSharedConvolutionalBoxPredictor) hash ^= WeightSharedConvolutionalBoxPredictor.GetHashCode();
      hash ^= (int) boxPredictorOneofCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.ConvolutionalBoxPredictor) {
        output.WriteRawTag(10);
        output.WriteMessage(ConvolutionalBoxPredictor);
      }
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.MaskRcnnBoxPredictor) {
        output.WriteRawTag(18);
        output.WriteMessage(MaskRcnnBoxPredictor);
      }
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.RfcnBoxPredictor) {
        output.WriteRawTag(26);
        output.WriteMessage(RfcnBoxPredictor);
      }
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.WeightSharedConvolutionalBoxPredictor) {
        output.WriteRawTag(34);
        output.WriteMessage(WeightSharedConvolutionalBoxPredictor);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.ConvolutionalBoxPredictor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConvolutionalBoxPredictor);
      }
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.MaskRcnnBoxPredictor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MaskRcnnBoxPredictor);
      }
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.RfcnBoxPredictor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RfcnBoxPredictor);
      }
      if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.WeightSharedConvolutionalBoxPredictor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightSharedConvolutionalBoxPredictor);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BoxPredictor other) {
      if (other == null) {
        return;
      }
      switch (other.BoxPredictorOneofCase) {
        case BoxPredictorOneofOneofCase.ConvolutionalBoxPredictor:
          if (ConvolutionalBoxPredictor == null) {
            ConvolutionalBoxPredictor = new global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor();
          }
          ConvolutionalBoxPredictor.MergeFrom(other.ConvolutionalBoxPredictor);
          break;
        case BoxPredictorOneofOneofCase.MaskRcnnBoxPredictor:
          if (MaskRcnnBoxPredictor == null) {
            MaskRcnnBoxPredictor = new global::Tensorflow.Models.ObjectDetection.Protos.MaskRCNNBoxPredictor();
          }
          MaskRcnnBoxPredictor.MergeFrom(other.MaskRcnnBoxPredictor);
          break;
        case BoxPredictorOneofOneofCase.RfcnBoxPredictor:
          if (RfcnBoxPredictor == null) {
            RfcnBoxPredictor = new global::Tensorflow.Models.ObjectDetection.Protos.RfcnBoxPredictor();
          }
          RfcnBoxPredictor.MergeFrom(other.RfcnBoxPredictor);
          break;
        case BoxPredictorOneofOneofCase.WeightSharedConvolutionalBoxPredictor:
          if (WeightSharedConvolutionalBoxPredictor == null) {
            WeightSharedConvolutionalBoxPredictor = new global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor();
          }
          WeightSharedConvolutionalBoxPredictor.MergeFrom(other.WeightSharedConvolutionalBoxPredictor);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor();
            if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.ConvolutionalBoxPredictor) {
              subBuilder.MergeFrom(ConvolutionalBoxPredictor);
            }
            input.ReadMessage(subBuilder);
            ConvolutionalBoxPredictor = subBuilder;
            break;
          }
          case 18: {
            global::Tensorflow.Models.ObjectDetection.Protos.MaskRCNNBoxPredictor subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.MaskRCNNBoxPredictor();
            if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.MaskRcnnBoxPredictor) {
              subBuilder.MergeFrom(MaskRcnnBoxPredictor);
            }
            input.ReadMessage(subBuilder);
            MaskRcnnBoxPredictor = subBuilder;
            break;
          }
          case 26: {
            global::Tensorflow.Models.ObjectDetection.Protos.RfcnBoxPredictor subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RfcnBoxPredictor();
            if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.RfcnBoxPredictor) {
              subBuilder.MergeFrom(RfcnBoxPredictor);
            }
            input.ReadMessage(subBuilder);
            RfcnBoxPredictor = subBuilder;
            break;
          }
          case 34: {
            global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor();
            if (boxPredictorOneofCase_ == BoxPredictorOneofOneofCase.WeightSharedConvolutionalBoxPredictor) {
              subBuilder.MergeFrom(WeightSharedConvolutionalBoxPredictor);
            }
            input.ReadMessage(subBuilder);
            WeightSharedConvolutionalBoxPredictor = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration proto for Convolutional box predictor.
  /// Next id: 13
  /// </summary>
  public sealed partial class ConvolutionalBoxPredictor : pb::IMessage<ConvolutionalBoxPredictor> {
    private static readonly pb::MessageParser<ConvolutionalBoxPredictor> _parser = new pb::MessageParser<ConvolutionalBoxPredictor>(() => new ConvolutionalBoxPredictor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConvolutionalBoxPredictor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictorReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvolutionalBoxPredictor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvolutionalBoxPredictor(ConvolutionalBoxPredictor other) : this() {
      convHyperparams_ = other.convHyperparams_ != null ? other.convHyperparams_.Clone() : null;
      minDepth_ = other.minDepth_;
      maxDepth_ = other.maxDepth_;
      numLayersBeforePredictor_ = other.numLayersBeforePredictor_;
      useDropout_ = other.useDropout_;
      dropoutKeepProbability_ = other.dropoutKeepProbability_;
      kernelSize_ = other.kernelSize_;
      boxCodeSize_ = other.boxCodeSize_;
      applySigmoidToScores_ = other.applySigmoidToScores_;
      classPredictionBiasInit_ = other.classPredictionBiasInit_;
      useDepthwise_ = other.useDepthwise_;
      boxEncodingsClipRange_ = other.boxEncodingsClipRange_ != null ? other.boxEncodingsClipRange_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvolutionalBoxPredictor Clone() {
      return new ConvolutionalBoxPredictor(this);
    }

    /// <summary>Field number for the "conv_hyperparams" field.</summary>
    public const int ConvHyperparamsFieldNumber = 1;
    private global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams convHyperparams_;
    /// <summary>
    /// Hyperparameters for convolution ops used in the box predictor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams ConvHyperparams {
      get { return convHyperparams_; }
      set {
        convHyperparams_ = value;
      }
    }

    /// <summary>Field number for the "min_depth" field.</summary>
    public const int MinDepthFieldNumber = 2;
    private int minDepth_;
    /// <summary>
    /// Minimum feature depth prior to predicting box encodings and class
    /// predictions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinDepth {
      get { return minDepth_; }
      set {
        minDepth_ = value;
      }
    }

    /// <summary>Field number for the "max_depth" field.</summary>
    public const int MaxDepthFieldNumber = 3;
    private int maxDepth_;
    /// <summary>
    /// Maximum feature depth prior to predicting box encodings and class
    /// predictions. If max_depth is set to 0, no additional feature map will be
    /// inserted before location and class predictions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxDepth {
      get { return maxDepth_; }
      set {
        maxDepth_ = value;
      }
    }

    /// <summary>Field number for the "num_layers_before_predictor" field.</summary>
    public const int NumLayersBeforePredictorFieldNumber = 4;
    private int numLayersBeforePredictor_;
    /// <summary>
    /// Number of the additional conv layers before the predictor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumLayersBeforePredictor {
      get { return numLayersBeforePredictor_; }
      set {
        numLayersBeforePredictor_ = value;
      }
    }

    /// <summary>Field number for the "use_dropout" field.</summary>
    public const int UseDropoutFieldNumber = 5;
    private bool useDropout_;
    /// <summary>
    /// Whether to use dropout for class prediction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseDropout {
      get { return useDropout_; }
      set {
        useDropout_ = value;
      }
    }

    /// <summary>Field number for the "dropout_keep_probability" field.</summary>
    public const int DropoutKeepProbabilityFieldNumber = 6;
    private float dropoutKeepProbability_;
    /// <summary>
    /// Keep probability for dropout
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DropoutKeepProbability {
      get { return dropoutKeepProbability_; }
      set {
        dropoutKeepProbability_ = value;
      }
    }

    /// <summary>Field number for the "kernel_size" field.</summary>
    public const int KernelSizeFieldNumber = 7;
    private int kernelSize_;
    /// <summary>
    /// Size of final convolution kernel. If the spatial resolution of the feature
    /// map is smaller than the kernel size, then the kernel size is set to
    /// min(feature_width, feature_height).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int KernelSize {
      get { return kernelSize_; }
      set {
        kernelSize_ = value;
      }
    }

    /// <summary>Field number for the "box_code_size" field.</summary>
    public const int BoxCodeSizeFieldNumber = 8;
    private int boxCodeSize_;
    /// <summary>
    /// Size of the encoding for boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int BoxCodeSize {
      get { return boxCodeSize_; }
      set {
        boxCodeSize_ = value;
      }
    }

    /// <summary>Field number for the "apply_sigmoid_to_scores" field.</summary>
    public const int ApplySigmoidToScoresFieldNumber = 9;
    private bool applySigmoidToScores_;
    /// <summary>
    /// Whether to apply sigmoid to the output of class predictions.
    /// TODO(jonathanhuang): Do we need this since we have a post processing
    /// module.?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ApplySigmoidToScores {
      get { return applySigmoidToScores_; }
      set {
        applySigmoidToScores_ = value;
      }
    }

    /// <summary>Field number for the "class_prediction_bias_init" field.</summary>
    public const int ClassPredictionBiasInitFieldNumber = 10;
    private float classPredictionBiasInit_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ClassPredictionBiasInit {
      get { return classPredictionBiasInit_; }
      set {
        classPredictionBiasInit_ = value;
      }
    }

    /// <summary>Field number for the "use_depthwise" field.</summary>
    public const int UseDepthwiseFieldNumber = 11;
    private bool useDepthwise_;
    /// <summary>
    /// Whether to use depthwise separable convolution for box predictor layers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseDepthwise {
      get { return useDepthwise_; }
      set {
        useDepthwise_ = value;
      }
    }

    /// <summary>Field number for the "box_encodings_clip_range" field.</summary>
    public const int BoxEncodingsClipRangeFieldNumber = 12;
    private global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor.Types.BoxEncodingsClipRange boxEncodingsClipRange_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor.Types.BoxEncodingsClipRange BoxEncodingsClipRange {
      get { return boxEncodingsClipRange_; }
      set {
        boxEncodingsClipRange_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConvolutionalBoxPredictor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConvolutionalBoxPredictor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConvHyperparams, other.ConvHyperparams)) return false;
      if (MinDepth != other.MinDepth) return false;
      if (MaxDepth != other.MaxDepth) return false;
      if (NumLayersBeforePredictor != other.NumLayersBeforePredictor) return false;
      if (UseDropout != other.UseDropout) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DropoutKeepProbability, other.DropoutKeepProbability)) return false;
      if (KernelSize != other.KernelSize) return false;
      if (BoxCodeSize != other.BoxCodeSize) return false;
      if (ApplySigmoidToScores != other.ApplySigmoidToScores) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ClassPredictionBiasInit, other.ClassPredictionBiasInit)) return false;
      if (UseDepthwise != other.UseDepthwise) return false;
      if (!object.Equals(BoxEncodingsClipRange, other.BoxEncodingsClipRange)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (convHyperparams_ != null) hash ^= ConvHyperparams.GetHashCode();
      if (MinDepth != 0) hash ^= MinDepth.GetHashCode();
      if (MaxDepth != 0) hash ^= MaxDepth.GetHashCode();
      if (NumLayersBeforePredictor != 0) hash ^= NumLayersBeforePredictor.GetHashCode();
      if (UseDropout != false) hash ^= UseDropout.GetHashCode();
      if (DropoutKeepProbability != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DropoutKeepProbability);
      if (KernelSize != 0) hash ^= KernelSize.GetHashCode();
      if (BoxCodeSize != 0) hash ^= BoxCodeSize.GetHashCode();
      if (ApplySigmoidToScores != false) hash ^= ApplySigmoidToScores.GetHashCode();
      if (ClassPredictionBiasInit != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ClassPredictionBiasInit);
      if (UseDepthwise != false) hash ^= UseDepthwise.GetHashCode();
      if (boxEncodingsClipRange_ != null) hash ^= BoxEncodingsClipRange.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (convHyperparams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConvHyperparams);
      }
      if (MinDepth != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(MinDepth);
      }
      if (MaxDepth != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(MaxDepth);
      }
      if (NumLayersBeforePredictor != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(NumLayersBeforePredictor);
      }
      if (UseDropout != false) {
        output.WriteRawTag(40);
        output.WriteBool(UseDropout);
      }
      if (DropoutKeepProbability != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(DropoutKeepProbability);
      }
      if (KernelSize != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(KernelSize);
      }
      if (BoxCodeSize != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(BoxCodeSize);
      }
      if (ApplySigmoidToScores != false) {
        output.WriteRawTag(72);
        output.WriteBool(ApplySigmoidToScores);
      }
      if (ClassPredictionBiasInit != 0F) {
        output.WriteRawTag(85);
        output.WriteFloat(ClassPredictionBiasInit);
      }
      if (UseDepthwise != false) {
        output.WriteRawTag(88);
        output.WriteBool(UseDepthwise);
      }
      if (boxEncodingsClipRange_ != null) {
        output.WriteRawTag(98);
        output.WriteMessage(BoxEncodingsClipRange);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (convHyperparams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConvHyperparams);
      }
      if (MinDepth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinDepth);
      }
      if (MaxDepth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxDepth);
      }
      if (NumLayersBeforePredictor != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumLayersBeforePredictor);
      }
      if (UseDropout != false) {
        size += 1 + 1;
      }
      if (DropoutKeepProbability != 0F) {
        size += 1 + 4;
      }
      if (KernelSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(KernelSize);
      }
      if (BoxCodeSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(BoxCodeSize);
      }
      if (ApplySigmoidToScores != false) {
        size += 1 + 1;
      }
      if (ClassPredictionBiasInit != 0F) {
        size += 1 + 4;
      }
      if (UseDepthwise != false) {
        size += 1 + 1;
      }
      if (boxEncodingsClipRange_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoxEncodingsClipRange);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConvolutionalBoxPredictor other) {
      if (other == null) {
        return;
      }
      if (other.convHyperparams_ != null) {
        if (convHyperparams_ == null) {
          convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
        }
        ConvHyperparams.MergeFrom(other.ConvHyperparams);
      }
      if (other.MinDepth != 0) {
        MinDepth = other.MinDepth;
      }
      if (other.MaxDepth != 0) {
        MaxDepth = other.MaxDepth;
      }
      if (other.NumLayersBeforePredictor != 0) {
        NumLayersBeforePredictor = other.NumLayersBeforePredictor;
      }
      if (other.UseDropout != false) {
        UseDropout = other.UseDropout;
      }
      if (other.DropoutKeepProbability != 0F) {
        DropoutKeepProbability = other.DropoutKeepProbability;
      }
      if (other.KernelSize != 0) {
        KernelSize = other.KernelSize;
      }
      if (other.BoxCodeSize != 0) {
        BoxCodeSize = other.BoxCodeSize;
      }
      if (other.ApplySigmoidToScores != false) {
        ApplySigmoidToScores = other.ApplySigmoidToScores;
      }
      if (other.ClassPredictionBiasInit != 0F) {
        ClassPredictionBiasInit = other.ClassPredictionBiasInit;
      }
      if (other.UseDepthwise != false) {
        UseDepthwise = other.UseDepthwise;
      }
      if (other.boxEncodingsClipRange_ != null) {
        if (boxEncodingsClipRange_ == null) {
          boxEncodingsClipRange_ = new global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor.Types.BoxEncodingsClipRange();
        }
        BoxEncodingsClipRange.MergeFrom(other.BoxEncodingsClipRange);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (convHyperparams_ == null) {
              convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
            }
            input.ReadMessage(convHyperparams_);
            break;
          }
          case 16: {
            MinDepth = input.ReadInt32();
            break;
          }
          case 24: {
            MaxDepth = input.ReadInt32();
            break;
          }
          case 32: {
            NumLayersBeforePredictor = input.ReadInt32();
            break;
          }
          case 40: {
            UseDropout = input.ReadBool();
            break;
          }
          case 53: {
            DropoutKeepProbability = input.ReadFloat();
            break;
          }
          case 56: {
            KernelSize = input.ReadInt32();
            break;
          }
          case 64: {
            BoxCodeSize = input.ReadInt32();
            break;
          }
          case 72: {
            ApplySigmoidToScores = input.ReadBool();
            break;
          }
          case 85: {
            ClassPredictionBiasInit = input.ReadFloat();
            break;
          }
          case 88: {
            UseDepthwise = input.ReadBool();
            break;
          }
          case 98: {
            if (boxEncodingsClipRange_ == null) {
              boxEncodingsClipRange_ = new global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor.Types.BoxEncodingsClipRange();
            }
            input.ReadMessage(boxEncodingsClipRange_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ConvolutionalBoxPredictor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// If specified, apply clipping to box encodings.
      /// </summary>
      public sealed partial class BoxEncodingsClipRange : pb::IMessage<BoxEncodingsClipRange> {
        private static readonly pb::MessageParser<BoxEncodingsClipRange> _parser = new pb::MessageParser<BoxEncodingsClipRange>(() => new BoxEncodingsClipRange());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BoxEncodingsClipRange> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.Models.ObjectDetection.Protos.ConvolutionalBoxPredictor.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoxEncodingsClipRange() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoxEncodingsClipRange(BoxEncodingsClipRange other) : this() {
          min_ = other.min_;
          max_ = other.max_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoxEncodingsClipRange Clone() {
          return new BoxEncodingsClipRange(this);
        }

        /// <summary>Field number for the "min" field.</summary>
        public const int MinFieldNumber = 1;
        private float min_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Min {
          get { return min_; }
          set {
            min_ = value;
          }
        }

        /// <summary>Field number for the "max" field.</summary>
        public const int MaxFieldNumber = 2;
        private float max_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Max {
          get { return max_; }
          set {
            max_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as BoxEncodingsClipRange);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BoxEncodingsClipRange other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Min, other.Min)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Max, other.Max)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Min != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Min);
          if (Max != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Max);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Min != 0F) {
            output.WriteRawTag(13);
            output.WriteFloat(Min);
          }
          if (Max != 0F) {
            output.WriteRawTag(21);
            output.WriteFloat(Max);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Min != 0F) {
            size += 1 + 4;
          }
          if (Max != 0F) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BoxEncodingsClipRange other) {
          if (other == null) {
            return;
          }
          if (other.Min != 0F) {
            Min = other.Min;
          }
          if (other.Max != 0F) {
            Max = other.Max;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                Min = input.ReadFloat();
                break;
              }
              case 21: {
                Max = input.ReadFloat();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Configuration proto for weight shared convolutional box predictor.
  /// Next id: 18
  /// </summary>
  public sealed partial class WeightSharedConvolutionalBoxPredictor : pb::IMessage<WeightSharedConvolutionalBoxPredictor> {
    private static readonly pb::MessageParser<WeightSharedConvolutionalBoxPredictor> _parser = new pb::MessageParser<WeightSharedConvolutionalBoxPredictor>(() => new WeightSharedConvolutionalBoxPredictor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightSharedConvolutionalBoxPredictor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictorReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightSharedConvolutionalBoxPredictor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightSharedConvolutionalBoxPredictor(WeightSharedConvolutionalBoxPredictor other) : this() {
      convHyperparams_ = other.convHyperparams_ != null ? other.convHyperparams_.Clone() : null;
      numLayersBeforePredictor_ = other.numLayersBeforePredictor_;
      depth_ = other.depth_;
      kernelSize_ = other.kernelSize_;
      boxCodeSize_ = other.boxCodeSize_;
      classPredictionBiasInit_ = other.classPredictionBiasInit_;
      useDropout_ = other.useDropout_;
      dropoutKeepProbability_ = other.dropoutKeepProbability_;
      sharePredictionTower_ = other.sharePredictionTower_;
      useDepthwise_ = other.useDepthwise_;
      scoreConverter_ = other.scoreConverter_;
      boxEncodingsClipRange_ = other.boxEncodingsClipRange_ != null ? other.boxEncodingsClipRange_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightSharedConvolutionalBoxPredictor Clone() {
      return new WeightSharedConvolutionalBoxPredictor(this);
    }

    /// <summary>Field number for the "conv_hyperparams" field.</summary>
    public const int ConvHyperparamsFieldNumber = 1;
    private global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams convHyperparams_;
    /// <summary>
    /// Hyperparameters for convolution ops used in the box predictor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams ConvHyperparams {
      get { return convHyperparams_; }
      set {
        convHyperparams_ = value;
      }
    }

    /// <summary>Field number for the "num_layers_before_predictor" field.</summary>
    public const int NumLayersBeforePredictorFieldNumber = 4;
    private int numLayersBeforePredictor_;
    /// <summary>
    /// Number of the additional conv layers before the predictor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumLayersBeforePredictor {
      get { return numLayersBeforePredictor_; }
      set {
        numLayersBeforePredictor_ = value;
      }
    }

    /// <summary>Field number for the "depth" field.</summary>
    public const int DepthFieldNumber = 2;
    private int depth_;
    /// <summary>
    /// Output depth for the convolution ops prior to predicting box encodings
    /// and class predictions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Depth {
      get { return depth_; }
      set {
        depth_ = value;
      }
    }

    /// <summary>Field number for the "kernel_size" field.</summary>
    public const int KernelSizeFieldNumber = 7;
    private int kernelSize_;
    /// <summary>
    /// Size of final convolution kernel. If the spatial resolution of the feature
    /// map is smaller than the kernel size, then the kernel size is set to
    /// min(feature_width, feature_height).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int KernelSize {
      get { return kernelSize_; }
      set {
        kernelSize_ = value;
      }
    }

    /// <summary>Field number for the "box_code_size" field.</summary>
    public const int BoxCodeSizeFieldNumber = 8;
    private int boxCodeSize_;
    /// <summary>
    /// Size of the encoding for boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int BoxCodeSize {
      get { return boxCodeSize_; }
      set {
        boxCodeSize_ = value;
      }
    }

    /// <summary>Field number for the "class_prediction_bias_init" field.</summary>
    public const int ClassPredictionBiasInitFieldNumber = 10;
    private float classPredictionBiasInit_;
    /// <summary>
    /// Bias initialization for class prediction. It has been show to stabilize
    /// training where there are large number of negative boxes. See
    /// https://arxiv.org/abs/1708.02002 for details.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ClassPredictionBiasInit {
      get { return classPredictionBiasInit_; }
      set {
        classPredictionBiasInit_ = value;
      }
    }

    /// <summary>Field number for the "use_dropout" field.</summary>
    public const int UseDropoutFieldNumber = 11;
    private bool useDropout_;
    /// <summary>
    /// Whether to use dropout for class prediction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseDropout {
      get { return useDropout_; }
      set {
        useDropout_ = value;
      }
    }

    /// <summary>Field number for the "dropout_keep_probability" field.</summary>
    public const int DropoutKeepProbabilityFieldNumber = 12;
    private float dropoutKeepProbability_;
    /// <summary>
    /// Keep probability for dropout.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DropoutKeepProbability {
      get { return dropoutKeepProbability_; }
      set {
        dropoutKeepProbability_ = value;
      }
    }

    /// <summary>Field number for the "share_prediction_tower" field.</summary>
    public const int SharePredictionTowerFieldNumber = 13;
    private bool sharePredictionTower_;
    /// <summary>
    /// Whether to share the multi-layer tower between box prediction and class
    /// prediction heads.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SharePredictionTower {
      get { return sharePredictionTower_; }
      set {
        sharePredictionTower_ = value;
      }
    }

    /// <summary>Field number for the "use_depthwise" field.</summary>
    public const int UseDepthwiseFieldNumber = 14;
    private bool useDepthwise_;
    /// <summary>
    /// Whether to use depthwise separable convolution for box predictor layers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseDepthwise {
      get { return useDepthwise_; }
      set {
        useDepthwise_ = value;
      }
    }

    /// <summary>Field number for the "score_converter" field.</summary>
    public const int ScoreConverterFieldNumber = 16;
    private global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.ScoreConverter scoreConverter_ = 0;
    /// <summary>
    /// Callable elementwise score converter at inference time.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.ScoreConverter ScoreConverter {
      get { return scoreConverter_; }
      set {
        scoreConverter_ = value;
      }
    }

    /// <summary>Field number for the "box_encodings_clip_range" field.</summary>
    public const int BoxEncodingsClipRangeFieldNumber = 17;
    private global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.BoxEncodingsClipRange boxEncodingsClipRange_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.BoxEncodingsClipRange BoxEncodingsClipRange {
      get { return boxEncodingsClipRange_; }
      set {
        boxEncodingsClipRange_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightSharedConvolutionalBoxPredictor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightSharedConvolutionalBoxPredictor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConvHyperparams, other.ConvHyperparams)) return false;
      if (NumLayersBeforePredictor != other.NumLayersBeforePredictor) return false;
      if (Depth != other.Depth) return false;
      if (KernelSize != other.KernelSize) return false;
      if (BoxCodeSize != other.BoxCodeSize) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ClassPredictionBiasInit, other.ClassPredictionBiasInit)) return false;
      if (UseDropout != other.UseDropout) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DropoutKeepProbability, other.DropoutKeepProbability)) return false;
      if (SharePredictionTower != other.SharePredictionTower) return false;
      if (UseDepthwise != other.UseDepthwise) return false;
      if (ScoreConverter != other.ScoreConverter) return false;
      if (!object.Equals(BoxEncodingsClipRange, other.BoxEncodingsClipRange)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (convHyperparams_ != null) hash ^= ConvHyperparams.GetHashCode();
      if (NumLayersBeforePredictor != 0) hash ^= NumLayersBeforePredictor.GetHashCode();
      if (Depth != 0) hash ^= Depth.GetHashCode();
      if (KernelSize != 0) hash ^= KernelSize.GetHashCode();
      if (BoxCodeSize != 0) hash ^= BoxCodeSize.GetHashCode();
      if (ClassPredictionBiasInit != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ClassPredictionBiasInit);
      if (UseDropout != false) hash ^= UseDropout.GetHashCode();
      if (DropoutKeepProbability != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DropoutKeepProbability);
      if (SharePredictionTower != false) hash ^= SharePredictionTower.GetHashCode();
      if (UseDepthwise != false) hash ^= UseDepthwise.GetHashCode();
      if (ScoreConverter != 0) hash ^= ScoreConverter.GetHashCode();
      if (boxEncodingsClipRange_ != null) hash ^= BoxEncodingsClipRange.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (convHyperparams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConvHyperparams);
      }
      if (Depth != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(Depth);
      }
      if (NumLayersBeforePredictor != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(NumLayersBeforePredictor);
      }
      if (KernelSize != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(KernelSize);
      }
      if (BoxCodeSize != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(BoxCodeSize);
      }
      if (ClassPredictionBiasInit != 0F) {
        output.WriteRawTag(85);
        output.WriteFloat(ClassPredictionBiasInit);
      }
      if (UseDropout != false) {
        output.WriteRawTag(88);
        output.WriteBool(UseDropout);
      }
      if (DropoutKeepProbability != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(DropoutKeepProbability);
      }
      if (SharePredictionTower != false) {
        output.WriteRawTag(104);
        output.WriteBool(SharePredictionTower);
      }
      if (UseDepthwise != false) {
        output.WriteRawTag(112);
        output.WriteBool(UseDepthwise);
      }
      if (ScoreConverter != 0) {
        output.WriteRawTag(128, 1);
        output.WriteEnum((int) ScoreConverter);
      }
      if (boxEncodingsClipRange_ != null) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(BoxEncodingsClipRange);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (convHyperparams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConvHyperparams);
      }
      if (NumLayersBeforePredictor != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumLayersBeforePredictor);
      }
      if (Depth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Depth);
      }
      if (KernelSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(KernelSize);
      }
      if (BoxCodeSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(BoxCodeSize);
      }
      if (ClassPredictionBiasInit != 0F) {
        size += 1 + 4;
      }
      if (UseDropout != false) {
        size += 1 + 1;
      }
      if (DropoutKeepProbability != 0F) {
        size += 1 + 4;
      }
      if (SharePredictionTower != false) {
        size += 1 + 1;
      }
      if (UseDepthwise != false) {
        size += 1 + 1;
      }
      if (ScoreConverter != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ScoreConverter);
      }
      if (boxEncodingsClipRange_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(BoxEncodingsClipRange);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightSharedConvolutionalBoxPredictor other) {
      if (other == null) {
        return;
      }
      if (other.convHyperparams_ != null) {
        if (convHyperparams_ == null) {
          convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
        }
        ConvHyperparams.MergeFrom(other.ConvHyperparams);
      }
      if (other.NumLayersBeforePredictor != 0) {
        NumLayersBeforePredictor = other.NumLayersBeforePredictor;
      }
      if (other.Depth != 0) {
        Depth = other.Depth;
      }
      if (other.KernelSize != 0) {
        KernelSize = other.KernelSize;
      }
      if (other.BoxCodeSize != 0) {
        BoxCodeSize = other.BoxCodeSize;
      }
      if (other.ClassPredictionBiasInit != 0F) {
        ClassPredictionBiasInit = other.ClassPredictionBiasInit;
      }
      if (other.UseDropout != false) {
        UseDropout = other.UseDropout;
      }
      if (other.DropoutKeepProbability != 0F) {
        DropoutKeepProbability = other.DropoutKeepProbability;
      }
      if (other.SharePredictionTower != false) {
        SharePredictionTower = other.SharePredictionTower;
      }
      if (other.UseDepthwise != false) {
        UseDepthwise = other.UseDepthwise;
      }
      if (other.ScoreConverter != 0) {
        ScoreConverter = other.ScoreConverter;
      }
      if (other.boxEncodingsClipRange_ != null) {
        if (boxEncodingsClipRange_ == null) {
          boxEncodingsClipRange_ = new global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.BoxEncodingsClipRange();
        }
        BoxEncodingsClipRange.MergeFrom(other.BoxEncodingsClipRange);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (convHyperparams_ == null) {
              convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
            }
            input.ReadMessage(convHyperparams_);
            break;
          }
          case 16: {
            Depth = input.ReadInt32();
            break;
          }
          case 32: {
            NumLayersBeforePredictor = input.ReadInt32();
            break;
          }
          case 56: {
            KernelSize = input.ReadInt32();
            break;
          }
          case 64: {
            BoxCodeSize = input.ReadInt32();
            break;
          }
          case 85: {
            ClassPredictionBiasInit = input.ReadFloat();
            break;
          }
          case 88: {
            UseDropout = input.ReadBool();
            break;
          }
          case 101: {
            DropoutKeepProbability = input.ReadFloat();
            break;
          }
          case 104: {
            SharePredictionTower = input.ReadBool();
            break;
          }
          case 112: {
            UseDepthwise = input.ReadBool();
            break;
          }
          case 128: {
            scoreConverter_ = (global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.ScoreConverter) input.ReadEnum();
            break;
          }
          case 138: {
            if (boxEncodingsClipRange_ == null) {
              boxEncodingsClipRange_ = new global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Types.BoxEncodingsClipRange();
            }
            input.ReadMessage(boxEncodingsClipRange_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the WeightSharedConvolutionalBoxPredictor message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Enum to specify how to convert the detection scores at inference time.
      /// </summary>
      public enum ScoreConverter {
        /// <summary>
        /// Input scores equals output scores.
        /// </summary>
        [pbr::OriginalName("IDENTITY")] Identity = 0,
        /// <summary>
        /// Applies a sigmoid on input scores.
        /// </summary>
        [pbr::OriginalName("SIGMOID")] Sigmoid = 1,
      }

      /// <summary>
      /// If specified, apply clipping to box encodings.
      /// </summary>
      public sealed partial class BoxEncodingsClipRange : pb::IMessage<BoxEncodingsClipRange> {
        private static readonly pb::MessageParser<BoxEncodingsClipRange> _parser = new pb::MessageParser<BoxEncodingsClipRange>(() => new BoxEncodingsClipRange());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<BoxEncodingsClipRange> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.Models.ObjectDetection.Protos.WeightSharedConvolutionalBoxPredictor.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoxEncodingsClipRange() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoxEncodingsClipRange(BoxEncodingsClipRange other) : this() {
          min_ = other.min_;
          max_ = other.max_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public BoxEncodingsClipRange Clone() {
          return new BoxEncodingsClipRange(this);
        }

        /// <summary>Field number for the "min" field.</summary>
        public const int MinFieldNumber = 1;
        private float min_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Min {
          get { return min_; }
          set {
            min_ = value;
          }
        }

        /// <summary>Field number for the "max" field.</summary>
        public const int MaxFieldNumber = 2;
        private float max_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Max {
          get { return max_; }
          set {
            max_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as BoxEncodingsClipRange);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(BoxEncodingsClipRange other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Min, other.Min)) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Max, other.Max)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Min != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Min);
          if (Max != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Max);
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Min != 0F) {
            output.WriteRawTag(13);
            output.WriteFloat(Min);
          }
          if (Max != 0F) {
            output.WriteRawTag(21);
            output.WriteFloat(Max);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Min != 0F) {
            size += 1 + 4;
          }
          if (Max != 0F) {
            size += 1 + 4;
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(BoxEncodingsClipRange other) {
          if (other == null) {
            return;
          }
          if (other.Min != 0F) {
            Min = other.Min;
          }
          if (other.Max != 0F) {
            Max = other.Max;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                Min = input.ReadFloat();
                break;
              }
              case 21: {
                Max = input.ReadFloat();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// TODO(alirezafathi): Refactor the proto file to be able to configure mask rcnn
  /// head easily.
  /// Next id: 15
  /// </summary>
  public sealed partial class MaskRCNNBoxPredictor : pb::IMessage<MaskRCNNBoxPredictor> {
    private static readonly pb::MessageParser<MaskRCNNBoxPredictor> _parser = new pb::MessageParser<MaskRCNNBoxPredictor>(() => new MaskRCNNBoxPredictor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MaskRCNNBoxPredictor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictorReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MaskRCNNBoxPredictor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MaskRCNNBoxPredictor(MaskRCNNBoxPredictor other) : this() {
      fcHyperparams_ = other.fcHyperparams_ != null ? other.fcHyperparams_.Clone() : null;
      useDropout_ = other.useDropout_;
      dropoutKeepProbability_ = other.dropoutKeepProbability_;
      boxCodeSize_ = other.boxCodeSize_;
      convHyperparams_ = other.convHyperparams_ != null ? other.convHyperparams_.Clone() : null;
      predictInstanceMasks_ = other.predictInstanceMasks_;
      maskPredictionConvDepth_ = other.maskPredictionConvDepth_;
      predictKeypoints_ = other.predictKeypoints_;
      maskHeight_ = other.maskHeight_;
      maskWidth_ = other.maskWidth_;
      maskPredictionNumConvLayers_ = other.maskPredictionNumConvLayers_;
      masksAreClassAgnostic_ = other.masksAreClassAgnostic_;
      shareBoxAcrossClasses_ = other.shareBoxAcrossClasses_;
      convolveThenUpsampleMasks_ = other.convolveThenUpsampleMasks_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MaskRCNNBoxPredictor Clone() {
      return new MaskRCNNBoxPredictor(this);
    }

    /// <summary>Field number for the "fc_hyperparams" field.</summary>
    public const int FcHyperparamsFieldNumber = 1;
    private global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams fcHyperparams_;
    /// <summary>
    /// Hyperparameters for fully connected ops used in the box predictor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams FcHyperparams {
      get { return fcHyperparams_; }
      set {
        fcHyperparams_ = value;
      }
    }

    /// <summary>Field number for the "use_dropout" field.</summary>
    public const int UseDropoutFieldNumber = 2;
    private bool useDropout_;
    /// <summary>
    /// Whether to use dropout op prior to the both box and class predictions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseDropout {
      get { return useDropout_; }
      set {
        useDropout_ = value;
      }
    }

    /// <summary>Field number for the "dropout_keep_probability" field.</summary>
    public const int DropoutKeepProbabilityFieldNumber = 3;
    private float dropoutKeepProbability_;
    /// <summary>
    /// Keep probability for dropout. This is only used if use_dropout is true.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DropoutKeepProbability {
      get { return dropoutKeepProbability_; }
      set {
        dropoutKeepProbability_ = value;
      }
    }

    /// <summary>Field number for the "box_code_size" field.</summary>
    public const int BoxCodeSizeFieldNumber = 4;
    private int boxCodeSize_;
    /// <summary>
    /// Size of the encoding for the boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int BoxCodeSize {
      get { return boxCodeSize_; }
      set {
        boxCodeSize_ = value;
      }
    }

    /// <summary>Field number for the "conv_hyperparams" field.</summary>
    public const int ConvHyperparamsFieldNumber = 5;
    private global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams convHyperparams_;
    /// <summary>
    /// Hyperparameters for convolution ops used in the box predictor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams ConvHyperparams {
      get { return convHyperparams_; }
      set {
        convHyperparams_ = value;
      }
    }

    /// <summary>Field number for the "predict_instance_masks" field.</summary>
    public const int PredictInstanceMasksFieldNumber = 6;
    private bool predictInstanceMasks_;
    /// <summary>
    /// Whether to predict instance masks inside detection boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PredictInstanceMasks {
      get { return predictInstanceMasks_; }
      set {
        predictInstanceMasks_ = value;
      }
    }

    /// <summary>Field number for the "mask_prediction_conv_depth" field.</summary>
    public const int MaskPredictionConvDepthFieldNumber = 7;
    private int maskPredictionConvDepth_;
    /// <summary>
    /// The depth for the first conv2d_transpose op applied to the
    /// image_features in the mask prediction branch. If set to 0, the value
    /// will be set automatically based on the number of channels in the image
    /// features and the number of classes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaskPredictionConvDepth {
      get { return maskPredictionConvDepth_; }
      set {
        maskPredictionConvDepth_ = value;
      }
    }

    /// <summary>Field number for the "predict_keypoints" field.</summary>
    public const int PredictKeypointsFieldNumber = 8;
    private bool predictKeypoints_;
    /// <summary>
    /// Whether to predict keypoints inside detection boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool PredictKeypoints {
      get { return predictKeypoints_; }
      set {
        predictKeypoints_ = value;
      }
    }

    /// <summary>Field number for the "mask_height" field.</summary>
    public const int MaskHeightFieldNumber = 9;
    private int maskHeight_;
    /// <summary>
    /// The height and the width of the predicted mask.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaskHeight {
      get { return maskHeight_; }
      set {
        maskHeight_ = value;
      }
    }

    /// <summary>Field number for the "mask_width" field.</summary>
    public const int MaskWidthFieldNumber = 10;
    private int maskWidth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaskWidth {
      get { return maskWidth_; }
      set {
        maskWidth_ = value;
      }
    }

    /// <summary>Field number for the "mask_prediction_num_conv_layers" field.</summary>
    public const int MaskPredictionNumConvLayersFieldNumber = 11;
    private int maskPredictionNumConvLayers_;
    /// <summary>
    /// The number of convolutions applied to image_features in the mask prediction
    /// branch.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaskPredictionNumConvLayers {
      get { return maskPredictionNumConvLayers_; }
      set {
        maskPredictionNumConvLayers_ = value;
      }
    }

    /// <summary>Field number for the "masks_are_class_agnostic" field.</summary>
    public const int MasksAreClassAgnosticFieldNumber = 12;
    private bool masksAreClassAgnostic_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool MasksAreClassAgnostic {
      get { return masksAreClassAgnostic_; }
      set {
        masksAreClassAgnostic_ = value;
      }
    }

    /// <summary>Field number for the "share_box_across_classes" field.</summary>
    public const int ShareBoxAcrossClassesFieldNumber = 13;
    private bool shareBoxAcrossClasses_;
    /// <summary>
    /// Whether to use one box for all classes rather than a different box for each
    /// class.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ShareBoxAcrossClasses {
      get { return shareBoxAcrossClasses_; }
      set {
        shareBoxAcrossClasses_ = value;
      }
    }

    /// <summary>Field number for the "convolve_then_upsample_masks" field.</summary>
    public const int ConvolveThenUpsampleMasksFieldNumber = 14;
    private bool convolveThenUpsampleMasks_;
    /// <summary>
    /// Whether to apply convolutions on mask features before upsampling using
    /// nearest neighbor resizing.
    /// By default, mask features are resized to [`mask_height`, `mask_width`]
    /// before applying convolutions and predicting masks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ConvolveThenUpsampleMasks {
      get { return convolveThenUpsampleMasks_; }
      set {
        convolveThenUpsampleMasks_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MaskRCNNBoxPredictor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MaskRCNNBoxPredictor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(FcHyperparams, other.FcHyperparams)) return false;
      if (UseDropout != other.UseDropout) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DropoutKeepProbability, other.DropoutKeepProbability)) return false;
      if (BoxCodeSize != other.BoxCodeSize) return false;
      if (!object.Equals(ConvHyperparams, other.ConvHyperparams)) return false;
      if (PredictInstanceMasks != other.PredictInstanceMasks) return false;
      if (MaskPredictionConvDepth != other.MaskPredictionConvDepth) return false;
      if (PredictKeypoints != other.PredictKeypoints) return false;
      if (MaskHeight != other.MaskHeight) return false;
      if (MaskWidth != other.MaskWidth) return false;
      if (MaskPredictionNumConvLayers != other.MaskPredictionNumConvLayers) return false;
      if (MasksAreClassAgnostic != other.MasksAreClassAgnostic) return false;
      if (ShareBoxAcrossClasses != other.ShareBoxAcrossClasses) return false;
      if (ConvolveThenUpsampleMasks != other.ConvolveThenUpsampleMasks) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (fcHyperparams_ != null) hash ^= FcHyperparams.GetHashCode();
      if (UseDropout != false) hash ^= UseDropout.GetHashCode();
      if (DropoutKeepProbability != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DropoutKeepProbability);
      if (BoxCodeSize != 0) hash ^= BoxCodeSize.GetHashCode();
      if (convHyperparams_ != null) hash ^= ConvHyperparams.GetHashCode();
      if (PredictInstanceMasks != false) hash ^= PredictInstanceMasks.GetHashCode();
      if (MaskPredictionConvDepth != 0) hash ^= MaskPredictionConvDepth.GetHashCode();
      if (PredictKeypoints != false) hash ^= PredictKeypoints.GetHashCode();
      if (MaskHeight != 0) hash ^= MaskHeight.GetHashCode();
      if (MaskWidth != 0) hash ^= MaskWidth.GetHashCode();
      if (MaskPredictionNumConvLayers != 0) hash ^= MaskPredictionNumConvLayers.GetHashCode();
      if (MasksAreClassAgnostic != false) hash ^= MasksAreClassAgnostic.GetHashCode();
      if (ShareBoxAcrossClasses != false) hash ^= ShareBoxAcrossClasses.GetHashCode();
      if (ConvolveThenUpsampleMasks != false) hash ^= ConvolveThenUpsampleMasks.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (fcHyperparams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(FcHyperparams);
      }
      if (UseDropout != false) {
        output.WriteRawTag(16);
        output.WriteBool(UseDropout);
      }
      if (DropoutKeepProbability != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(DropoutKeepProbability);
      }
      if (BoxCodeSize != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(BoxCodeSize);
      }
      if (convHyperparams_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(ConvHyperparams);
      }
      if (PredictInstanceMasks != false) {
        output.WriteRawTag(48);
        output.WriteBool(PredictInstanceMasks);
      }
      if (MaskPredictionConvDepth != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(MaskPredictionConvDepth);
      }
      if (PredictKeypoints != false) {
        output.WriteRawTag(64);
        output.WriteBool(PredictKeypoints);
      }
      if (MaskHeight != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(MaskHeight);
      }
      if (MaskWidth != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(MaskWidth);
      }
      if (MaskPredictionNumConvLayers != 0) {
        output.WriteRawTag(88);
        output.WriteInt32(MaskPredictionNumConvLayers);
      }
      if (MasksAreClassAgnostic != false) {
        output.WriteRawTag(96);
        output.WriteBool(MasksAreClassAgnostic);
      }
      if (ShareBoxAcrossClasses != false) {
        output.WriteRawTag(104);
        output.WriteBool(ShareBoxAcrossClasses);
      }
      if (ConvolveThenUpsampleMasks != false) {
        output.WriteRawTag(112);
        output.WriteBool(ConvolveThenUpsampleMasks);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (fcHyperparams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FcHyperparams);
      }
      if (UseDropout != false) {
        size += 1 + 1;
      }
      if (DropoutKeepProbability != 0F) {
        size += 1 + 4;
      }
      if (BoxCodeSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(BoxCodeSize);
      }
      if (convHyperparams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConvHyperparams);
      }
      if (PredictInstanceMasks != false) {
        size += 1 + 1;
      }
      if (MaskPredictionConvDepth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskPredictionConvDepth);
      }
      if (PredictKeypoints != false) {
        size += 1 + 1;
      }
      if (MaskHeight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskHeight);
      }
      if (MaskWidth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskWidth);
      }
      if (MaskPredictionNumConvLayers != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskPredictionNumConvLayers);
      }
      if (MasksAreClassAgnostic != false) {
        size += 1 + 1;
      }
      if (ShareBoxAcrossClasses != false) {
        size += 1 + 1;
      }
      if (ConvolveThenUpsampleMasks != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MaskRCNNBoxPredictor other) {
      if (other == null) {
        return;
      }
      if (other.fcHyperparams_ != null) {
        if (fcHyperparams_ == null) {
          fcHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
        }
        FcHyperparams.MergeFrom(other.FcHyperparams);
      }
      if (other.UseDropout != false) {
        UseDropout = other.UseDropout;
      }
      if (other.DropoutKeepProbability != 0F) {
        DropoutKeepProbability = other.DropoutKeepProbability;
      }
      if (other.BoxCodeSize != 0) {
        BoxCodeSize = other.BoxCodeSize;
      }
      if (other.convHyperparams_ != null) {
        if (convHyperparams_ == null) {
          convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
        }
        ConvHyperparams.MergeFrom(other.ConvHyperparams);
      }
      if (other.PredictInstanceMasks != false) {
        PredictInstanceMasks = other.PredictInstanceMasks;
      }
      if (other.MaskPredictionConvDepth != 0) {
        MaskPredictionConvDepth = other.MaskPredictionConvDepth;
      }
      if (other.PredictKeypoints != false) {
        PredictKeypoints = other.PredictKeypoints;
      }
      if (other.MaskHeight != 0) {
        MaskHeight = other.MaskHeight;
      }
      if (other.MaskWidth != 0) {
        MaskWidth = other.MaskWidth;
      }
      if (other.MaskPredictionNumConvLayers != 0) {
        MaskPredictionNumConvLayers = other.MaskPredictionNumConvLayers;
      }
      if (other.MasksAreClassAgnostic != false) {
        MasksAreClassAgnostic = other.MasksAreClassAgnostic;
      }
      if (other.ShareBoxAcrossClasses != false) {
        ShareBoxAcrossClasses = other.ShareBoxAcrossClasses;
      }
      if (other.ConvolveThenUpsampleMasks != false) {
        ConvolveThenUpsampleMasks = other.ConvolveThenUpsampleMasks;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (fcHyperparams_ == null) {
              fcHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
            }
            input.ReadMessage(fcHyperparams_);
            break;
          }
          case 16: {
            UseDropout = input.ReadBool();
            break;
          }
          case 29: {
            DropoutKeepProbability = input.ReadFloat();
            break;
          }
          case 32: {
            BoxCodeSize = input.ReadInt32();
            break;
          }
          case 42: {
            if (convHyperparams_ == null) {
              convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
            }
            input.ReadMessage(convHyperparams_);
            break;
          }
          case 48: {
            PredictInstanceMasks = input.ReadBool();
            break;
          }
          case 56: {
            MaskPredictionConvDepth = input.ReadInt32();
            break;
          }
          case 64: {
            PredictKeypoints = input.ReadBool();
            break;
          }
          case 72: {
            MaskHeight = input.ReadInt32();
            break;
          }
          case 80: {
            MaskWidth = input.ReadInt32();
            break;
          }
          case 88: {
            MaskPredictionNumConvLayers = input.ReadInt32();
            break;
          }
          case 96: {
            MasksAreClassAgnostic = input.ReadBool();
            break;
          }
          case 104: {
            ShareBoxAcrossClasses = input.ReadBool();
            break;
          }
          case 112: {
            ConvolveThenUpsampleMasks = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  public sealed partial class RfcnBoxPredictor : pb::IMessage<RfcnBoxPredictor> {
    private static readonly pb::MessageParser<RfcnBoxPredictor> _parser = new pb::MessageParser<RfcnBoxPredictor>(() => new RfcnBoxPredictor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RfcnBoxPredictor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictorReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RfcnBoxPredictor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RfcnBoxPredictor(RfcnBoxPredictor other) : this() {
      convHyperparams_ = other.convHyperparams_ != null ? other.convHyperparams_.Clone() : null;
      numSpatialBinsHeight_ = other.numSpatialBinsHeight_;
      numSpatialBinsWidth_ = other.numSpatialBinsWidth_;
      depth_ = other.depth_;
      boxCodeSize_ = other.boxCodeSize_;
      cropHeight_ = other.cropHeight_;
      cropWidth_ = other.cropWidth_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RfcnBoxPredictor Clone() {
      return new RfcnBoxPredictor(this);
    }

    /// <summary>Field number for the "conv_hyperparams" field.</summary>
    public const int ConvHyperparamsFieldNumber = 1;
    private global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams convHyperparams_;
    /// <summary>
    /// Hyperparameters for convolution ops used in the box predictor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams ConvHyperparams {
      get { return convHyperparams_; }
      set {
        convHyperparams_ = value;
      }
    }

    /// <summary>Field number for the "num_spatial_bins_height" field.</summary>
    public const int NumSpatialBinsHeightFieldNumber = 2;
    private int numSpatialBinsHeight_;
    /// <summary>
    /// Bin sizes for RFCN crops.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumSpatialBinsHeight {
      get { return numSpatialBinsHeight_; }
      set {
        numSpatialBinsHeight_ = value;
      }
    }

    /// <summary>Field number for the "num_spatial_bins_width" field.</summary>
    public const int NumSpatialBinsWidthFieldNumber = 3;
    private int numSpatialBinsWidth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumSpatialBinsWidth {
      get { return numSpatialBinsWidth_; }
      set {
        numSpatialBinsWidth_ = value;
      }
    }

    /// <summary>Field number for the "depth" field.</summary>
    public const int DepthFieldNumber = 4;
    private int depth_;
    /// <summary>
    /// Target depth to reduce the input image features to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Depth {
      get { return depth_; }
      set {
        depth_ = value;
      }
    }

    /// <summary>Field number for the "box_code_size" field.</summary>
    public const int BoxCodeSizeFieldNumber = 5;
    private int boxCodeSize_;
    /// <summary>
    /// Size of the encoding for the boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int BoxCodeSize {
      get { return boxCodeSize_; }
      set {
        boxCodeSize_ = value;
      }
    }

    /// <summary>Field number for the "crop_height" field.</summary>
    public const int CropHeightFieldNumber = 6;
    private int cropHeight_;
    /// <summary>
    /// Size to resize the rfcn crops to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CropHeight {
      get { return cropHeight_; }
      set {
        cropHeight_ = value;
      }
    }

    /// <summary>Field number for the "crop_width" field.</summary>
    public const int CropWidthFieldNumber = 7;
    private int cropWidth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CropWidth {
      get { return cropWidth_; }
      set {
        cropWidth_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RfcnBoxPredictor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RfcnBoxPredictor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(ConvHyperparams, other.ConvHyperparams)) return false;
      if (NumSpatialBinsHeight != other.NumSpatialBinsHeight) return false;
      if (NumSpatialBinsWidth != other.NumSpatialBinsWidth) return false;
      if (Depth != other.Depth) return false;
      if (BoxCodeSize != other.BoxCodeSize) return false;
      if (CropHeight != other.CropHeight) return false;
      if (CropWidth != other.CropWidth) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (convHyperparams_ != null) hash ^= ConvHyperparams.GetHashCode();
      if (NumSpatialBinsHeight != 0) hash ^= NumSpatialBinsHeight.GetHashCode();
      if (NumSpatialBinsWidth != 0) hash ^= NumSpatialBinsWidth.GetHashCode();
      if (Depth != 0) hash ^= Depth.GetHashCode();
      if (BoxCodeSize != 0) hash ^= BoxCodeSize.GetHashCode();
      if (CropHeight != 0) hash ^= CropHeight.GetHashCode();
      if (CropWidth != 0) hash ^= CropWidth.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (convHyperparams_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(ConvHyperparams);
      }
      if (NumSpatialBinsHeight != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NumSpatialBinsHeight);
      }
      if (NumSpatialBinsWidth != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(NumSpatialBinsWidth);
      }
      if (Depth != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(Depth);
      }
      if (BoxCodeSize != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(BoxCodeSize);
      }
      if (CropHeight != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(CropHeight);
      }
      if (CropWidth != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(CropWidth);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (convHyperparams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConvHyperparams);
      }
      if (NumSpatialBinsHeight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumSpatialBinsHeight);
      }
      if (NumSpatialBinsWidth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumSpatialBinsWidth);
      }
      if (Depth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Depth);
      }
      if (BoxCodeSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(BoxCodeSize);
      }
      if (CropHeight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CropHeight);
      }
      if (CropWidth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(CropWidth);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RfcnBoxPredictor other) {
      if (other == null) {
        return;
      }
      if (other.convHyperparams_ != null) {
        if (convHyperparams_ == null) {
          convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
        }
        ConvHyperparams.MergeFrom(other.ConvHyperparams);
      }
      if (other.NumSpatialBinsHeight != 0) {
        NumSpatialBinsHeight = other.NumSpatialBinsHeight;
      }
      if (other.NumSpatialBinsWidth != 0) {
        NumSpatialBinsWidth = other.NumSpatialBinsWidth;
      }
      if (other.Depth != 0) {
        Depth = other.Depth;
      }
      if (other.BoxCodeSize != 0) {
        BoxCodeSize = other.BoxCodeSize;
      }
      if (other.CropHeight != 0) {
        CropHeight = other.CropHeight;
      }
      if (other.CropWidth != 0) {
        CropWidth = other.CropWidth;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (convHyperparams_ == null) {
              convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
            }
            input.ReadMessage(convHyperparams_);
            break;
          }
          case 16: {
            NumSpatialBinsHeight = input.ReadInt32();
            break;
          }
          case 24: {
            NumSpatialBinsWidth = input.ReadInt32();
            break;
          }
          case 32: {
            Depth = input.ReadInt32();
            break;
          }
          case 40: {
            BoxCodeSize = input.ReadInt32();
            break;
          }
          case 48: {
            CropHeight = input.ReadInt32();
            break;
          }
          case 56: {
            CropWidth = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
