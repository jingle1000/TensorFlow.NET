// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: object_detection/protos/preprocessor.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Models.ObjectDetection.Protos {

  /// <summary>Holder for reflection information generated from object_detection/protos/preprocessor.proto</summary>
  public static partial class PreprocessorReflection {

    #region Descriptor
    /// <summary>File descriptor for object_detection/protos/preprocessor.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PreprocessorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CipvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9wcmVwcm9jZXNzb3IucHJvdG8S",
            "F29iamVjdF9kZXRlY3Rpb24ucHJvdG9zItgUChFQcmVwcm9jZXNzaW5nU3Rl",
            "cBJCCg9ub3JtYWxpemVfaW1hZ2UYASABKAsyJy5vYmplY3RfZGV0ZWN0aW9u",
            "LnByb3Rvcy5Ob3JtYWxpemVJbWFnZUgAEk8KFnJhbmRvbV9ob3Jpem9udGFs",
            "X2ZsaXAYAiABKAsyLS5vYmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5SYW5kb21I",
            "b3Jpem9udGFsRmxpcEgAElIKGHJhbmRvbV9waXhlbF92YWx1ZV9zY2FsZRgD",
            "IAEoCzIuLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLlJhbmRvbVBpeGVsVmFs",
            "dWVTY2FsZUgAEkcKEnJhbmRvbV9pbWFnZV9zY2FsZRgEIAEoCzIpLm9iamVj",
            "dF9kZXRlY3Rpb24ucHJvdG9zLlJhbmRvbUltYWdlU2NhbGVIABJGChJyYW5k",
            "b21fcmdiX3RvX2dyYXkYBSABKAsyKC5vYmplY3RfZGV0ZWN0aW9uLnByb3Rv",
            "cy5SYW5kb21SR0J0b0dyYXlIABJTChhyYW5kb21fYWRqdXN0X2JyaWdodG5l",
            "c3MYBiABKAsyLy5vYmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5SYW5kb21BZGp1",
            "c3RCcmlnaHRuZXNzSAASTwoWcmFuZG9tX2FkanVzdF9jb250cmFzdBgHIAEo",
            "CzItLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLlJhbmRvbUFkanVzdENvbnRy",
            "YXN0SAASRQoRcmFuZG9tX2FkanVzdF9odWUYCCABKAsyKC5vYmplY3RfZGV0",
            "ZWN0aW9uLnByb3Rvcy5SYW5kb21BZGp1c3RIdWVIABJTChhyYW5kb21fYWRq",
            "dXN0X3NhdHVyYXRpb24YCSABKAsyLy5vYmplY3RfZGV0ZWN0aW9uLnByb3Rv",
            "cy5SYW5kb21BZGp1c3RTYXR1cmF0aW9uSAASSwoUcmFuZG9tX2Rpc3RvcnRf",
            "Y29sb3IYCiABKAsyKy5vYmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5SYW5kb21E",
            "aXN0b3J0Q29sb3JIABJJChNyYW5kb21faml0dGVyX2JveGVzGAsgASgLMiou",
            "b2JqZWN0X2RldGVjdGlvbi5wcm90b3MuUmFuZG9tSml0dGVyQm94ZXNIABJF",
            "ChFyYW5kb21fY3JvcF9pbWFnZRgMIAEoCzIoLm9iamVjdF9kZXRlY3Rpb24u",
            "cHJvdG9zLlJhbmRvbUNyb3BJbWFnZUgAEkMKEHJhbmRvbV9wYWRfaW1hZ2UY",
            "DSABKAsyJy5vYmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5SYW5kb21QYWRJbWFn",
            "ZUgAEkwKFXJhbmRvbV9jcm9wX3BhZF9pbWFnZRgOIAEoCzIrLm9iamVjdF9k",
            "ZXRlY3Rpb24ucHJvdG9zLlJhbmRvbUNyb3BQYWRJbWFnZUgAElcKG3JhbmRv",
            "bV9jcm9wX3RvX2FzcGVjdF9yYXRpbxgPIAEoCzIwLm9iamVjdF9kZXRlY3Rp",
            "b24ucHJvdG9zLlJhbmRvbUNyb3BUb0FzcGVjdFJhdGlvSAASSwoUcmFuZG9t",
            "X2JsYWNrX3BhdGNoZXMYECABKAsyKy5vYmplY3RfZGV0ZWN0aW9uLnByb3Rv",
            "cy5SYW5kb21CbGFja1BhdGNoZXNIABJLChRyYW5kb21fcmVzaXplX21ldGhv",
            "ZBgRIAEoCzIrLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLlJhbmRvbVJlc2l6",
            "ZU1ldGhvZEgAEmEKIHNjYWxlX2JveGVzX3RvX3BpeGVsX2Nvb3JkaW5hdGVz",
            "GBIgASgLMjUub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuU2NhbGVCb3hlc1Rv",
            "UGl4ZWxDb29yZGluYXRlc0gAEjwKDHJlc2l6ZV9pbWFnZRgTIAEoCzIkLm9i",
            "amVjdF9kZXRlY3Rpb24ucHJvdG9zLlJlc2l6ZUltYWdlSAASTQoVc3VidHJh",
            "Y3RfY2hhbm5lbF9tZWFuGBQgASgLMiwub2JqZWN0X2RldGVjdGlvbi5wcm90",
            "b3MuU3VidHJhY3RDaGFubmVsTWVhbkgAEkEKD3NzZF9yYW5kb21fY3JvcBgV",
            "IAEoCzImLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLlNTRFJhbmRvbUNyb3BI",
            "ABJIChNzc2RfcmFuZG9tX2Nyb3BfcGFkGBYgASgLMikub2JqZWN0X2RldGVj",
            "dGlvbi5wcm90b3MuU1NEUmFuZG9tQ3JvcFBhZEgAEmQKInNzZF9yYW5kb21f",
            "Y3JvcF9maXhlZF9hc3BlY3RfcmF0aW8YFyABKAsyNi5vYmplY3RfZGV0ZWN0",
            "aW9uLnByb3Rvcy5TU0RSYW5kb21Dcm9wRml4ZWRBc3BlY3RSYXRpb0gAEmsK",
            "JnNzZF9yYW5kb21fY3JvcF9wYWRfZml4ZWRfYXNwZWN0X3JhdGlvGBggASgL",
            "Mjkub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuU1NEUmFuZG9tQ3JvcFBhZEZp",
            "eGVkQXNwZWN0UmF0aW9IABJLChRyYW5kb21fdmVydGljYWxfZmxpcBgZIAEo",
            "CzIrLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLlJhbmRvbVZlcnRpY2FsRmxp",
            "cEgAEkYKEXJhbmRvbV9yb3RhdGlvbjkwGBogASgLMikub2JqZWN0X2RldGVj",
            "dGlvbi5wcm90b3MuUmFuZG9tUm90YXRpb245MEgAEjkKC3JnYl90b19ncmF5",
            "GBsgASgLMiIub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuUkdCdG9HcmF5SAAS",
            "XwofY29udmVydF9jbGFzc19sb2dpdHNfdG9fc29mdG1heBgcIAEoCzI0Lm9i",
            "amVjdF9kZXRlY3Rpb24ucHJvdG9zLkNvbnZlcnRDbGFzc0xvZ2l0c1RvU29m",
            "dG1heEgAElQKGXJhbmRvbV9hYnNvbHV0ZV9wYWRfaW1hZ2UYHSABKAsyLy5v",
            "YmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5SYW5kb21BYnNvbHV0ZVBhZEltYWdl",
            "SAASUgoYcmFuZG9tX3NlbGZfY29uY2F0X2ltYWdlGB4gASgLMi4ub2JqZWN0",
            "X2RldGVjdGlvbi5wcm90b3MuUmFuZG9tU2VsZkNvbmNhdEltYWdlSAASRgoR",
            "YXV0b2F1Z21lbnRfaW1hZ2UYHyABKAsyKS5vYmplY3RfZGV0ZWN0aW9uLnBy",
            "b3Rvcy5BdXRvQXVnbWVudEltYWdlSAASWwocZHJvcF9sYWJlbF9wcm9iYWJp",
            "bGlzdGljYWxseRggIAEoCzIzLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLkRy",
            "b3BMYWJlbFByb2JhYmlsaXN0aWNhbGx5SAASPAoMcmVtYXBfbGFiZWxzGCEg",
            "ASgLMiQub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuUmVtYXBMYWJlbHNIAEIU",
            "ChJwcmVwcm9jZXNzaW5nX3N0ZXAicAoOTm9ybWFsaXplSW1hZ2USFwoPb3Jp",
            "Z2luYWxfbWludmFsGAEgASgCEhcKD29yaWdpbmFsX21heHZhbBgCIAEoAhIV",
            "Cg10YXJnZXRfbWludmFsGAMgASgCEhUKDXRhcmdldF9tYXh2YWwYBCABKAIi",
            "OQoUUmFuZG9tSG9yaXpvbnRhbEZsaXASIQoZa2V5cG9pbnRfZmxpcF9wZXJt",
            "dXRhdGlvbhgBIAMoBSI3ChJSYW5kb21WZXJ0aWNhbEZsaXASIQoZa2V5cG9p",
            "bnRfZmxpcF9wZXJtdXRhdGlvbhgBIAMoBSISChBSYW5kb21Sb3RhdGlvbjkw",
            "IjcKFVJhbmRvbVBpeGVsVmFsdWVTY2FsZRIOCgZtaW52YWwYASABKAISDgoG",
            "bWF4dmFsGAIgASgCIkQKEFJhbmRvbUltYWdlU2NhbGUSFwoPbWluX3NjYWxl",
            "X3JhdGlvGAEgASgCEhcKD21heF9zY2FsZV9yYXRpbxgCIAEoAiImCg9SYW5k",
            "b21SR0J0b0dyYXkSEwoLcHJvYmFiaWxpdHkYASABKAIiKwoWUmFuZG9tQWRq",
            "dXN0QnJpZ2h0bmVzcxIRCgltYXhfZGVsdGEYASABKAIiPAoUUmFuZG9tQWRq",
            "dXN0Q29udHJhc3QSEQoJbWluX2RlbHRhGAEgASgCEhEKCW1heF9kZWx0YRgC",
            "IAEoAiIkCg9SYW5kb21BZGp1c3RIdWUSEQoJbWF4X2RlbHRhGAEgASgCIj4K",
            "FlJhbmRvbUFkanVzdFNhdHVyYXRpb24SEQoJbWluX2RlbHRhGAEgASgCEhEK",
            "CW1heF9kZWx0YRgCIAEoAiIsChJSYW5kb21EaXN0b3J0Q29sb3ISFgoOY29s",
            "b3Jfb3JkZXJpbmcYASABKAUiIgoRUmFuZG9tSml0dGVyQm94ZXMSDQoFcmF0",
            "aW8YASABKAIixgEKD1JhbmRvbUNyb3BJbWFnZRIaChJtaW5fb2JqZWN0X2Nv",
            "dmVyZWQYASABKAISGAoQbWluX2FzcGVjdF9yYXRpbxgCIAEoAhIYChBtYXhf",
            "YXNwZWN0X3JhdGlvGAMgASgCEhAKCG1pbl9hcmVhGAQgASgCEhAKCG1heF9h",
            "cmVhGAUgASgCEhYKDm92ZXJsYXBfdGhyZXNoGAYgASgCEhIKCmNsaXBfYm94",
            "ZXMYCCABKAgSEwoLcmFuZG9tX2NvZWYYByABKAIiiQEKDlJhbmRvbVBhZElt",
            "YWdlEhgKEG1pbl9pbWFnZV9oZWlnaHQYASABKAUSFwoPbWluX2ltYWdlX3dp",
            "ZHRoGAIgASgFEhgKEG1heF9pbWFnZV9oZWlnaHQYAyABKAUSFwoPbWF4X2lt",
            "YWdlX3dpZHRoGAQgASgFEhEKCXBhZF9jb2xvchgFIAMoAiJiChZSYW5kb21B",
            "YnNvbHV0ZVBhZEltYWdlEhoKEm1heF9oZWlnaHRfcGFkZGluZxgBIAEoBRIZ",
            "ChFtYXhfd2lkdGhfcGFkZGluZxgCIAEoBRIRCglwYWRfY29sb3IYAyADKAIi",
            "mgIKElJhbmRvbUNyb3BQYWRJbWFnZRIaChJtaW5fb2JqZWN0X2NvdmVyZWQY",
            "ASABKAISGAoQbWluX2FzcGVjdF9yYXRpbxgCIAEoAhIYChBtYXhfYXNwZWN0",
            "X3JhdGlvGAMgASgCEhAKCG1pbl9hcmVhGAQgASgCEhAKCG1heF9hcmVhGAUg",
            "ASgCEhYKDm92ZXJsYXBfdGhyZXNoGAYgASgCEhIKCmNsaXBfYm94ZXMYCyAB",
            "KAgSEwoLcmFuZG9tX2NvZWYYByABKAISHQoVbWluX3BhZGRlZF9zaXplX3Jh",
            "dGlvGAggAygCEh0KFW1heF9wYWRkZWRfc2l6ZV9yYXRpbxgJIAMoAhIRCglw",
            "YWRfY29sb3IYCiADKAIiWwoXUmFuZG9tQ3JvcFRvQXNwZWN0UmF0aW8SFAoM",
            "YXNwZWN0X3JhdGlvGAEgASgCEhYKDm92ZXJsYXBfdGhyZXNoGAIgASgCEhIK",
            "CmNsaXBfYm94ZXMYAyABKAgiYQoSUmFuZG9tQmxhY2tQYXRjaGVzEhkKEW1h",
            "eF9ibGFja19wYXRjaGVzGAEgASgFEhMKC3Byb2JhYmlsaXR5GAIgASgCEhsK",
            "E3NpemVfdG9faW1hZ2VfcmF0aW8YAyABKAIiQQoSUmFuZG9tUmVzaXplTWV0",
            "aG9kEhUKDXRhcmdldF9oZWlnaHQYASABKAUSFAoMdGFyZ2V0X3dpZHRoGAIg",
            "ASgFIgsKCVJHQnRvR3JheSIeChxTY2FsZUJveGVzVG9QaXhlbENvb3JkaW5h",
            "dGVzIsABCgtSZXNpemVJbWFnZRISCgpuZXdfaGVpZ2h0GAEgASgFEhEKCW5l",
            "d193aWR0aBgCIAEoBRI7CgZtZXRob2QYAyABKA4yKy5vYmplY3RfZGV0ZWN0",
            "aW9uLnByb3Rvcy5SZXNpemVJbWFnZS5NZXRob2QiTQoGTWV0aG9kEggKBE5P",
            "TkUQABIICgRBUkVBEAESCwoHQklDVUJJQxACEgwKCEJJTElORUFSEAMSFAoQ",
            "TkVBUkVTVF9ORUlHSEJPUhAEIiQKE1N1YnRyYWN0Q2hhbm5lbE1lYW4SDQoF",
            "bWVhbnMYASADKAIizQEKFlNTRFJhbmRvbUNyb3BPcGVyYXRpb24SGgoSbWlu",
            "X29iamVjdF9jb3ZlcmVkGAEgASgCEhgKEG1pbl9hc3BlY3RfcmF0aW8YAiAB",
            "KAISGAoQbWF4X2FzcGVjdF9yYXRpbxgDIAEoAhIQCghtaW5fYXJlYRgEIAEo",
            "AhIQCghtYXhfYXJlYRgFIAEoAhIWCg5vdmVybGFwX3RocmVzaBgGIAEoAhIS",
            "CgpjbGlwX2JveGVzGAggASgIEhMKC3JhbmRvbV9jb2VmGAcgASgCIlQKDVNT",
            "RFJhbmRvbUNyb3ASQwoKb3BlcmF0aW9ucxgBIAMoCzIvLm9iamVjdF9kZXRl",
            "Y3Rpb24ucHJvdG9zLlNTRFJhbmRvbUNyb3BPcGVyYXRpb24izQIKGVNTRFJh",
            "bmRvbUNyb3BQYWRPcGVyYXRpb24SGgoSbWluX29iamVjdF9jb3ZlcmVkGAEg",
            "ASgCEhgKEG1pbl9hc3BlY3RfcmF0aW8YAiABKAISGAoQbWF4X2FzcGVjdF9y",
            "YXRpbxgDIAEoAhIQCghtaW5fYXJlYRgEIAEoAhIQCghtYXhfYXJlYRgFIAEo",
            "AhIWCg5vdmVybGFwX3RocmVzaBgGIAEoAhISCgpjbGlwX2JveGVzGA0gASgI",
            "EhMKC3JhbmRvbV9jb2VmGAcgASgCEh0KFW1pbl9wYWRkZWRfc2l6ZV9yYXRp",
            "bxgIIAMoAhIdChVtYXhfcGFkZGVkX3NpemVfcmF0aW8YCSADKAISEwoLcGFk",
            "X2NvbG9yX3IYCiABKAISEwoLcGFkX2NvbG9yX2cYCyABKAISEwoLcGFkX2Nv",
            "bG9yX2IYDCABKAIiWgoQU1NEUmFuZG9tQ3JvcFBhZBJGCgpvcGVyYXRpb25z",
            "GAEgAygLMjIub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuU1NEUmFuZG9tQ3Jv",
            "cFBhZE9wZXJhdGlvbiKpAQomU1NEUmFuZG9tQ3JvcEZpeGVkQXNwZWN0UmF0",
            "aW9PcGVyYXRpb24SGgoSbWluX29iamVjdF9jb3ZlcmVkGAEgASgCEhAKCG1p",
            "bl9hcmVhGAQgASgCEhAKCG1heF9hcmVhGAUgASgCEhYKDm92ZXJsYXBfdGhy",
            "ZXNoGAYgASgCEhIKCmNsaXBfYm94ZXMYCCABKAgSEwoLcmFuZG9tX2NvZWYY",
            "ByABKAIiigEKHVNTRFJhbmRvbUNyb3BGaXhlZEFzcGVjdFJhdGlvElMKCm9w",
            "ZXJhdGlvbnMYASADKAsyPy5vYmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5TU0RS",
            "YW5kb21Dcm9wRml4ZWRBc3BlY3RSYXRpb09wZXJhdGlvbhIUCgxhc3BlY3Rf",
            "cmF0aW8YAiABKAIi4AEKKVNTRFJhbmRvbUNyb3BQYWRGaXhlZEFzcGVjdFJh",
            "dGlvT3BlcmF0aW9uEhoKEm1pbl9vYmplY3RfY292ZXJlZBgBIAEoAhIYChBt",
            "aW5fYXNwZWN0X3JhdGlvGAIgASgCEhgKEG1heF9hc3BlY3RfcmF0aW8YAyAB",
            "KAISEAoIbWluX2FyZWEYBCABKAISEAoIbWF4X2FyZWEYBSABKAISFgoOb3Zl",
            "cmxhcF90aHJlc2gYBiABKAISEgoKY2xpcF9ib3hlcxgIIAEoCBITCgtyYW5k",
            "b21fY29lZhgHIAEoAiLOAQogU1NEUmFuZG9tQ3JvcFBhZEZpeGVkQXNwZWN0",
            "UmF0aW8SVgoKb3BlcmF0aW9ucxgBIAMoCzJCLm9iamVjdF9kZXRlY3Rpb24u",
            "cHJvdG9zLlNTRFJhbmRvbUNyb3BQYWRGaXhlZEFzcGVjdFJhdGlvT3BlcmF0",
            "aW9uEhQKDGFzcGVjdF9yYXRpbxgCIAEoAhIdChVtaW5fcGFkZGVkX3NpemVf",
            "cmF0aW8YAyADKAISHQoVbWF4X3BhZGRlZF9zaXplX3JhdGlvGAQgAygCIjIK",
            "G0NvbnZlcnRDbGFzc0xvZ2l0c1RvU29mdG1heBITCgt0ZW1wZXJhdHVyZRgB",
            "IAEoAiJjChVSYW5kb21TZWxmQ29uY2F0SW1hZ2USIwobY29uY2F0X3ZlcnRp",
            "Y2FsX3Byb2JhYmlsaXR5GAEgASgCEiUKHWNvbmNhdF9ob3Jpem9udGFsX3By",
            "b2JhYmlsaXR5GAIgASgCIicKEEF1dG9BdWdtZW50SW1hZ2USEwoLcG9saWN5",
            "X25hbWUYASABKAkiRQoaRHJvcExhYmVsUHJvYmFiaWxpc3RpY2FsbHkSDQoF",
            "bGFiZWwYASABKAUSGAoQZHJvcF9wcm9iYWJpbGl0eRgCIAEoAiI5CgtSZW1h",
            "cExhYmVscxIXCg9vcmlnaW5hbF9sYWJlbHMYASADKAUSEQoJbmV3X2xhYmVs",
            "GAIgASgFYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.PreprocessingStep), global::Tensorflow.Models.ObjectDetection.Protos.PreprocessingStep.Parser, new[]{ "NormalizeImage", "RandomHorizontalFlip", "RandomPixelValueScale", "RandomImageScale", "RandomRgbToGray", "RandomAdjustBrightness", "RandomAdjustContrast", "RandomAdjustHue", "RandomAdjustSaturation", "RandomDistortColor", "RandomJitterBoxes", "RandomCropImage", "RandomPadImage", "RandomCropPadImage", "RandomCropToAspectRatio", "RandomBlackPatches", "RandomResizeMethod", "ScaleBoxesToPixelCoordinates", "ResizeImage", "SubtractChannelMean", "SsdRandomCrop", "SsdRandomCropPad", "SsdRandomCropFixedAspectRatio", "SsdRandomCropPadFixedAspectRatio", "RandomVerticalFlip", "RandomRotation90", "RgbToGray", "ConvertClassLogitsToSoftmax", "RandomAbsolutePadImage", "RandomSelfConcatImage", "AutoaugmentImage", "DropLabelProbabilistically", "RemapLabels" }, new[]{ "PreprocessingStep" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.NormalizeImage), global::Tensorflow.Models.ObjectDetection.Protos.NormalizeImage.Parser, new[]{ "OriginalMinval", "OriginalMaxval", "TargetMinval", "TargetMaxval" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomHorizontalFlip), global::Tensorflow.Models.ObjectDetection.Protos.RandomHorizontalFlip.Parser, new[]{ "KeypointFlipPermutation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomVerticalFlip), global::Tensorflow.Models.ObjectDetection.Protos.RandomVerticalFlip.Parser, new[]{ "KeypointFlipPermutation" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomRotation90), global::Tensorflow.Models.ObjectDetection.Protos.RandomRotation90.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomPixelValueScale), global::Tensorflow.Models.ObjectDetection.Protos.RandomPixelValueScale.Parser, new[]{ "Minval", "Maxval" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomImageScale), global::Tensorflow.Models.ObjectDetection.Protos.RandomImageScale.Parser, new[]{ "MinScaleRatio", "MaxScaleRatio" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomRGBtoGray), global::Tensorflow.Models.ObjectDetection.Protos.RandomRGBtoGray.Parser, new[]{ "Probability" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustBrightness), global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustBrightness.Parser, new[]{ "MaxDelta" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustContrast), global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustContrast.Parser, new[]{ "MinDelta", "MaxDelta" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustHue), global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustHue.Parser, new[]{ "MaxDelta" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustSaturation), global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustSaturation.Parser, new[]{ "MinDelta", "MaxDelta" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomDistortColor), global::Tensorflow.Models.ObjectDetection.Protos.RandomDistortColor.Parser, new[]{ "ColorOrdering" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomJitterBoxes), global::Tensorflow.Models.ObjectDetection.Protos.RandomJitterBoxes.Parser, new[]{ "Ratio" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomCropImage), global::Tensorflow.Models.ObjectDetection.Protos.RandomCropImage.Parser, new[]{ "MinObjectCovered", "MinAspectRatio", "MaxAspectRatio", "MinArea", "MaxArea", "OverlapThresh", "ClipBoxes", "RandomCoef" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomPadImage), global::Tensorflow.Models.ObjectDetection.Protos.RandomPadImage.Parser, new[]{ "MinImageHeight", "MinImageWidth", "MaxImageHeight", "MaxImageWidth", "PadColor" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomAbsolutePadImage), global::Tensorflow.Models.ObjectDetection.Protos.RandomAbsolutePadImage.Parser, new[]{ "MaxHeightPadding", "MaxWidthPadding", "PadColor" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomCropPadImage), global::Tensorflow.Models.ObjectDetection.Protos.RandomCropPadImage.Parser, new[]{ "MinObjectCovered", "MinAspectRatio", "MaxAspectRatio", "MinArea", "MaxArea", "OverlapThresh", "ClipBoxes", "RandomCoef", "MinPaddedSizeRatio", "MaxPaddedSizeRatio", "PadColor" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomCropToAspectRatio), global::Tensorflow.Models.ObjectDetection.Protos.RandomCropToAspectRatio.Parser, new[]{ "AspectRatio", "OverlapThresh", "ClipBoxes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomBlackPatches), global::Tensorflow.Models.ObjectDetection.Protos.RandomBlackPatches.Parser, new[]{ "MaxBlackPatches", "Probability", "SizeToImageRatio" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomResizeMethod), global::Tensorflow.Models.ObjectDetection.Protos.RandomResizeMethod.Parser, new[]{ "TargetHeight", "TargetWidth" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RGBtoGray), global::Tensorflow.Models.ObjectDetection.Protos.RGBtoGray.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.ScaleBoxesToPixelCoordinates), global::Tensorflow.Models.ObjectDetection.Protos.ScaleBoxesToPixelCoordinates.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage), global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage.Parser, new[]{ "NewHeight", "NewWidth", "Method" }, null, new[]{ typeof(global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage.Types.Method) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SubtractChannelMean), global::Tensorflow.Models.ObjectDetection.Protos.SubtractChannelMean.Parser, new[]{ "Means" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropOperation), global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropOperation.Parser, new[]{ "MinObjectCovered", "MinAspectRatio", "MaxAspectRatio", "MinArea", "MaxArea", "OverlapThresh", "ClipBoxes", "RandomCoef" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCrop), global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCrop.Parser, new[]{ "Operations" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadOperation), global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadOperation.Parser, new[]{ "MinObjectCovered", "MinAspectRatio", "MaxAspectRatio", "MinArea", "MaxArea", "OverlapThresh", "ClipBoxes", "RandomCoef", "MinPaddedSizeRatio", "MaxPaddedSizeRatio", "PadColorR", "PadColorG", "PadColorB" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPad), global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPad.Parser, new[]{ "Operations" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatioOperation), global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatioOperation.Parser, new[]{ "MinObjectCovered", "MinArea", "MaxArea", "OverlapThresh", "ClipBoxes", "RandomCoef" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatio), global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatio.Parser, new[]{ "Operations", "AspectRatio" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatioOperation), global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatioOperation.Parser, new[]{ "MinObjectCovered", "MinAspectRatio", "MaxAspectRatio", "MinArea", "MaxArea", "OverlapThresh", "ClipBoxes", "RandomCoef" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatio), global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatio.Parser, new[]{ "Operations", "AspectRatio", "MinPaddedSizeRatio", "MaxPaddedSizeRatio" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.ConvertClassLogitsToSoftmax), global::Tensorflow.Models.ObjectDetection.Protos.ConvertClassLogitsToSoftmax.Parser, new[]{ "Temperature" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomSelfConcatImage), global::Tensorflow.Models.ObjectDetection.Protos.RandomSelfConcatImage.Parser, new[]{ "ConcatVerticalProbability", "ConcatHorizontalProbability" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.AutoAugmentImage), global::Tensorflow.Models.ObjectDetection.Protos.AutoAugmentImage.Parser, new[]{ "PolicyName" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.DropLabelProbabilistically), global::Tensorflow.Models.ObjectDetection.Protos.DropLabelProbabilistically.Parser, new[]{ "Label", "DropProbability" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RemapLabels), global::Tensorflow.Models.ObjectDetection.Protos.RemapLabels.Parser, new[]{ "OriginalLabels", "NewLabel" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Message for defining a preprocessing operation on input data.
  /// See: //third_party/tensorflow_models/object_detection/core/preprocessor.py
  /// </summary>
  public sealed partial class PreprocessingStep : pb::IMessage<PreprocessingStep> {
    private static readonly pb::MessageParser<PreprocessingStep> _parser = new pb::MessageParser<PreprocessingStep>(() => new PreprocessingStep());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PreprocessingStep> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PreprocessingStep() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PreprocessingStep(PreprocessingStep other) : this() {
      switch (other.PreprocessingStepCase) {
        case PreprocessingStepOneofCase.NormalizeImage:
          NormalizeImage = other.NormalizeImage.Clone();
          break;
        case PreprocessingStepOneofCase.RandomHorizontalFlip:
          RandomHorizontalFlip = other.RandomHorizontalFlip.Clone();
          break;
        case PreprocessingStepOneofCase.RandomPixelValueScale:
          RandomPixelValueScale = other.RandomPixelValueScale.Clone();
          break;
        case PreprocessingStepOneofCase.RandomImageScale:
          RandomImageScale = other.RandomImageScale.Clone();
          break;
        case PreprocessingStepOneofCase.RandomRgbToGray:
          RandomRgbToGray = other.RandomRgbToGray.Clone();
          break;
        case PreprocessingStepOneofCase.RandomAdjustBrightness:
          RandomAdjustBrightness = other.RandomAdjustBrightness.Clone();
          break;
        case PreprocessingStepOneofCase.RandomAdjustContrast:
          RandomAdjustContrast = other.RandomAdjustContrast.Clone();
          break;
        case PreprocessingStepOneofCase.RandomAdjustHue:
          RandomAdjustHue = other.RandomAdjustHue.Clone();
          break;
        case PreprocessingStepOneofCase.RandomAdjustSaturation:
          RandomAdjustSaturation = other.RandomAdjustSaturation.Clone();
          break;
        case PreprocessingStepOneofCase.RandomDistortColor:
          RandomDistortColor = other.RandomDistortColor.Clone();
          break;
        case PreprocessingStepOneofCase.RandomJitterBoxes:
          RandomJitterBoxes = other.RandomJitterBoxes.Clone();
          break;
        case PreprocessingStepOneofCase.RandomCropImage:
          RandomCropImage = other.RandomCropImage.Clone();
          break;
        case PreprocessingStepOneofCase.RandomPadImage:
          RandomPadImage = other.RandomPadImage.Clone();
          break;
        case PreprocessingStepOneofCase.RandomCropPadImage:
          RandomCropPadImage = other.RandomCropPadImage.Clone();
          break;
        case PreprocessingStepOneofCase.RandomCropToAspectRatio:
          RandomCropToAspectRatio = other.RandomCropToAspectRatio.Clone();
          break;
        case PreprocessingStepOneofCase.RandomBlackPatches:
          RandomBlackPatches = other.RandomBlackPatches.Clone();
          break;
        case PreprocessingStepOneofCase.RandomResizeMethod:
          RandomResizeMethod = other.RandomResizeMethod.Clone();
          break;
        case PreprocessingStepOneofCase.ScaleBoxesToPixelCoordinates:
          ScaleBoxesToPixelCoordinates = other.ScaleBoxesToPixelCoordinates.Clone();
          break;
        case PreprocessingStepOneofCase.ResizeImage:
          ResizeImage = other.ResizeImage.Clone();
          break;
        case PreprocessingStepOneofCase.SubtractChannelMean:
          SubtractChannelMean = other.SubtractChannelMean.Clone();
          break;
        case PreprocessingStepOneofCase.SsdRandomCrop:
          SsdRandomCrop = other.SsdRandomCrop.Clone();
          break;
        case PreprocessingStepOneofCase.SsdRandomCropPad:
          SsdRandomCropPad = other.SsdRandomCropPad.Clone();
          break;
        case PreprocessingStepOneofCase.SsdRandomCropFixedAspectRatio:
          SsdRandomCropFixedAspectRatio = other.SsdRandomCropFixedAspectRatio.Clone();
          break;
        case PreprocessingStepOneofCase.SsdRandomCropPadFixedAspectRatio:
          SsdRandomCropPadFixedAspectRatio = other.SsdRandomCropPadFixedAspectRatio.Clone();
          break;
        case PreprocessingStepOneofCase.RandomVerticalFlip:
          RandomVerticalFlip = other.RandomVerticalFlip.Clone();
          break;
        case PreprocessingStepOneofCase.RandomRotation90:
          RandomRotation90 = other.RandomRotation90.Clone();
          break;
        case PreprocessingStepOneofCase.RgbToGray:
          RgbToGray = other.RgbToGray.Clone();
          break;
        case PreprocessingStepOneofCase.ConvertClassLogitsToSoftmax:
          ConvertClassLogitsToSoftmax = other.ConvertClassLogitsToSoftmax.Clone();
          break;
        case PreprocessingStepOneofCase.RandomAbsolutePadImage:
          RandomAbsolutePadImage = other.RandomAbsolutePadImage.Clone();
          break;
        case PreprocessingStepOneofCase.RandomSelfConcatImage:
          RandomSelfConcatImage = other.RandomSelfConcatImage.Clone();
          break;
        case PreprocessingStepOneofCase.AutoaugmentImage:
          AutoaugmentImage = other.AutoaugmentImage.Clone();
          break;
        case PreprocessingStepOneofCase.DropLabelProbabilistically:
          DropLabelProbabilistically = other.DropLabelProbabilistically.Clone();
          break;
        case PreprocessingStepOneofCase.RemapLabels:
          RemapLabels = other.RemapLabels.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PreprocessingStep Clone() {
      return new PreprocessingStep(this);
    }

    /// <summary>Field number for the "normalize_image" field.</summary>
    public const int NormalizeImageFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.NormalizeImage NormalizeImage {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.NormalizeImage ? (global::Tensorflow.Models.ObjectDetection.Protos.NormalizeImage) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.NormalizeImage;
      }
    }

    /// <summary>Field number for the "random_horizontal_flip" field.</summary>
    public const int RandomHorizontalFlipFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomHorizontalFlip RandomHorizontalFlip {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomHorizontalFlip ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomHorizontalFlip) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomHorizontalFlip;
      }
    }

    /// <summary>Field number for the "random_pixel_value_scale" field.</summary>
    public const int RandomPixelValueScaleFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomPixelValueScale RandomPixelValueScale {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPixelValueScale ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomPixelValueScale) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomPixelValueScale;
      }
    }

    /// <summary>Field number for the "random_image_scale" field.</summary>
    public const int RandomImageScaleFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomImageScale RandomImageScale {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomImageScale ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomImageScale) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomImageScale;
      }
    }

    /// <summary>Field number for the "random_rgb_to_gray" field.</summary>
    public const int RandomRgbToGrayFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomRGBtoGray RandomRgbToGray {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRgbToGray ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomRGBtoGray) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomRgbToGray;
      }
    }

    /// <summary>Field number for the "random_adjust_brightness" field.</summary>
    public const int RandomAdjustBrightnessFieldNumber = 6;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustBrightness RandomAdjustBrightness {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustBrightness ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustBrightness) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomAdjustBrightness;
      }
    }

    /// <summary>Field number for the "random_adjust_contrast" field.</summary>
    public const int RandomAdjustContrastFieldNumber = 7;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustContrast RandomAdjustContrast {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustContrast ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustContrast) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomAdjustContrast;
      }
    }

    /// <summary>Field number for the "random_adjust_hue" field.</summary>
    public const int RandomAdjustHueFieldNumber = 8;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustHue RandomAdjustHue {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustHue ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustHue) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomAdjustHue;
      }
    }

    /// <summary>Field number for the "random_adjust_saturation" field.</summary>
    public const int RandomAdjustSaturationFieldNumber = 9;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustSaturation RandomAdjustSaturation {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustSaturation ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustSaturation) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomAdjustSaturation;
      }
    }

    /// <summary>Field number for the "random_distort_color" field.</summary>
    public const int RandomDistortColorFieldNumber = 10;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomDistortColor RandomDistortColor {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomDistortColor ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomDistortColor) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomDistortColor;
      }
    }

    /// <summary>Field number for the "random_jitter_boxes" field.</summary>
    public const int RandomJitterBoxesFieldNumber = 11;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomJitterBoxes RandomJitterBoxes {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomJitterBoxes ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomJitterBoxes) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomJitterBoxes;
      }
    }

    /// <summary>Field number for the "random_crop_image" field.</summary>
    public const int RandomCropImageFieldNumber = 12;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomCropImage RandomCropImage {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropImage ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomCropImage) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomCropImage;
      }
    }

    /// <summary>Field number for the "random_pad_image" field.</summary>
    public const int RandomPadImageFieldNumber = 13;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomPadImage RandomPadImage {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPadImage ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomPadImage) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomPadImage;
      }
    }

    /// <summary>Field number for the "random_crop_pad_image" field.</summary>
    public const int RandomCropPadImageFieldNumber = 14;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomCropPadImage RandomCropPadImage {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropPadImage ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomCropPadImage) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomCropPadImage;
      }
    }

    /// <summary>Field number for the "random_crop_to_aspect_ratio" field.</summary>
    public const int RandomCropToAspectRatioFieldNumber = 15;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomCropToAspectRatio RandomCropToAspectRatio {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropToAspectRatio ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomCropToAspectRatio) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomCropToAspectRatio;
      }
    }

    /// <summary>Field number for the "random_black_patches" field.</summary>
    public const int RandomBlackPatchesFieldNumber = 16;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomBlackPatches RandomBlackPatches {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomBlackPatches ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomBlackPatches) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomBlackPatches;
      }
    }

    /// <summary>Field number for the "random_resize_method" field.</summary>
    public const int RandomResizeMethodFieldNumber = 17;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomResizeMethod RandomResizeMethod {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomResizeMethod ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomResizeMethod) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomResizeMethod;
      }
    }

    /// <summary>Field number for the "scale_boxes_to_pixel_coordinates" field.</summary>
    public const int ScaleBoxesToPixelCoordinatesFieldNumber = 18;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ScaleBoxesToPixelCoordinates ScaleBoxesToPixelCoordinates {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.ScaleBoxesToPixelCoordinates ? (global::Tensorflow.Models.ObjectDetection.Protos.ScaleBoxesToPixelCoordinates) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.ScaleBoxesToPixelCoordinates;
      }
    }

    /// <summary>Field number for the "resize_image" field.</summary>
    public const int ResizeImageFieldNumber = 19;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage ResizeImage {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.ResizeImage ? (global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.ResizeImage;
      }
    }

    /// <summary>Field number for the "subtract_channel_mean" field.</summary>
    public const int SubtractChannelMeanFieldNumber = 20;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.SubtractChannelMean SubtractChannelMean {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.SubtractChannelMean ? (global::Tensorflow.Models.ObjectDetection.Protos.SubtractChannelMean) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.SubtractChannelMean;
      }
    }

    /// <summary>Field number for the "ssd_random_crop" field.</summary>
    public const int SsdRandomCropFieldNumber = 21;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCrop SsdRandomCrop {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCrop ? (global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCrop) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.SsdRandomCrop;
      }
    }

    /// <summary>Field number for the "ssd_random_crop_pad" field.</summary>
    public const int SsdRandomCropPadFieldNumber = 22;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPad SsdRandomCropPad {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPad ? (global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPad) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.SsdRandomCropPad;
      }
    }

    /// <summary>Field number for the "ssd_random_crop_fixed_aspect_ratio" field.</summary>
    public const int SsdRandomCropFixedAspectRatioFieldNumber = 23;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatio SsdRandomCropFixedAspectRatio {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropFixedAspectRatio ? (global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatio) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.SsdRandomCropFixedAspectRatio;
      }
    }

    /// <summary>Field number for the "ssd_random_crop_pad_fixed_aspect_ratio" field.</summary>
    public const int SsdRandomCropPadFixedAspectRatioFieldNumber = 24;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatio SsdRandomCropPadFixedAspectRatio {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPadFixedAspectRatio ? (global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatio) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.SsdRandomCropPadFixedAspectRatio;
      }
    }

    /// <summary>Field number for the "random_vertical_flip" field.</summary>
    public const int RandomVerticalFlipFieldNumber = 25;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomVerticalFlip RandomVerticalFlip {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomVerticalFlip ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomVerticalFlip) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomVerticalFlip;
      }
    }

    /// <summary>Field number for the "random_rotation90" field.</summary>
    public const int RandomRotation90FieldNumber = 26;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomRotation90 RandomRotation90 {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRotation90 ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomRotation90) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomRotation90;
      }
    }

    /// <summary>Field number for the "rgb_to_gray" field.</summary>
    public const int RgbToGrayFieldNumber = 27;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RGBtoGray RgbToGray {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RgbToGray ? (global::Tensorflow.Models.ObjectDetection.Protos.RGBtoGray) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RgbToGray;
      }
    }

    /// <summary>Field number for the "convert_class_logits_to_softmax" field.</summary>
    public const int ConvertClassLogitsToSoftmaxFieldNumber = 28;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ConvertClassLogitsToSoftmax ConvertClassLogitsToSoftmax {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.ConvertClassLogitsToSoftmax ? (global::Tensorflow.Models.ObjectDetection.Protos.ConvertClassLogitsToSoftmax) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.ConvertClassLogitsToSoftmax;
      }
    }

    /// <summary>Field number for the "random_absolute_pad_image" field.</summary>
    public const int RandomAbsolutePadImageFieldNumber = 29;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomAbsolutePadImage RandomAbsolutePadImage {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAbsolutePadImage ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomAbsolutePadImage) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomAbsolutePadImage;
      }
    }

    /// <summary>Field number for the "random_self_concat_image" field.</summary>
    public const int RandomSelfConcatImageFieldNumber = 30;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomSelfConcatImage RandomSelfConcatImage {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RandomSelfConcatImage ? (global::Tensorflow.Models.ObjectDetection.Protos.RandomSelfConcatImage) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RandomSelfConcatImage;
      }
    }

    /// <summary>Field number for the "autoaugment_image" field.</summary>
    public const int AutoaugmentImageFieldNumber = 31;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.AutoAugmentImage AutoaugmentImage {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.AutoaugmentImage ? (global::Tensorflow.Models.ObjectDetection.Protos.AutoAugmentImage) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.AutoaugmentImage;
      }
    }

    /// <summary>Field number for the "drop_label_probabilistically" field.</summary>
    public const int DropLabelProbabilisticallyFieldNumber = 32;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.DropLabelProbabilistically DropLabelProbabilistically {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.DropLabelProbabilistically ? (global::Tensorflow.Models.ObjectDetection.Protos.DropLabelProbabilistically) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.DropLabelProbabilistically;
      }
    }

    /// <summary>Field number for the "remap_labels" field.</summary>
    public const int RemapLabelsFieldNumber = 33;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RemapLabels RemapLabels {
      get { return preprocessingStepCase_ == PreprocessingStepOneofCase.RemapLabels ? (global::Tensorflow.Models.ObjectDetection.Protos.RemapLabels) preprocessingStep_ : null; }
      set {
        preprocessingStep_ = value;
        preprocessingStepCase_ = value == null ? PreprocessingStepOneofCase.None : PreprocessingStepOneofCase.RemapLabels;
      }
    }

    private object preprocessingStep_;
    /// <summary>Enum of possible cases for the "preprocessing_step" oneof.</summary>
    public enum PreprocessingStepOneofCase {
      None = 0,
      NormalizeImage = 1,
      RandomHorizontalFlip = 2,
      RandomPixelValueScale = 3,
      RandomImageScale = 4,
      RandomRgbToGray = 5,
      RandomAdjustBrightness = 6,
      RandomAdjustContrast = 7,
      RandomAdjustHue = 8,
      RandomAdjustSaturation = 9,
      RandomDistortColor = 10,
      RandomJitterBoxes = 11,
      RandomCropImage = 12,
      RandomPadImage = 13,
      RandomCropPadImage = 14,
      RandomCropToAspectRatio = 15,
      RandomBlackPatches = 16,
      RandomResizeMethod = 17,
      ScaleBoxesToPixelCoordinates = 18,
      ResizeImage = 19,
      SubtractChannelMean = 20,
      SsdRandomCrop = 21,
      SsdRandomCropPad = 22,
      SsdRandomCropFixedAspectRatio = 23,
      SsdRandomCropPadFixedAspectRatio = 24,
      RandomVerticalFlip = 25,
      RandomRotation90 = 26,
      RgbToGray = 27,
      ConvertClassLogitsToSoftmax = 28,
      RandomAbsolutePadImage = 29,
      RandomSelfConcatImage = 30,
      AutoaugmentImage = 31,
      DropLabelProbabilistically = 32,
      RemapLabels = 33,
    }
    private PreprocessingStepOneofCase preprocessingStepCase_ = PreprocessingStepOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PreprocessingStepOneofCase PreprocessingStepCase {
      get { return preprocessingStepCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearPreprocessingStep() {
      preprocessingStepCase_ = PreprocessingStepOneofCase.None;
      preprocessingStep_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PreprocessingStep);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PreprocessingStep other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(NormalizeImage, other.NormalizeImage)) return false;
      if (!object.Equals(RandomHorizontalFlip, other.RandomHorizontalFlip)) return false;
      if (!object.Equals(RandomPixelValueScale, other.RandomPixelValueScale)) return false;
      if (!object.Equals(RandomImageScale, other.RandomImageScale)) return false;
      if (!object.Equals(RandomRgbToGray, other.RandomRgbToGray)) return false;
      if (!object.Equals(RandomAdjustBrightness, other.RandomAdjustBrightness)) return false;
      if (!object.Equals(RandomAdjustContrast, other.RandomAdjustContrast)) return false;
      if (!object.Equals(RandomAdjustHue, other.RandomAdjustHue)) return false;
      if (!object.Equals(RandomAdjustSaturation, other.RandomAdjustSaturation)) return false;
      if (!object.Equals(RandomDistortColor, other.RandomDistortColor)) return false;
      if (!object.Equals(RandomJitterBoxes, other.RandomJitterBoxes)) return false;
      if (!object.Equals(RandomCropImage, other.RandomCropImage)) return false;
      if (!object.Equals(RandomPadImage, other.RandomPadImage)) return false;
      if (!object.Equals(RandomCropPadImage, other.RandomCropPadImage)) return false;
      if (!object.Equals(RandomCropToAspectRatio, other.RandomCropToAspectRatio)) return false;
      if (!object.Equals(RandomBlackPatches, other.RandomBlackPatches)) return false;
      if (!object.Equals(RandomResizeMethod, other.RandomResizeMethod)) return false;
      if (!object.Equals(ScaleBoxesToPixelCoordinates, other.ScaleBoxesToPixelCoordinates)) return false;
      if (!object.Equals(ResizeImage, other.ResizeImage)) return false;
      if (!object.Equals(SubtractChannelMean, other.SubtractChannelMean)) return false;
      if (!object.Equals(SsdRandomCrop, other.SsdRandomCrop)) return false;
      if (!object.Equals(SsdRandomCropPad, other.SsdRandomCropPad)) return false;
      if (!object.Equals(SsdRandomCropFixedAspectRatio, other.SsdRandomCropFixedAspectRatio)) return false;
      if (!object.Equals(SsdRandomCropPadFixedAspectRatio, other.SsdRandomCropPadFixedAspectRatio)) return false;
      if (!object.Equals(RandomVerticalFlip, other.RandomVerticalFlip)) return false;
      if (!object.Equals(RandomRotation90, other.RandomRotation90)) return false;
      if (!object.Equals(RgbToGray, other.RgbToGray)) return false;
      if (!object.Equals(ConvertClassLogitsToSoftmax, other.ConvertClassLogitsToSoftmax)) return false;
      if (!object.Equals(RandomAbsolutePadImage, other.RandomAbsolutePadImage)) return false;
      if (!object.Equals(RandomSelfConcatImage, other.RandomSelfConcatImage)) return false;
      if (!object.Equals(AutoaugmentImage, other.AutoaugmentImage)) return false;
      if (!object.Equals(DropLabelProbabilistically, other.DropLabelProbabilistically)) return false;
      if (!object.Equals(RemapLabels, other.RemapLabels)) return false;
      if (PreprocessingStepCase != other.PreprocessingStepCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.NormalizeImage) hash ^= NormalizeImage.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomHorizontalFlip) hash ^= RandomHorizontalFlip.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPixelValueScale) hash ^= RandomPixelValueScale.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomImageScale) hash ^= RandomImageScale.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRgbToGray) hash ^= RandomRgbToGray.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustBrightness) hash ^= RandomAdjustBrightness.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustContrast) hash ^= RandomAdjustContrast.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustHue) hash ^= RandomAdjustHue.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustSaturation) hash ^= RandomAdjustSaturation.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomDistortColor) hash ^= RandomDistortColor.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomJitterBoxes) hash ^= RandomJitterBoxes.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropImage) hash ^= RandomCropImage.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPadImage) hash ^= RandomPadImage.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropPadImage) hash ^= RandomCropPadImage.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropToAspectRatio) hash ^= RandomCropToAspectRatio.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomBlackPatches) hash ^= RandomBlackPatches.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomResizeMethod) hash ^= RandomResizeMethod.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ScaleBoxesToPixelCoordinates) hash ^= ScaleBoxesToPixelCoordinates.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ResizeImage) hash ^= ResizeImage.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SubtractChannelMean) hash ^= SubtractChannelMean.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCrop) hash ^= SsdRandomCrop.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPad) hash ^= SsdRandomCropPad.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropFixedAspectRatio) hash ^= SsdRandomCropFixedAspectRatio.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPadFixedAspectRatio) hash ^= SsdRandomCropPadFixedAspectRatio.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomVerticalFlip) hash ^= RandomVerticalFlip.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRotation90) hash ^= RandomRotation90.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RgbToGray) hash ^= RgbToGray.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ConvertClassLogitsToSoftmax) hash ^= ConvertClassLogitsToSoftmax.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAbsolutePadImage) hash ^= RandomAbsolutePadImage.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomSelfConcatImage) hash ^= RandomSelfConcatImage.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.AutoaugmentImage) hash ^= AutoaugmentImage.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.DropLabelProbabilistically) hash ^= DropLabelProbabilistically.GetHashCode();
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RemapLabels) hash ^= RemapLabels.GetHashCode();
      hash ^= (int) preprocessingStepCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.NormalizeImage) {
        output.WriteRawTag(10);
        output.WriteMessage(NormalizeImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomHorizontalFlip) {
        output.WriteRawTag(18);
        output.WriteMessage(RandomHorizontalFlip);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPixelValueScale) {
        output.WriteRawTag(26);
        output.WriteMessage(RandomPixelValueScale);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomImageScale) {
        output.WriteRawTag(34);
        output.WriteMessage(RandomImageScale);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRgbToGray) {
        output.WriteRawTag(42);
        output.WriteMessage(RandomRgbToGray);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustBrightness) {
        output.WriteRawTag(50);
        output.WriteMessage(RandomAdjustBrightness);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustContrast) {
        output.WriteRawTag(58);
        output.WriteMessage(RandomAdjustContrast);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustHue) {
        output.WriteRawTag(66);
        output.WriteMessage(RandomAdjustHue);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustSaturation) {
        output.WriteRawTag(74);
        output.WriteMessage(RandomAdjustSaturation);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomDistortColor) {
        output.WriteRawTag(82);
        output.WriteMessage(RandomDistortColor);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomJitterBoxes) {
        output.WriteRawTag(90);
        output.WriteMessage(RandomJitterBoxes);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropImage) {
        output.WriteRawTag(98);
        output.WriteMessage(RandomCropImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPadImage) {
        output.WriteRawTag(106);
        output.WriteMessage(RandomPadImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropPadImage) {
        output.WriteRawTag(114);
        output.WriteMessage(RandomCropPadImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropToAspectRatio) {
        output.WriteRawTag(122);
        output.WriteMessage(RandomCropToAspectRatio);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomBlackPatches) {
        output.WriteRawTag(130, 1);
        output.WriteMessage(RandomBlackPatches);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomResizeMethod) {
        output.WriteRawTag(138, 1);
        output.WriteMessage(RandomResizeMethod);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ScaleBoxesToPixelCoordinates) {
        output.WriteRawTag(146, 1);
        output.WriteMessage(ScaleBoxesToPixelCoordinates);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ResizeImage) {
        output.WriteRawTag(154, 1);
        output.WriteMessage(ResizeImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SubtractChannelMean) {
        output.WriteRawTag(162, 1);
        output.WriteMessage(SubtractChannelMean);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCrop) {
        output.WriteRawTag(170, 1);
        output.WriteMessage(SsdRandomCrop);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPad) {
        output.WriteRawTag(178, 1);
        output.WriteMessage(SsdRandomCropPad);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropFixedAspectRatio) {
        output.WriteRawTag(186, 1);
        output.WriteMessage(SsdRandomCropFixedAspectRatio);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPadFixedAspectRatio) {
        output.WriteRawTag(194, 1);
        output.WriteMessage(SsdRandomCropPadFixedAspectRatio);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomVerticalFlip) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(RandomVerticalFlip);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRotation90) {
        output.WriteRawTag(210, 1);
        output.WriteMessage(RandomRotation90);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RgbToGray) {
        output.WriteRawTag(218, 1);
        output.WriteMessage(RgbToGray);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ConvertClassLogitsToSoftmax) {
        output.WriteRawTag(226, 1);
        output.WriteMessage(ConvertClassLogitsToSoftmax);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAbsolutePadImage) {
        output.WriteRawTag(234, 1);
        output.WriteMessage(RandomAbsolutePadImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomSelfConcatImage) {
        output.WriteRawTag(242, 1);
        output.WriteMessage(RandomSelfConcatImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.AutoaugmentImage) {
        output.WriteRawTag(250, 1);
        output.WriteMessage(AutoaugmentImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.DropLabelProbabilistically) {
        output.WriteRawTag(130, 2);
        output.WriteMessage(DropLabelProbabilistically);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RemapLabels) {
        output.WriteRawTag(138, 2);
        output.WriteMessage(RemapLabels);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.NormalizeImage) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(NormalizeImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomHorizontalFlip) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomHorizontalFlip);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPixelValueScale) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomPixelValueScale);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomImageScale) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomImageScale);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRgbToGray) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomRgbToGray);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustBrightness) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomAdjustBrightness);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustContrast) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomAdjustContrast);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustHue) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomAdjustHue);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustSaturation) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomAdjustSaturation);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomDistortColor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomDistortColor);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomJitterBoxes) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomJitterBoxes);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropImage) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomCropImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPadImage) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomPadImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropPadImage) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomCropPadImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropToAspectRatio) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomCropToAspectRatio);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomBlackPatches) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RandomBlackPatches);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomResizeMethod) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RandomResizeMethod);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ScaleBoxesToPixelCoordinates) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ScaleBoxesToPixelCoordinates);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ResizeImage) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ResizeImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SubtractChannelMean) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SubtractChannelMean);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCrop) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SsdRandomCrop);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPad) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SsdRandomCropPad);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropFixedAspectRatio) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SsdRandomCropFixedAspectRatio);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPadFixedAspectRatio) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(SsdRandomCropPadFixedAspectRatio);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomVerticalFlip) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RandomVerticalFlip);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRotation90) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RandomRotation90);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RgbToGray) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RgbToGray);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.ConvertClassLogitsToSoftmax) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(ConvertClassLogitsToSoftmax);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAbsolutePadImage) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RandomAbsolutePadImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomSelfConcatImage) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RandomSelfConcatImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.AutoaugmentImage) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(AutoaugmentImage);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.DropLabelProbabilistically) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(DropLabelProbabilistically);
      }
      if (preprocessingStepCase_ == PreprocessingStepOneofCase.RemapLabels) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(RemapLabels);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PreprocessingStep other) {
      if (other == null) {
        return;
      }
      switch (other.PreprocessingStepCase) {
        case PreprocessingStepOneofCase.NormalizeImage:
          if (NormalizeImage == null) {
            NormalizeImage = new global::Tensorflow.Models.ObjectDetection.Protos.NormalizeImage();
          }
          NormalizeImage.MergeFrom(other.NormalizeImage);
          break;
        case PreprocessingStepOneofCase.RandomHorizontalFlip:
          if (RandomHorizontalFlip == null) {
            RandomHorizontalFlip = new global::Tensorflow.Models.ObjectDetection.Protos.RandomHorizontalFlip();
          }
          RandomHorizontalFlip.MergeFrom(other.RandomHorizontalFlip);
          break;
        case PreprocessingStepOneofCase.RandomPixelValueScale:
          if (RandomPixelValueScale == null) {
            RandomPixelValueScale = new global::Tensorflow.Models.ObjectDetection.Protos.RandomPixelValueScale();
          }
          RandomPixelValueScale.MergeFrom(other.RandomPixelValueScale);
          break;
        case PreprocessingStepOneofCase.RandomImageScale:
          if (RandomImageScale == null) {
            RandomImageScale = new global::Tensorflow.Models.ObjectDetection.Protos.RandomImageScale();
          }
          RandomImageScale.MergeFrom(other.RandomImageScale);
          break;
        case PreprocessingStepOneofCase.RandomRgbToGray:
          if (RandomRgbToGray == null) {
            RandomRgbToGray = new global::Tensorflow.Models.ObjectDetection.Protos.RandomRGBtoGray();
          }
          RandomRgbToGray.MergeFrom(other.RandomRgbToGray);
          break;
        case PreprocessingStepOneofCase.RandomAdjustBrightness:
          if (RandomAdjustBrightness == null) {
            RandomAdjustBrightness = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustBrightness();
          }
          RandomAdjustBrightness.MergeFrom(other.RandomAdjustBrightness);
          break;
        case PreprocessingStepOneofCase.RandomAdjustContrast:
          if (RandomAdjustContrast == null) {
            RandomAdjustContrast = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustContrast();
          }
          RandomAdjustContrast.MergeFrom(other.RandomAdjustContrast);
          break;
        case PreprocessingStepOneofCase.RandomAdjustHue:
          if (RandomAdjustHue == null) {
            RandomAdjustHue = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustHue();
          }
          RandomAdjustHue.MergeFrom(other.RandomAdjustHue);
          break;
        case PreprocessingStepOneofCase.RandomAdjustSaturation:
          if (RandomAdjustSaturation == null) {
            RandomAdjustSaturation = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustSaturation();
          }
          RandomAdjustSaturation.MergeFrom(other.RandomAdjustSaturation);
          break;
        case PreprocessingStepOneofCase.RandomDistortColor:
          if (RandomDistortColor == null) {
            RandomDistortColor = new global::Tensorflow.Models.ObjectDetection.Protos.RandomDistortColor();
          }
          RandomDistortColor.MergeFrom(other.RandomDistortColor);
          break;
        case PreprocessingStepOneofCase.RandomJitterBoxes:
          if (RandomJitterBoxes == null) {
            RandomJitterBoxes = new global::Tensorflow.Models.ObjectDetection.Protos.RandomJitterBoxes();
          }
          RandomJitterBoxes.MergeFrom(other.RandomJitterBoxes);
          break;
        case PreprocessingStepOneofCase.RandomCropImage:
          if (RandomCropImage == null) {
            RandomCropImage = new global::Tensorflow.Models.ObjectDetection.Protos.RandomCropImage();
          }
          RandomCropImage.MergeFrom(other.RandomCropImage);
          break;
        case PreprocessingStepOneofCase.RandomPadImage:
          if (RandomPadImage == null) {
            RandomPadImage = new global::Tensorflow.Models.ObjectDetection.Protos.RandomPadImage();
          }
          RandomPadImage.MergeFrom(other.RandomPadImage);
          break;
        case PreprocessingStepOneofCase.RandomCropPadImage:
          if (RandomCropPadImage == null) {
            RandomCropPadImage = new global::Tensorflow.Models.ObjectDetection.Protos.RandomCropPadImage();
          }
          RandomCropPadImage.MergeFrom(other.RandomCropPadImage);
          break;
        case PreprocessingStepOneofCase.RandomCropToAspectRatio:
          if (RandomCropToAspectRatio == null) {
            RandomCropToAspectRatio = new global::Tensorflow.Models.ObjectDetection.Protos.RandomCropToAspectRatio();
          }
          RandomCropToAspectRatio.MergeFrom(other.RandomCropToAspectRatio);
          break;
        case PreprocessingStepOneofCase.RandomBlackPatches:
          if (RandomBlackPatches == null) {
            RandomBlackPatches = new global::Tensorflow.Models.ObjectDetection.Protos.RandomBlackPatches();
          }
          RandomBlackPatches.MergeFrom(other.RandomBlackPatches);
          break;
        case PreprocessingStepOneofCase.RandomResizeMethod:
          if (RandomResizeMethod == null) {
            RandomResizeMethod = new global::Tensorflow.Models.ObjectDetection.Protos.RandomResizeMethod();
          }
          RandomResizeMethod.MergeFrom(other.RandomResizeMethod);
          break;
        case PreprocessingStepOneofCase.ScaleBoxesToPixelCoordinates:
          if (ScaleBoxesToPixelCoordinates == null) {
            ScaleBoxesToPixelCoordinates = new global::Tensorflow.Models.ObjectDetection.Protos.ScaleBoxesToPixelCoordinates();
          }
          ScaleBoxesToPixelCoordinates.MergeFrom(other.ScaleBoxesToPixelCoordinates);
          break;
        case PreprocessingStepOneofCase.ResizeImage:
          if (ResizeImage == null) {
            ResizeImage = new global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage();
          }
          ResizeImage.MergeFrom(other.ResizeImage);
          break;
        case PreprocessingStepOneofCase.SubtractChannelMean:
          if (SubtractChannelMean == null) {
            SubtractChannelMean = new global::Tensorflow.Models.ObjectDetection.Protos.SubtractChannelMean();
          }
          SubtractChannelMean.MergeFrom(other.SubtractChannelMean);
          break;
        case PreprocessingStepOneofCase.SsdRandomCrop:
          if (SsdRandomCrop == null) {
            SsdRandomCrop = new global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCrop();
          }
          SsdRandomCrop.MergeFrom(other.SsdRandomCrop);
          break;
        case PreprocessingStepOneofCase.SsdRandomCropPad:
          if (SsdRandomCropPad == null) {
            SsdRandomCropPad = new global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPad();
          }
          SsdRandomCropPad.MergeFrom(other.SsdRandomCropPad);
          break;
        case PreprocessingStepOneofCase.SsdRandomCropFixedAspectRatio:
          if (SsdRandomCropFixedAspectRatio == null) {
            SsdRandomCropFixedAspectRatio = new global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatio();
          }
          SsdRandomCropFixedAspectRatio.MergeFrom(other.SsdRandomCropFixedAspectRatio);
          break;
        case PreprocessingStepOneofCase.SsdRandomCropPadFixedAspectRatio:
          if (SsdRandomCropPadFixedAspectRatio == null) {
            SsdRandomCropPadFixedAspectRatio = new global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatio();
          }
          SsdRandomCropPadFixedAspectRatio.MergeFrom(other.SsdRandomCropPadFixedAspectRatio);
          break;
        case PreprocessingStepOneofCase.RandomVerticalFlip:
          if (RandomVerticalFlip == null) {
            RandomVerticalFlip = new global::Tensorflow.Models.ObjectDetection.Protos.RandomVerticalFlip();
          }
          RandomVerticalFlip.MergeFrom(other.RandomVerticalFlip);
          break;
        case PreprocessingStepOneofCase.RandomRotation90:
          if (RandomRotation90 == null) {
            RandomRotation90 = new global::Tensorflow.Models.ObjectDetection.Protos.RandomRotation90();
          }
          RandomRotation90.MergeFrom(other.RandomRotation90);
          break;
        case PreprocessingStepOneofCase.RgbToGray:
          if (RgbToGray == null) {
            RgbToGray = new global::Tensorflow.Models.ObjectDetection.Protos.RGBtoGray();
          }
          RgbToGray.MergeFrom(other.RgbToGray);
          break;
        case PreprocessingStepOneofCase.ConvertClassLogitsToSoftmax:
          if (ConvertClassLogitsToSoftmax == null) {
            ConvertClassLogitsToSoftmax = new global::Tensorflow.Models.ObjectDetection.Protos.ConvertClassLogitsToSoftmax();
          }
          ConvertClassLogitsToSoftmax.MergeFrom(other.ConvertClassLogitsToSoftmax);
          break;
        case PreprocessingStepOneofCase.RandomAbsolutePadImage:
          if (RandomAbsolutePadImage == null) {
            RandomAbsolutePadImage = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAbsolutePadImage();
          }
          RandomAbsolutePadImage.MergeFrom(other.RandomAbsolutePadImage);
          break;
        case PreprocessingStepOneofCase.RandomSelfConcatImage:
          if (RandomSelfConcatImage == null) {
            RandomSelfConcatImage = new global::Tensorflow.Models.ObjectDetection.Protos.RandomSelfConcatImage();
          }
          RandomSelfConcatImage.MergeFrom(other.RandomSelfConcatImage);
          break;
        case PreprocessingStepOneofCase.AutoaugmentImage:
          if (AutoaugmentImage == null) {
            AutoaugmentImage = new global::Tensorflow.Models.ObjectDetection.Protos.AutoAugmentImage();
          }
          AutoaugmentImage.MergeFrom(other.AutoaugmentImage);
          break;
        case PreprocessingStepOneofCase.DropLabelProbabilistically:
          if (DropLabelProbabilistically == null) {
            DropLabelProbabilistically = new global::Tensorflow.Models.ObjectDetection.Protos.DropLabelProbabilistically();
          }
          DropLabelProbabilistically.MergeFrom(other.DropLabelProbabilistically);
          break;
        case PreprocessingStepOneofCase.RemapLabels:
          if (RemapLabels == null) {
            RemapLabels = new global::Tensorflow.Models.ObjectDetection.Protos.RemapLabels();
          }
          RemapLabels.MergeFrom(other.RemapLabels);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Tensorflow.Models.ObjectDetection.Protos.NormalizeImage subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.NormalizeImage();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.NormalizeImage) {
              subBuilder.MergeFrom(NormalizeImage);
            }
            input.ReadMessage(subBuilder);
            NormalizeImage = subBuilder;
            break;
          }
          case 18: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomHorizontalFlip subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomHorizontalFlip();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomHorizontalFlip) {
              subBuilder.MergeFrom(RandomHorizontalFlip);
            }
            input.ReadMessage(subBuilder);
            RandomHorizontalFlip = subBuilder;
            break;
          }
          case 26: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomPixelValueScale subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomPixelValueScale();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPixelValueScale) {
              subBuilder.MergeFrom(RandomPixelValueScale);
            }
            input.ReadMessage(subBuilder);
            RandomPixelValueScale = subBuilder;
            break;
          }
          case 34: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomImageScale subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomImageScale();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomImageScale) {
              subBuilder.MergeFrom(RandomImageScale);
            }
            input.ReadMessage(subBuilder);
            RandomImageScale = subBuilder;
            break;
          }
          case 42: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomRGBtoGray subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomRGBtoGray();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRgbToGray) {
              subBuilder.MergeFrom(RandomRgbToGray);
            }
            input.ReadMessage(subBuilder);
            RandomRgbToGray = subBuilder;
            break;
          }
          case 50: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustBrightness subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustBrightness();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustBrightness) {
              subBuilder.MergeFrom(RandomAdjustBrightness);
            }
            input.ReadMessage(subBuilder);
            RandomAdjustBrightness = subBuilder;
            break;
          }
          case 58: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustContrast subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustContrast();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustContrast) {
              subBuilder.MergeFrom(RandomAdjustContrast);
            }
            input.ReadMessage(subBuilder);
            RandomAdjustContrast = subBuilder;
            break;
          }
          case 66: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustHue subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustHue();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustHue) {
              subBuilder.MergeFrom(RandomAdjustHue);
            }
            input.ReadMessage(subBuilder);
            RandomAdjustHue = subBuilder;
            break;
          }
          case 74: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustSaturation subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAdjustSaturation();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAdjustSaturation) {
              subBuilder.MergeFrom(RandomAdjustSaturation);
            }
            input.ReadMessage(subBuilder);
            RandomAdjustSaturation = subBuilder;
            break;
          }
          case 82: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomDistortColor subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomDistortColor();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomDistortColor) {
              subBuilder.MergeFrom(RandomDistortColor);
            }
            input.ReadMessage(subBuilder);
            RandomDistortColor = subBuilder;
            break;
          }
          case 90: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomJitterBoxes subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomJitterBoxes();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomJitterBoxes) {
              subBuilder.MergeFrom(RandomJitterBoxes);
            }
            input.ReadMessage(subBuilder);
            RandomJitterBoxes = subBuilder;
            break;
          }
          case 98: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomCropImage subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomCropImage();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropImage) {
              subBuilder.MergeFrom(RandomCropImage);
            }
            input.ReadMessage(subBuilder);
            RandomCropImage = subBuilder;
            break;
          }
          case 106: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomPadImage subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomPadImage();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomPadImage) {
              subBuilder.MergeFrom(RandomPadImage);
            }
            input.ReadMessage(subBuilder);
            RandomPadImage = subBuilder;
            break;
          }
          case 114: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomCropPadImage subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomCropPadImage();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropPadImage) {
              subBuilder.MergeFrom(RandomCropPadImage);
            }
            input.ReadMessage(subBuilder);
            RandomCropPadImage = subBuilder;
            break;
          }
          case 122: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomCropToAspectRatio subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomCropToAspectRatio();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomCropToAspectRatio) {
              subBuilder.MergeFrom(RandomCropToAspectRatio);
            }
            input.ReadMessage(subBuilder);
            RandomCropToAspectRatio = subBuilder;
            break;
          }
          case 130: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomBlackPatches subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomBlackPatches();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomBlackPatches) {
              subBuilder.MergeFrom(RandomBlackPatches);
            }
            input.ReadMessage(subBuilder);
            RandomBlackPatches = subBuilder;
            break;
          }
          case 138: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomResizeMethod subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomResizeMethod();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomResizeMethod) {
              subBuilder.MergeFrom(RandomResizeMethod);
            }
            input.ReadMessage(subBuilder);
            RandomResizeMethod = subBuilder;
            break;
          }
          case 146: {
            global::Tensorflow.Models.ObjectDetection.Protos.ScaleBoxesToPixelCoordinates subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.ScaleBoxesToPixelCoordinates();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.ScaleBoxesToPixelCoordinates) {
              subBuilder.MergeFrom(ScaleBoxesToPixelCoordinates);
            }
            input.ReadMessage(subBuilder);
            ScaleBoxesToPixelCoordinates = subBuilder;
            break;
          }
          case 154: {
            global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.ResizeImage) {
              subBuilder.MergeFrom(ResizeImage);
            }
            input.ReadMessage(subBuilder);
            ResizeImage = subBuilder;
            break;
          }
          case 162: {
            global::Tensorflow.Models.ObjectDetection.Protos.SubtractChannelMean subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.SubtractChannelMean();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.SubtractChannelMean) {
              subBuilder.MergeFrom(SubtractChannelMean);
            }
            input.ReadMessage(subBuilder);
            SubtractChannelMean = subBuilder;
            break;
          }
          case 170: {
            global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCrop subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCrop();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCrop) {
              subBuilder.MergeFrom(SsdRandomCrop);
            }
            input.ReadMessage(subBuilder);
            SsdRandomCrop = subBuilder;
            break;
          }
          case 178: {
            global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPad subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPad();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPad) {
              subBuilder.MergeFrom(SsdRandomCropPad);
            }
            input.ReadMessage(subBuilder);
            SsdRandomCropPad = subBuilder;
            break;
          }
          case 186: {
            global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatio subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatio();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropFixedAspectRatio) {
              subBuilder.MergeFrom(SsdRandomCropFixedAspectRatio);
            }
            input.ReadMessage(subBuilder);
            SsdRandomCropFixedAspectRatio = subBuilder;
            break;
          }
          case 194: {
            global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatio subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatio();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.SsdRandomCropPadFixedAspectRatio) {
              subBuilder.MergeFrom(SsdRandomCropPadFixedAspectRatio);
            }
            input.ReadMessage(subBuilder);
            SsdRandomCropPadFixedAspectRatio = subBuilder;
            break;
          }
          case 202: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomVerticalFlip subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomVerticalFlip();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomVerticalFlip) {
              subBuilder.MergeFrom(RandomVerticalFlip);
            }
            input.ReadMessage(subBuilder);
            RandomVerticalFlip = subBuilder;
            break;
          }
          case 210: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomRotation90 subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomRotation90();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomRotation90) {
              subBuilder.MergeFrom(RandomRotation90);
            }
            input.ReadMessage(subBuilder);
            RandomRotation90 = subBuilder;
            break;
          }
          case 218: {
            global::Tensorflow.Models.ObjectDetection.Protos.RGBtoGray subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RGBtoGray();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RgbToGray) {
              subBuilder.MergeFrom(RgbToGray);
            }
            input.ReadMessage(subBuilder);
            RgbToGray = subBuilder;
            break;
          }
          case 226: {
            global::Tensorflow.Models.ObjectDetection.Protos.ConvertClassLogitsToSoftmax subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.ConvertClassLogitsToSoftmax();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.ConvertClassLogitsToSoftmax) {
              subBuilder.MergeFrom(ConvertClassLogitsToSoftmax);
            }
            input.ReadMessage(subBuilder);
            ConvertClassLogitsToSoftmax = subBuilder;
            break;
          }
          case 234: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomAbsolutePadImage subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomAbsolutePadImage();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomAbsolutePadImage) {
              subBuilder.MergeFrom(RandomAbsolutePadImage);
            }
            input.ReadMessage(subBuilder);
            RandomAbsolutePadImage = subBuilder;
            break;
          }
          case 242: {
            global::Tensorflow.Models.ObjectDetection.Protos.RandomSelfConcatImage subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RandomSelfConcatImage();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RandomSelfConcatImage) {
              subBuilder.MergeFrom(RandomSelfConcatImage);
            }
            input.ReadMessage(subBuilder);
            RandomSelfConcatImage = subBuilder;
            break;
          }
          case 250: {
            global::Tensorflow.Models.ObjectDetection.Protos.AutoAugmentImage subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.AutoAugmentImage();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.AutoaugmentImage) {
              subBuilder.MergeFrom(AutoaugmentImage);
            }
            input.ReadMessage(subBuilder);
            AutoaugmentImage = subBuilder;
            break;
          }
          case 258: {
            global::Tensorflow.Models.ObjectDetection.Protos.DropLabelProbabilistically subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.DropLabelProbabilistically();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.DropLabelProbabilistically) {
              subBuilder.MergeFrom(DropLabelProbabilistically);
            }
            input.ReadMessage(subBuilder);
            DropLabelProbabilistically = subBuilder;
            break;
          }
          case 266: {
            global::Tensorflow.Models.ObjectDetection.Protos.RemapLabels subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.RemapLabels();
            if (preprocessingStepCase_ == PreprocessingStepOneofCase.RemapLabels) {
              subBuilder.MergeFrom(RemapLabels);
            }
            input.ReadMessage(subBuilder);
            RemapLabels = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Normalizes pixel values in an image.
  /// For every channel in the image, moves the pixel values from the range
  /// [original_minval, original_maxval] to [target_minval, target_maxval].
  /// </summary>
  public sealed partial class NormalizeImage : pb::IMessage<NormalizeImage> {
    private static readonly pb::MessageParser<NormalizeImage> _parser = new pb::MessageParser<NormalizeImage>(() => new NormalizeImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NormalizeImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NormalizeImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NormalizeImage(NormalizeImage other) : this() {
      originalMinval_ = other.originalMinval_;
      originalMaxval_ = other.originalMaxval_;
      targetMinval_ = other.targetMinval_;
      targetMaxval_ = other.targetMaxval_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NormalizeImage Clone() {
      return new NormalizeImage(this);
    }

    /// <summary>Field number for the "original_minval" field.</summary>
    public const int OriginalMinvalFieldNumber = 1;
    private float originalMinval_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OriginalMinval {
      get { return originalMinval_; }
      set {
        originalMinval_ = value;
      }
    }

    /// <summary>Field number for the "original_maxval" field.</summary>
    public const int OriginalMaxvalFieldNumber = 2;
    private float originalMaxval_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OriginalMaxval {
      get { return originalMaxval_; }
      set {
        originalMaxval_ = value;
      }
    }

    /// <summary>Field number for the "target_minval" field.</summary>
    public const int TargetMinvalFieldNumber = 3;
    private float targetMinval_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float TargetMinval {
      get { return targetMinval_; }
      set {
        targetMinval_ = value;
      }
    }

    /// <summary>Field number for the "target_maxval" field.</summary>
    public const int TargetMaxvalFieldNumber = 4;
    private float targetMaxval_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float TargetMaxval {
      get { return targetMaxval_; }
      set {
        targetMaxval_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NormalizeImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NormalizeImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OriginalMinval, other.OriginalMinval)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OriginalMaxval, other.OriginalMaxval)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TargetMinval, other.TargetMinval)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(TargetMaxval, other.TargetMaxval)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (OriginalMinval != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OriginalMinval);
      if (OriginalMaxval != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OriginalMaxval);
      if (TargetMinval != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TargetMinval);
      if (TargetMaxval != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(TargetMaxval);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (OriginalMinval != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(OriginalMinval);
      }
      if (OriginalMaxval != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(OriginalMaxval);
      }
      if (TargetMinval != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(TargetMinval);
      }
      if (TargetMaxval != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(TargetMaxval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (OriginalMinval != 0F) {
        size += 1 + 4;
      }
      if (OriginalMaxval != 0F) {
        size += 1 + 4;
      }
      if (TargetMinval != 0F) {
        size += 1 + 4;
      }
      if (TargetMaxval != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NormalizeImage other) {
      if (other == null) {
        return;
      }
      if (other.OriginalMinval != 0F) {
        OriginalMinval = other.OriginalMinval;
      }
      if (other.OriginalMaxval != 0F) {
        OriginalMaxval = other.OriginalMaxval;
      }
      if (other.TargetMinval != 0F) {
        TargetMinval = other.TargetMinval;
      }
      if (other.TargetMaxval != 0F) {
        TargetMaxval = other.TargetMaxval;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            OriginalMinval = input.ReadFloat();
            break;
          }
          case 21: {
            OriginalMaxval = input.ReadFloat();
            break;
          }
          case 29: {
            TargetMinval = input.ReadFloat();
            break;
          }
          case 37: {
            TargetMaxval = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly horizontally flips the image and detections 50% of the time.
  /// </summary>
  public sealed partial class RandomHorizontalFlip : pb::IMessage<RandomHorizontalFlip> {
    private static readonly pb::MessageParser<RandomHorizontalFlip> _parser = new pb::MessageParser<RandomHorizontalFlip>(() => new RandomHorizontalFlip());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomHorizontalFlip> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomHorizontalFlip() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomHorizontalFlip(RandomHorizontalFlip other) : this() {
      keypointFlipPermutation_ = other.keypointFlipPermutation_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomHorizontalFlip Clone() {
      return new RandomHorizontalFlip(this);
    }

    /// <summary>Field number for the "keypoint_flip_permutation" field.</summary>
    public const int KeypointFlipPermutationFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_keypointFlipPermutation_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> keypointFlipPermutation_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Specifies a mapping from the original keypoint indices to horizontally
    /// flipped indices. This is used in the event that keypoints are specified,
    /// in which case when the image is horizontally flipped the keypoints will
    /// need to be permuted. E.g. for keypoints representing left_eye, right_eye,
    /// nose_tip, mouth, left_ear, right_ear (in that order), one might specify
    /// the keypoint_flip_permutation below:
    /// keypoint_flip_permutation: 1
    /// keypoint_flip_permutation: 0
    /// keypoint_flip_permutation: 2
    /// keypoint_flip_permutation: 3
    /// keypoint_flip_permutation: 5
    /// keypoint_flip_permutation: 4
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> KeypointFlipPermutation {
      get { return keypointFlipPermutation_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomHorizontalFlip);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomHorizontalFlip other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!keypointFlipPermutation_.Equals(other.keypointFlipPermutation_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= keypointFlipPermutation_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      keypointFlipPermutation_.WriteTo(output, _repeated_keypointFlipPermutation_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += keypointFlipPermutation_.CalculateSize(_repeated_keypointFlipPermutation_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomHorizontalFlip other) {
      if (other == null) {
        return;
      }
      keypointFlipPermutation_.Add(other.keypointFlipPermutation_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            keypointFlipPermutation_.AddEntriesFrom(input, _repeated_keypointFlipPermutation_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly vertically flips the image and detections 50% of the time.
  /// </summary>
  public sealed partial class RandomVerticalFlip : pb::IMessage<RandomVerticalFlip> {
    private static readonly pb::MessageParser<RandomVerticalFlip> _parser = new pb::MessageParser<RandomVerticalFlip>(() => new RandomVerticalFlip());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomVerticalFlip> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomVerticalFlip() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomVerticalFlip(RandomVerticalFlip other) : this() {
      keypointFlipPermutation_ = other.keypointFlipPermutation_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomVerticalFlip Clone() {
      return new RandomVerticalFlip(this);
    }

    /// <summary>Field number for the "keypoint_flip_permutation" field.</summary>
    public const int KeypointFlipPermutationFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_keypointFlipPermutation_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> keypointFlipPermutation_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Specifies a mapping from the original keypoint indices to vertically
    /// flipped indices. This is used in the event that keypoints are specified,
    /// in which case when the image is vertically flipped the keypoints will
    /// need to be permuted. E.g. for keypoints representing left_eye, right_eye,
    /// nose_tip, mouth, left_ear, right_ear (in that order), one might specify
    /// the keypoint_flip_permutation below:
    /// keypoint_flip_permutation: 1
    /// keypoint_flip_permutation: 0
    /// keypoint_flip_permutation: 2
    /// keypoint_flip_permutation: 3
    /// keypoint_flip_permutation: 5
    /// keypoint_flip_permutation: 4
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> KeypointFlipPermutation {
      get { return keypointFlipPermutation_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomVerticalFlip);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomVerticalFlip other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!keypointFlipPermutation_.Equals(other.keypointFlipPermutation_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= keypointFlipPermutation_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      keypointFlipPermutation_.WriteTo(output, _repeated_keypointFlipPermutation_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += keypointFlipPermutation_.CalculateSize(_repeated_keypointFlipPermutation_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomVerticalFlip other) {
      if (other == null) {
        return;
      }
      keypointFlipPermutation_.Add(other.keypointFlipPermutation_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            keypointFlipPermutation_.AddEntriesFrom(input, _repeated_keypointFlipPermutation_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly rotates the image and detections by 90 degrees counter-clockwise
  /// 50% of the time.
  /// </summary>
  public sealed partial class RandomRotation90 : pb::IMessage<RandomRotation90> {
    private static readonly pb::MessageParser<RandomRotation90> _parser = new pb::MessageParser<RandomRotation90>(() => new RandomRotation90());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomRotation90> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomRotation90() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomRotation90(RandomRotation90 other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomRotation90 Clone() {
      return new RandomRotation90(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomRotation90);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomRotation90 other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomRotation90 other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Randomly scales the values of all pixels in the image by some constant value
  /// between [minval, maxval], then clip the value to a range between [0, 1.0].
  /// </summary>
  public sealed partial class RandomPixelValueScale : pb::IMessage<RandomPixelValueScale> {
    private static readonly pb::MessageParser<RandomPixelValueScale> _parser = new pb::MessageParser<RandomPixelValueScale>(() => new RandomPixelValueScale());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomPixelValueScale> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomPixelValueScale() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomPixelValueScale(RandomPixelValueScale other) : this() {
      minval_ = other.minval_;
      maxval_ = other.maxval_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomPixelValueScale Clone() {
      return new RandomPixelValueScale(this);
    }

    /// <summary>Field number for the "minval" field.</summary>
    public const int MinvalFieldNumber = 1;
    private float minval_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Minval {
      get { return minval_; }
      set {
        minval_ = value;
      }
    }

    /// <summary>Field number for the "maxval" field.</summary>
    public const int MaxvalFieldNumber = 2;
    private float maxval_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Maxval {
      get { return maxval_; }
      set {
        maxval_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomPixelValueScale);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomPixelValueScale other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Minval, other.Minval)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Maxval, other.Maxval)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Minval != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Minval);
      if (Maxval != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Maxval);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Minval != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Minval);
      }
      if (Maxval != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Maxval);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Minval != 0F) {
        size += 1 + 4;
      }
      if (Maxval != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomPixelValueScale other) {
      if (other == null) {
        return;
      }
      if (other.Minval != 0F) {
        Minval = other.Minval;
      }
      if (other.Maxval != 0F) {
        Maxval = other.Maxval;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Minval = input.ReadFloat();
            break;
          }
          case 21: {
            Maxval = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly enlarges or shrinks image (keeping aspect ratio).
  /// </summary>
  public sealed partial class RandomImageScale : pb::IMessage<RandomImageScale> {
    private static readonly pb::MessageParser<RandomImageScale> _parser = new pb::MessageParser<RandomImageScale>(() => new RandomImageScale());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomImageScale> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomImageScale() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomImageScale(RandomImageScale other) : this() {
      minScaleRatio_ = other.minScaleRatio_;
      maxScaleRatio_ = other.maxScaleRatio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomImageScale Clone() {
      return new RandomImageScale(this);
    }

    /// <summary>Field number for the "min_scale_ratio" field.</summary>
    public const int MinScaleRatioFieldNumber = 1;
    private float minScaleRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinScaleRatio {
      get { return minScaleRatio_; }
      set {
        minScaleRatio_ = value;
      }
    }

    /// <summary>Field number for the "max_scale_ratio" field.</summary>
    public const int MaxScaleRatioFieldNumber = 2;
    private float maxScaleRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxScaleRatio {
      get { return maxScaleRatio_; }
      set {
        maxScaleRatio_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomImageScale);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomImageScale other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinScaleRatio, other.MinScaleRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxScaleRatio, other.MaxScaleRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinScaleRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinScaleRatio);
      if (MaxScaleRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxScaleRatio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinScaleRatio != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinScaleRatio);
      }
      if (MaxScaleRatio != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(MaxScaleRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinScaleRatio != 0F) {
        size += 1 + 4;
      }
      if (MaxScaleRatio != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomImageScale other) {
      if (other == null) {
        return;
      }
      if (other.MinScaleRatio != 0F) {
        MinScaleRatio = other.MinScaleRatio;
      }
      if (other.MaxScaleRatio != 0F) {
        MaxScaleRatio = other.MaxScaleRatio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinScaleRatio = input.ReadFloat();
            break;
          }
          case 21: {
            MaxScaleRatio = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly convert entire image to grey scale.
  /// </summary>
  public sealed partial class RandomRGBtoGray : pb::IMessage<RandomRGBtoGray> {
    private static readonly pb::MessageParser<RandomRGBtoGray> _parser = new pb::MessageParser<RandomRGBtoGray>(() => new RandomRGBtoGray());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomRGBtoGray> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomRGBtoGray() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomRGBtoGray(RandomRGBtoGray other) : this() {
      probability_ = other.probability_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomRGBtoGray Clone() {
      return new RandomRGBtoGray(this);
    }

    /// <summary>Field number for the "probability" field.</summary>
    public const int ProbabilityFieldNumber = 1;
    private float probability_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Probability {
      get { return probability_; }
      set {
        probability_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomRGBtoGray);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomRGBtoGray other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Probability, other.Probability)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Probability != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Probability);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Probability != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Probability);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Probability != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomRGBtoGray other) {
      if (other == null) {
        return;
      }
      if (other.Probability != 0F) {
        Probability = other.Probability;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Probability = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly changes image brightness by up to max_delta. Image outputs will be
  /// saturated between 0 and 1.
  /// </summary>
  public sealed partial class RandomAdjustBrightness : pb::IMessage<RandomAdjustBrightness> {
    private static readonly pb::MessageParser<RandomAdjustBrightness> _parser = new pb::MessageParser<RandomAdjustBrightness>(() => new RandomAdjustBrightness());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomAdjustBrightness> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustBrightness() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustBrightness(RandomAdjustBrightness other) : this() {
      maxDelta_ = other.maxDelta_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustBrightness Clone() {
      return new RandomAdjustBrightness(this);
    }

    /// <summary>Field number for the "max_delta" field.</summary>
    public const int MaxDeltaFieldNumber = 1;
    private float maxDelta_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxDelta {
      get { return maxDelta_; }
      set {
        maxDelta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomAdjustBrightness);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomAdjustBrightness other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxDelta, other.MaxDelta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MaxDelta != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxDelta);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MaxDelta != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MaxDelta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MaxDelta != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomAdjustBrightness other) {
      if (other == null) {
        return;
      }
      if (other.MaxDelta != 0F) {
        MaxDelta = other.MaxDelta;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MaxDelta = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly scales contract by a value between [min_delta, max_delta].
  /// </summary>
  public sealed partial class RandomAdjustContrast : pb::IMessage<RandomAdjustContrast> {
    private static readonly pb::MessageParser<RandomAdjustContrast> _parser = new pb::MessageParser<RandomAdjustContrast>(() => new RandomAdjustContrast());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomAdjustContrast> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustContrast() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustContrast(RandomAdjustContrast other) : this() {
      minDelta_ = other.minDelta_;
      maxDelta_ = other.maxDelta_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustContrast Clone() {
      return new RandomAdjustContrast(this);
    }

    /// <summary>Field number for the "min_delta" field.</summary>
    public const int MinDeltaFieldNumber = 1;
    private float minDelta_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinDelta {
      get { return minDelta_; }
      set {
        minDelta_ = value;
      }
    }

    /// <summary>Field number for the "max_delta" field.</summary>
    public const int MaxDeltaFieldNumber = 2;
    private float maxDelta_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxDelta {
      get { return maxDelta_; }
      set {
        maxDelta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomAdjustContrast);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomAdjustContrast other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinDelta, other.MinDelta)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxDelta, other.MaxDelta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinDelta != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinDelta);
      if (MaxDelta != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxDelta);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinDelta != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinDelta);
      }
      if (MaxDelta != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(MaxDelta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinDelta != 0F) {
        size += 1 + 4;
      }
      if (MaxDelta != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomAdjustContrast other) {
      if (other == null) {
        return;
      }
      if (other.MinDelta != 0F) {
        MinDelta = other.MinDelta;
      }
      if (other.MaxDelta != 0F) {
        MaxDelta = other.MaxDelta;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinDelta = input.ReadFloat();
            break;
          }
          case 21: {
            MaxDelta = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly alters hue by a value of up to max_delta.
  /// </summary>
  public sealed partial class RandomAdjustHue : pb::IMessage<RandomAdjustHue> {
    private static readonly pb::MessageParser<RandomAdjustHue> _parser = new pb::MessageParser<RandomAdjustHue>(() => new RandomAdjustHue());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomAdjustHue> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustHue() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustHue(RandomAdjustHue other) : this() {
      maxDelta_ = other.maxDelta_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustHue Clone() {
      return new RandomAdjustHue(this);
    }

    /// <summary>Field number for the "max_delta" field.</summary>
    public const int MaxDeltaFieldNumber = 1;
    private float maxDelta_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxDelta {
      get { return maxDelta_; }
      set {
        maxDelta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomAdjustHue);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomAdjustHue other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxDelta, other.MaxDelta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MaxDelta != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxDelta);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MaxDelta != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MaxDelta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MaxDelta != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomAdjustHue other) {
      if (other == null) {
        return;
      }
      if (other.MaxDelta != 0F) {
        MaxDelta = other.MaxDelta;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MaxDelta = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly changes saturation by a value between [min_delta, max_delta].
  /// </summary>
  public sealed partial class RandomAdjustSaturation : pb::IMessage<RandomAdjustSaturation> {
    private static readonly pb::MessageParser<RandomAdjustSaturation> _parser = new pb::MessageParser<RandomAdjustSaturation>(() => new RandomAdjustSaturation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomAdjustSaturation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustSaturation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustSaturation(RandomAdjustSaturation other) : this() {
      minDelta_ = other.minDelta_;
      maxDelta_ = other.maxDelta_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAdjustSaturation Clone() {
      return new RandomAdjustSaturation(this);
    }

    /// <summary>Field number for the "min_delta" field.</summary>
    public const int MinDeltaFieldNumber = 1;
    private float minDelta_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinDelta {
      get { return minDelta_; }
      set {
        minDelta_ = value;
      }
    }

    /// <summary>Field number for the "max_delta" field.</summary>
    public const int MaxDeltaFieldNumber = 2;
    private float maxDelta_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxDelta {
      get { return maxDelta_; }
      set {
        maxDelta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomAdjustSaturation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomAdjustSaturation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinDelta, other.MinDelta)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxDelta, other.MaxDelta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinDelta != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinDelta);
      if (MaxDelta != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxDelta);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinDelta != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinDelta);
      }
      if (MaxDelta != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(MaxDelta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinDelta != 0F) {
        size += 1 + 4;
      }
      if (MaxDelta != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomAdjustSaturation other) {
      if (other == null) {
        return;
      }
      if (other.MinDelta != 0F) {
        MinDelta = other.MinDelta;
      }
      if (other.MaxDelta != 0F) {
        MaxDelta = other.MaxDelta;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinDelta = input.ReadFloat();
            break;
          }
          case 21: {
            MaxDelta = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Performs a random color distortion. color_orderings should either be 0 or 1.
  /// </summary>
  public sealed partial class RandomDistortColor : pb::IMessage<RandomDistortColor> {
    private static readonly pb::MessageParser<RandomDistortColor> _parser = new pb::MessageParser<RandomDistortColor>(() => new RandomDistortColor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomDistortColor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomDistortColor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomDistortColor(RandomDistortColor other) : this() {
      colorOrdering_ = other.colorOrdering_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomDistortColor Clone() {
      return new RandomDistortColor(this);
    }

    /// <summary>Field number for the "color_ordering" field.</summary>
    public const int ColorOrderingFieldNumber = 1;
    private int colorOrdering_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ColorOrdering {
      get { return colorOrdering_; }
      set {
        colorOrdering_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomDistortColor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomDistortColor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (ColorOrdering != other.ColorOrdering) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ColorOrdering != 0) hash ^= ColorOrdering.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ColorOrdering != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(ColorOrdering);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ColorOrdering != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ColorOrdering);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomDistortColor other) {
      if (other == null) {
        return;
      }
      if (other.ColorOrdering != 0) {
        ColorOrdering = other.ColorOrdering;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            ColorOrdering = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly jitters corners of boxes in the image determined by ratio.
  /// ie. If a box is [100, 200] and ratio is 0.02, the corners can move by [1, 4].
  /// </summary>
  public sealed partial class RandomJitterBoxes : pb::IMessage<RandomJitterBoxes> {
    private static readonly pb::MessageParser<RandomJitterBoxes> _parser = new pb::MessageParser<RandomJitterBoxes>(() => new RandomJitterBoxes());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomJitterBoxes> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomJitterBoxes() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomJitterBoxes(RandomJitterBoxes other) : this() {
      ratio_ = other.ratio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomJitterBoxes Clone() {
      return new RandomJitterBoxes(this);
    }

    /// <summary>Field number for the "ratio" field.</summary>
    public const int RatioFieldNumber = 1;
    private float ratio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Ratio {
      get { return ratio_; }
      set {
        ratio_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomJitterBoxes);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomJitterBoxes other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Ratio, other.Ratio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Ratio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Ratio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Ratio != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Ratio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Ratio != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomJitterBoxes other) {
      if (other == null) {
        return;
      }
      if (other.Ratio != 0F) {
        Ratio = other.Ratio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Ratio = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly crops the image and bounding boxes.
  /// </summary>
  public sealed partial class RandomCropImage : pb::IMessage<RandomCropImage> {
    private static readonly pb::MessageParser<RandomCropImage> _parser = new pb::MessageParser<RandomCropImage>(() => new RandomCropImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomCropImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[14]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropImage(RandomCropImage other) : this() {
      minObjectCovered_ = other.minObjectCovered_;
      minAspectRatio_ = other.minAspectRatio_;
      maxAspectRatio_ = other.maxAspectRatio_;
      minArea_ = other.minArea_;
      maxArea_ = other.maxArea_;
      overlapThresh_ = other.overlapThresh_;
      clipBoxes_ = other.clipBoxes_;
      randomCoef_ = other.randomCoef_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropImage Clone() {
      return new RandomCropImage(this);
    }

    /// <summary>Field number for the "min_object_covered" field.</summary>
    public const int MinObjectCoveredFieldNumber = 1;
    private float minObjectCovered_;
    /// <summary>
    /// Cropped image must cover at least one box by this fraction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinObjectCovered {
      get { return minObjectCovered_; }
      set {
        minObjectCovered_ = value;
      }
    }

    /// <summary>Field number for the "min_aspect_ratio" field.</summary>
    public const int MinAspectRatioFieldNumber = 2;
    private float minAspectRatio_;
    /// <summary>
    /// Aspect ratio bounds of cropped image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinAspectRatio {
      get { return minAspectRatio_; }
      set {
        minAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "max_aspect_ratio" field.</summary>
    public const int MaxAspectRatioFieldNumber = 3;
    private float maxAspectRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxAspectRatio {
      get { return maxAspectRatio_; }
      set {
        maxAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "min_area" field.</summary>
    public const int MinAreaFieldNumber = 4;
    private float minArea_;
    /// <summary>
    /// Allowed area ratio of cropped image to original image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinArea {
      get { return minArea_; }
      set {
        minArea_ = value;
      }
    }

    /// <summary>Field number for the "max_area" field.</summary>
    public const int MaxAreaFieldNumber = 5;
    private float maxArea_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxArea {
      get { return maxArea_; }
      set {
        maxArea_ = value;
      }
    }

    /// <summary>Field number for the "overlap_thresh" field.</summary>
    public const int OverlapThreshFieldNumber = 6;
    private float overlapThresh_;
    /// <summary>
    /// Minimum overlap threshold of cropped boxes to keep in new image. If the
    /// ratio between a cropped bounding box and the original is less than this
    /// value, it is removed from the new image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OverlapThresh {
      get { return overlapThresh_; }
      set {
        overlapThresh_ = value;
      }
    }

    /// <summary>Field number for the "clip_boxes" field.</summary>
    public const int ClipBoxesFieldNumber = 8;
    private bool clipBoxes_;
    /// <summary>
    /// Whether to clip the boxes to the cropped image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ClipBoxes {
      get { return clipBoxes_; }
      set {
        clipBoxes_ = value;
      }
    }

    /// <summary>Field number for the "random_coef" field.</summary>
    public const int RandomCoefFieldNumber = 7;
    private float randomCoef_;
    /// <summary>
    /// Probability of keeping the original image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomCoef {
      get { return randomCoef_; }
      set {
        randomCoef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomCropImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomCropImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinObjectCovered, other.MinObjectCovered)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinAspectRatio, other.MinAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxAspectRatio, other.MaxAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinArea, other.MinArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxArea, other.MaxArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlapThresh, other.OverlapThresh)) return false;
      if (ClipBoxes != other.ClipBoxes) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RandomCoef, other.RandomCoef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinObjectCovered != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinObjectCovered);
      if (MinAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinAspectRatio);
      if (MaxAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxAspectRatio);
      if (MinArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinArea);
      if (MaxArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxArea);
      if (OverlapThresh != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlapThresh);
      if (ClipBoxes != false) hash ^= ClipBoxes.GetHashCode();
      if (RandomCoef != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RandomCoef);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinObjectCovered != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinObjectCovered);
      }
      if (MinAspectRatio != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(MinAspectRatio);
      }
      if (MaxAspectRatio != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(MaxAspectRatio);
      }
      if (MinArea != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(MinArea);
      }
      if (MaxArea != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(MaxArea);
      }
      if (OverlapThresh != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(OverlapThresh);
      }
      if (RandomCoef != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(RandomCoef);
      }
      if (ClipBoxes != false) {
        output.WriteRawTag(64);
        output.WriteBool(ClipBoxes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinObjectCovered != 0F) {
        size += 1 + 4;
      }
      if (MinAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MaxAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MinArea != 0F) {
        size += 1 + 4;
      }
      if (MaxArea != 0F) {
        size += 1 + 4;
      }
      if (OverlapThresh != 0F) {
        size += 1 + 4;
      }
      if (ClipBoxes != false) {
        size += 1 + 1;
      }
      if (RandomCoef != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomCropImage other) {
      if (other == null) {
        return;
      }
      if (other.MinObjectCovered != 0F) {
        MinObjectCovered = other.MinObjectCovered;
      }
      if (other.MinAspectRatio != 0F) {
        MinAspectRatio = other.MinAspectRatio;
      }
      if (other.MaxAspectRatio != 0F) {
        MaxAspectRatio = other.MaxAspectRatio;
      }
      if (other.MinArea != 0F) {
        MinArea = other.MinArea;
      }
      if (other.MaxArea != 0F) {
        MaxArea = other.MaxArea;
      }
      if (other.OverlapThresh != 0F) {
        OverlapThresh = other.OverlapThresh;
      }
      if (other.ClipBoxes != false) {
        ClipBoxes = other.ClipBoxes;
      }
      if (other.RandomCoef != 0F) {
        RandomCoef = other.RandomCoef;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinObjectCovered = input.ReadFloat();
            break;
          }
          case 21: {
            MinAspectRatio = input.ReadFloat();
            break;
          }
          case 29: {
            MaxAspectRatio = input.ReadFloat();
            break;
          }
          case 37: {
            MinArea = input.ReadFloat();
            break;
          }
          case 45: {
            MaxArea = input.ReadFloat();
            break;
          }
          case 53: {
            OverlapThresh = input.ReadFloat();
            break;
          }
          case 61: {
            RandomCoef = input.ReadFloat();
            break;
          }
          case 64: {
            ClipBoxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly adds padding to the image.
  /// </summary>
  public sealed partial class RandomPadImage : pb::IMessage<RandomPadImage> {
    private static readonly pb::MessageParser<RandomPadImage> _parser = new pb::MessageParser<RandomPadImage>(() => new RandomPadImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomPadImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[15]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomPadImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomPadImage(RandomPadImage other) : this() {
      minImageHeight_ = other.minImageHeight_;
      minImageWidth_ = other.minImageWidth_;
      maxImageHeight_ = other.maxImageHeight_;
      maxImageWidth_ = other.maxImageWidth_;
      padColor_ = other.padColor_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomPadImage Clone() {
      return new RandomPadImage(this);
    }

    /// <summary>Field number for the "min_image_height" field.</summary>
    public const int MinImageHeightFieldNumber = 1;
    private int minImageHeight_;
    /// <summary>
    /// Minimum dimensions for padded image. If unset, will use original image
    /// dimension as a lower bound.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinImageHeight {
      get { return minImageHeight_; }
      set {
        minImageHeight_ = value;
      }
    }

    /// <summary>Field number for the "min_image_width" field.</summary>
    public const int MinImageWidthFieldNumber = 2;
    private int minImageWidth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinImageWidth {
      get { return minImageWidth_; }
      set {
        minImageWidth_ = value;
      }
    }

    /// <summary>Field number for the "max_image_height" field.</summary>
    public const int MaxImageHeightFieldNumber = 3;
    private int maxImageHeight_;
    /// <summary>
    /// Maximum dimensions for padded image. If unset, will use double the original
    /// image dimension as a lower bound.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxImageHeight {
      get { return maxImageHeight_; }
      set {
        maxImageHeight_ = value;
      }
    }

    /// <summary>Field number for the "max_image_width" field.</summary>
    public const int MaxImageWidthFieldNumber = 4;
    private int maxImageWidth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxImageWidth {
      get { return maxImageWidth_; }
      set {
        maxImageWidth_ = value;
      }
    }

    /// <summary>Field number for the "pad_color" field.</summary>
    public const int PadColorFieldNumber = 5;
    private static readonly pb::FieldCodec<float> _repeated_padColor_codec
        = pb::FieldCodec.ForFloat(42);
    private readonly pbc::RepeatedField<float> padColor_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Color of the padding. If unset, will pad using average color of the input
    /// image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> PadColor {
      get { return padColor_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomPadImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomPadImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MinImageHeight != other.MinImageHeight) return false;
      if (MinImageWidth != other.MinImageWidth) return false;
      if (MaxImageHeight != other.MaxImageHeight) return false;
      if (MaxImageWidth != other.MaxImageWidth) return false;
      if(!padColor_.Equals(other.padColor_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinImageHeight != 0) hash ^= MinImageHeight.GetHashCode();
      if (MinImageWidth != 0) hash ^= MinImageWidth.GetHashCode();
      if (MaxImageHeight != 0) hash ^= MaxImageHeight.GetHashCode();
      if (MaxImageWidth != 0) hash ^= MaxImageWidth.GetHashCode();
      hash ^= padColor_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinImageHeight != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(MinImageHeight);
      }
      if (MinImageWidth != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(MinImageWidth);
      }
      if (MaxImageHeight != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(MaxImageHeight);
      }
      if (MaxImageWidth != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(MaxImageWidth);
      }
      padColor_.WriteTo(output, _repeated_padColor_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinImageHeight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinImageHeight);
      }
      if (MinImageWidth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinImageWidth);
      }
      if (MaxImageHeight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxImageHeight);
      }
      if (MaxImageWidth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxImageWidth);
      }
      size += padColor_.CalculateSize(_repeated_padColor_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomPadImage other) {
      if (other == null) {
        return;
      }
      if (other.MinImageHeight != 0) {
        MinImageHeight = other.MinImageHeight;
      }
      if (other.MinImageWidth != 0) {
        MinImageWidth = other.MinImageWidth;
      }
      if (other.MaxImageHeight != 0) {
        MaxImageHeight = other.MaxImageHeight;
      }
      if (other.MaxImageWidth != 0) {
        MaxImageWidth = other.MaxImageWidth;
      }
      padColor_.Add(other.padColor_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MinImageHeight = input.ReadInt32();
            break;
          }
          case 16: {
            MinImageWidth = input.ReadInt32();
            break;
          }
          case 24: {
            MaxImageHeight = input.ReadInt32();
            break;
          }
          case 32: {
            MaxImageWidth = input.ReadInt32();
            break;
          }
          case 42:
          case 45: {
            padColor_.AddEntriesFrom(input, _repeated_padColor_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly adds a padding of size [0, max_height_padding), [0, max_width_padding).
  /// </summary>
  public sealed partial class RandomAbsolutePadImage : pb::IMessage<RandomAbsolutePadImage> {
    private static readonly pb::MessageParser<RandomAbsolutePadImage> _parser = new pb::MessageParser<RandomAbsolutePadImage>(() => new RandomAbsolutePadImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomAbsolutePadImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[16]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAbsolutePadImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAbsolutePadImage(RandomAbsolutePadImage other) : this() {
      maxHeightPadding_ = other.maxHeightPadding_;
      maxWidthPadding_ = other.maxWidthPadding_;
      padColor_ = other.padColor_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomAbsolutePadImage Clone() {
      return new RandomAbsolutePadImage(this);
    }

    /// <summary>Field number for the "max_height_padding" field.</summary>
    public const int MaxHeightPaddingFieldNumber = 1;
    private int maxHeightPadding_;
    /// <summary>
    /// Height will be padded uniformly at random from [0, max_height_padding).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxHeightPadding {
      get { return maxHeightPadding_; }
      set {
        maxHeightPadding_ = value;
      }
    }

    /// <summary>Field number for the "max_width_padding" field.</summary>
    public const int MaxWidthPaddingFieldNumber = 2;
    private int maxWidthPadding_;
    /// <summary>
    /// Width will be padded uniformly at random from [0, max_width_padding).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxWidthPadding {
      get { return maxWidthPadding_; }
      set {
        maxWidthPadding_ = value;
      }
    }

    /// <summary>Field number for the "pad_color" field.</summary>
    public const int PadColorFieldNumber = 3;
    private static readonly pb::FieldCodec<float> _repeated_padColor_codec
        = pb::FieldCodec.ForFloat(26);
    private readonly pbc::RepeatedField<float> padColor_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Color of the padding. If unset, will pad using average color of the input
    /// image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> PadColor {
      get { return padColor_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomAbsolutePadImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomAbsolutePadImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxHeightPadding != other.MaxHeightPadding) return false;
      if (MaxWidthPadding != other.MaxWidthPadding) return false;
      if(!padColor_.Equals(other.padColor_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MaxHeightPadding != 0) hash ^= MaxHeightPadding.GetHashCode();
      if (MaxWidthPadding != 0) hash ^= MaxWidthPadding.GetHashCode();
      hash ^= padColor_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MaxHeightPadding != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(MaxHeightPadding);
      }
      if (MaxWidthPadding != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(MaxWidthPadding);
      }
      padColor_.WriteTo(output, _repeated_padColor_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MaxHeightPadding != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxHeightPadding);
      }
      if (MaxWidthPadding != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxWidthPadding);
      }
      size += padColor_.CalculateSize(_repeated_padColor_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomAbsolutePadImage other) {
      if (other == null) {
        return;
      }
      if (other.MaxHeightPadding != 0) {
        MaxHeightPadding = other.MaxHeightPadding;
      }
      if (other.MaxWidthPadding != 0) {
        MaxWidthPadding = other.MaxWidthPadding;
      }
      padColor_.Add(other.padColor_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxHeightPadding = input.ReadInt32();
            break;
          }
          case 16: {
            MaxWidthPadding = input.ReadInt32();
            break;
          }
          case 26:
          case 29: {
            padColor_.AddEntriesFrom(input, _repeated_padColor_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly crops an image followed by a random pad.
  /// </summary>
  public sealed partial class RandomCropPadImage : pb::IMessage<RandomCropPadImage> {
    private static readonly pb::MessageParser<RandomCropPadImage> _parser = new pb::MessageParser<RandomCropPadImage>(() => new RandomCropPadImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomCropPadImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[17]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropPadImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropPadImage(RandomCropPadImage other) : this() {
      minObjectCovered_ = other.minObjectCovered_;
      minAspectRatio_ = other.minAspectRatio_;
      maxAspectRatio_ = other.maxAspectRatio_;
      minArea_ = other.minArea_;
      maxArea_ = other.maxArea_;
      overlapThresh_ = other.overlapThresh_;
      clipBoxes_ = other.clipBoxes_;
      randomCoef_ = other.randomCoef_;
      minPaddedSizeRatio_ = other.minPaddedSizeRatio_.Clone();
      maxPaddedSizeRatio_ = other.maxPaddedSizeRatio_.Clone();
      padColor_ = other.padColor_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropPadImage Clone() {
      return new RandomCropPadImage(this);
    }

    /// <summary>Field number for the "min_object_covered" field.</summary>
    public const int MinObjectCoveredFieldNumber = 1;
    private float minObjectCovered_;
    /// <summary>
    /// Cropping operation must cover at least one box by this fraction.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinObjectCovered {
      get { return minObjectCovered_; }
      set {
        minObjectCovered_ = value;
      }
    }

    /// <summary>Field number for the "min_aspect_ratio" field.</summary>
    public const int MinAspectRatioFieldNumber = 2;
    private float minAspectRatio_;
    /// <summary>
    /// Aspect ratio bounds of image after cropping operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinAspectRatio {
      get { return minAspectRatio_; }
      set {
        minAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "max_aspect_ratio" field.</summary>
    public const int MaxAspectRatioFieldNumber = 3;
    private float maxAspectRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxAspectRatio {
      get { return maxAspectRatio_; }
      set {
        maxAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "min_area" field.</summary>
    public const int MinAreaFieldNumber = 4;
    private float minArea_;
    /// <summary>
    /// Allowed area ratio of image after cropping operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinArea {
      get { return minArea_; }
      set {
        minArea_ = value;
      }
    }

    /// <summary>Field number for the "max_area" field.</summary>
    public const int MaxAreaFieldNumber = 5;
    private float maxArea_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxArea {
      get { return maxArea_; }
      set {
        maxArea_ = value;
      }
    }

    /// <summary>Field number for the "overlap_thresh" field.</summary>
    public const int OverlapThreshFieldNumber = 6;
    private float overlapThresh_;
    /// <summary>
    /// Minimum overlap threshold of cropped boxes to keep in new image. If the
    /// ratio between a cropped bounding box and the original is less than this
    /// value, it is removed from the new image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OverlapThresh {
      get { return overlapThresh_; }
      set {
        overlapThresh_ = value;
      }
    }

    /// <summary>Field number for the "clip_boxes" field.</summary>
    public const int ClipBoxesFieldNumber = 11;
    private bool clipBoxes_;
    /// <summary>
    /// Whether to clip the boxes to the cropped image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ClipBoxes {
      get { return clipBoxes_; }
      set {
        clipBoxes_ = value;
      }
    }

    /// <summary>Field number for the "random_coef" field.</summary>
    public const int RandomCoefFieldNumber = 7;
    private float randomCoef_;
    /// <summary>
    /// Probability of keeping the original image during the crop operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomCoef {
      get { return randomCoef_; }
      set {
        randomCoef_ = value;
      }
    }

    /// <summary>Field number for the "min_padded_size_ratio" field.</summary>
    public const int MinPaddedSizeRatioFieldNumber = 8;
    private static readonly pb::FieldCodec<float> _repeated_minPaddedSizeRatio_codec
        = pb::FieldCodec.ForFloat(66);
    private readonly pbc::RepeatedField<float> minPaddedSizeRatio_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Maximum dimensions for padded image. If unset, will use double the original
    /// image dimension as a lower bound. Both of the following fields should be
    /// length 2.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> MinPaddedSizeRatio {
      get { return minPaddedSizeRatio_; }
    }

    /// <summary>Field number for the "max_padded_size_ratio" field.</summary>
    public const int MaxPaddedSizeRatioFieldNumber = 9;
    private static readonly pb::FieldCodec<float> _repeated_maxPaddedSizeRatio_codec
        = pb::FieldCodec.ForFloat(74);
    private readonly pbc::RepeatedField<float> maxPaddedSizeRatio_ = new pbc::RepeatedField<float>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> MaxPaddedSizeRatio {
      get { return maxPaddedSizeRatio_; }
    }

    /// <summary>Field number for the "pad_color" field.</summary>
    public const int PadColorFieldNumber = 10;
    private static readonly pb::FieldCodec<float> _repeated_padColor_codec
        = pb::FieldCodec.ForFloat(82);
    private readonly pbc::RepeatedField<float> padColor_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Color of the padding. If unset, will pad using average color of the input
    /// image. This field should be of length 3.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> PadColor {
      get { return padColor_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomCropPadImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomCropPadImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinObjectCovered, other.MinObjectCovered)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinAspectRatio, other.MinAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxAspectRatio, other.MaxAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinArea, other.MinArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxArea, other.MaxArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlapThresh, other.OverlapThresh)) return false;
      if (ClipBoxes != other.ClipBoxes) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RandomCoef, other.RandomCoef)) return false;
      if(!minPaddedSizeRatio_.Equals(other.minPaddedSizeRatio_)) return false;
      if(!maxPaddedSizeRatio_.Equals(other.maxPaddedSizeRatio_)) return false;
      if(!padColor_.Equals(other.padColor_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinObjectCovered != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinObjectCovered);
      if (MinAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinAspectRatio);
      if (MaxAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxAspectRatio);
      if (MinArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinArea);
      if (MaxArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxArea);
      if (OverlapThresh != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlapThresh);
      if (ClipBoxes != false) hash ^= ClipBoxes.GetHashCode();
      if (RandomCoef != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RandomCoef);
      hash ^= minPaddedSizeRatio_.GetHashCode();
      hash ^= maxPaddedSizeRatio_.GetHashCode();
      hash ^= padColor_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinObjectCovered != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinObjectCovered);
      }
      if (MinAspectRatio != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(MinAspectRatio);
      }
      if (MaxAspectRatio != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(MaxAspectRatio);
      }
      if (MinArea != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(MinArea);
      }
      if (MaxArea != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(MaxArea);
      }
      if (OverlapThresh != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(OverlapThresh);
      }
      if (RandomCoef != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(RandomCoef);
      }
      minPaddedSizeRatio_.WriteTo(output, _repeated_minPaddedSizeRatio_codec);
      maxPaddedSizeRatio_.WriteTo(output, _repeated_maxPaddedSizeRatio_codec);
      padColor_.WriteTo(output, _repeated_padColor_codec);
      if (ClipBoxes != false) {
        output.WriteRawTag(88);
        output.WriteBool(ClipBoxes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinObjectCovered != 0F) {
        size += 1 + 4;
      }
      if (MinAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MaxAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MinArea != 0F) {
        size += 1 + 4;
      }
      if (MaxArea != 0F) {
        size += 1 + 4;
      }
      if (OverlapThresh != 0F) {
        size += 1 + 4;
      }
      if (ClipBoxes != false) {
        size += 1 + 1;
      }
      if (RandomCoef != 0F) {
        size += 1 + 4;
      }
      size += minPaddedSizeRatio_.CalculateSize(_repeated_minPaddedSizeRatio_codec);
      size += maxPaddedSizeRatio_.CalculateSize(_repeated_maxPaddedSizeRatio_codec);
      size += padColor_.CalculateSize(_repeated_padColor_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomCropPadImage other) {
      if (other == null) {
        return;
      }
      if (other.MinObjectCovered != 0F) {
        MinObjectCovered = other.MinObjectCovered;
      }
      if (other.MinAspectRatio != 0F) {
        MinAspectRatio = other.MinAspectRatio;
      }
      if (other.MaxAspectRatio != 0F) {
        MaxAspectRatio = other.MaxAspectRatio;
      }
      if (other.MinArea != 0F) {
        MinArea = other.MinArea;
      }
      if (other.MaxArea != 0F) {
        MaxArea = other.MaxArea;
      }
      if (other.OverlapThresh != 0F) {
        OverlapThresh = other.OverlapThresh;
      }
      if (other.ClipBoxes != false) {
        ClipBoxes = other.ClipBoxes;
      }
      if (other.RandomCoef != 0F) {
        RandomCoef = other.RandomCoef;
      }
      minPaddedSizeRatio_.Add(other.minPaddedSizeRatio_);
      maxPaddedSizeRatio_.Add(other.maxPaddedSizeRatio_);
      padColor_.Add(other.padColor_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinObjectCovered = input.ReadFloat();
            break;
          }
          case 21: {
            MinAspectRatio = input.ReadFloat();
            break;
          }
          case 29: {
            MaxAspectRatio = input.ReadFloat();
            break;
          }
          case 37: {
            MinArea = input.ReadFloat();
            break;
          }
          case 45: {
            MaxArea = input.ReadFloat();
            break;
          }
          case 53: {
            OverlapThresh = input.ReadFloat();
            break;
          }
          case 61: {
            RandomCoef = input.ReadFloat();
            break;
          }
          case 66:
          case 69: {
            minPaddedSizeRatio_.AddEntriesFrom(input, _repeated_minPaddedSizeRatio_codec);
            break;
          }
          case 74:
          case 77: {
            maxPaddedSizeRatio_.AddEntriesFrom(input, _repeated_maxPaddedSizeRatio_codec);
            break;
          }
          case 82:
          case 85: {
            padColor_.AddEntriesFrom(input, _repeated_padColor_codec);
            break;
          }
          case 88: {
            ClipBoxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly crops an iamge to a given aspect ratio.
  /// </summary>
  public sealed partial class RandomCropToAspectRatio : pb::IMessage<RandomCropToAspectRatio> {
    private static readonly pb::MessageParser<RandomCropToAspectRatio> _parser = new pb::MessageParser<RandomCropToAspectRatio>(() => new RandomCropToAspectRatio());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomCropToAspectRatio> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[18]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropToAspectRatio() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropToAspectRatio(RandomCropToAspectRatio other) : this() {
      aspectRatio_ = other.aspectRatio_;
      overlapThresh_ = other.overlapThresh_;
      clipBoxes_ = other.clipBoxes_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomCropToAspectRatio Clone() {
      return new RandomCropToAspectRatio(this);
    }

    /// <summary>Field number for the "aspect_ratio" field.</summary>
    public const int AspectRatioFieldNumber = 1;
    private float aspectRatio_;
    /// <summary>
    /// Aspect ratio.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float AspectRatio {
      get { return aspectRatio_; }
      set {
        aspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "overlap_thresh" field.</summary>
    public const int OverlapThreshFieldNumber = 2;
    private float overlapThresh_;
    /// <summary>
    /// Minimum overlap threshold of cropped boxes to keep in new image. If the
    /// ratio between a cropped bounding box and the original is less than this
    /// value, it is removed from the new image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OverlapThresh {
      get { return overlapThresh_; }
      set {
        overlapThresh_ = value;
      }
    }

    /// <summary>Field number for the "clip_boxes" field.</summary>
    public const int ClipBoxesFieldNumber = 3;
    private bool clipBoxes_;
    /// <summary>
    /// Whether to clip the boxes to the cropped image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ClipBoxes {
      get { return clipBoxes_; }
      set {
        clipBoxes_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomCropToAspectRatio);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomCropToAspectRatio other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AspectRatio, other.AspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlapThresh, other.OverlapThresh)) return false;
      if (ClipBoxes != other.ClipBoxes) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AspectRatio);
      if (OverlapThresh != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlapThresh);
      if (ClipBoxes != false) hash ^= ClipBoxes.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AspectRatio != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(AspectRatio);
      }
      if (OverlapThresh != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(OverlapThresh);
      }
      if (ClipBoxes != false) {
        output.WriteRawTag(24);
        output.WriteBool(ClipBoxes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AspectRatio != 0F) {
        size += 1 + 4;
      }
      if (OverlapThresh != 0F) {
        size += 1 + 4;
      }
      if (ClipBoxes != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomCropToAspectRatio other) {
      if (other == null) {
        return;
      }
      if (other.AspectRatio != 0F) {
        AspectRatio = other.AspectRatio;
      }
      if (other.OverlapThresh != 0F) {
        OverlapThresh = other.OverlapThresh;
      }
      if (other.ClipBoxes != false) {
        ClipBoxes = other.ClipBoxes;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            AspectRatio = input.ReadFloat();
            break;
          }
          case 21: {
            OverlapThresh = input.ReadFloat();
            break;
          }
          case 24: {
            ClipBoxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly adds black square patches to an image.
  /// </summary>
  public sealed partial class RandomBlackPatches : pb::IMessage<RandomBlackPatches> {
    private static readonly pb::MessageParser<RandomBlackPatches> _parser = new pb::MessageParser<RandomBlackPatches>(() => new RandomBlackPatches());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomBlackPatches> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[19]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomBlackPatches() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomBlackPatches(RandomBlackPatches other) : this() {
      maxBlackPatches_ = other.maxBlackPatches_;
      probability_ = other.probability_;
      sizeToImageRatio_ = other.sizeToImageRatio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomBlackPatches Clone() {
      return new RandomBlackPatches(this);
    }

    /// <summary>Field number for the "max_black_patches" field.</summary>
    public const int MaxBlackPatchesFieldNumber = 1;
    private int maxBlackPatches_;
    /// <summary>
    /// The maximum number of black patches to add.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxBlackPatches {
      get { return maxBlackPatches_; }
      set {
        maxBlackPatches_ = value;
      }
    }

    /// <summary>Field number for the "probability" field.</summary>
    public const int ProbabilityFieldNumber = 2;
    private float probability_;
    /// <summary>
    /// The probability of a black patch being added to an image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Probability {
      get { return probability_; }
      set {
        probability_ = value;
      }
    }

    /// <summary>Field number for the "size_to_image_ratio" field.</summary>
    public const int SizeToImageRatioFieldNumber = 3;
    private float sizeToImageRatio_;
    /// <summary>
    /// Ratio between the dimension of the black patch to the minimum dimension of
    /// the image (patch_width = patch_height = min(image_height, image_width)).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float SizeToImageRatio {
      get { return sizeToImageRatio_; }
      set {
        sizeToImageRatio_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomBlackPatches);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomBlackPatches other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MaxBlackPatches != other.MaxBlackPatches) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Probability, other.Probability)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SizeToImageRatio, other.SizeToImageRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MaxBlackPatches != 0) hash ^= MaxBlackPatches.GetHashCode();
      if (Probability != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Probability);
      if (SizeToImageRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SizeToImageRatio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MaxBlackPatches != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(MaxBlackPatches);
      }
      if (Probability != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Probability);
      }
      if (SizeToImageRatio != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(SizeToImageRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MaxBlackPatches != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxBlackPatches);
      }
      if (Probability != 0F) {
        size += 1 + 4;
      }
      if (SizeToImageRatio != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomBlackPatches other) {
      if (other == null) {
        return;
      }
      if (other.MaxBlackPatches != 0) {
        MaxBlackPatches = other.MaxBlackPatches;
      }
      if (other.Probability != 0F) {
        Probability = other.Probability;
      }
      if (other.SizeToImageRatio != 0F) {
        SizeToImageRatio = other.SizeToImageRatio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MaxBlackPatches = input.ReadInt32();
            break;
          }
          case 21: {
            Probability = input.ReadFloat();
            break;
          }
          case 29: {
            SizeToImageRatio = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly resizes the image up to [target_height, target_width].
  /// </summary>
  public sealed partial class RandomResizeMethod : pb::IMessage<RandomResizeMethod> {
    private static readonly pb::MessageParser<RandomResizeMethod> _parser = new pb::MessageParser<RandomResizeMethod>(() => new RandomResizeMethod());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomResizeMethod> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[20]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomResizeMethod() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomResizeMethod(RandomResizeMethod other) : this() {
      targetHeight_ = other.targetHeight_;
      targetWidth_ = other.targetWidth_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomResizeMethod Clone() {
      return new RandomResizeMethod(this);
    }

    /// <summary>Field number for the "target_height" field.</summary>
    public const int TargetHeightFieldNumber = 1;
    private int targetHeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int TargetHeight {
      get { return targetHeight_; }
      set {
        targetHeight_ = value;
      }
    }

    /// <summary>Field number for the "target_width" field.</summary>
    public const int TargetWidthFieldNumber = 2;
    private int targetWidth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int TargetWidth {
      get { return targetWidth_; }
      set {
        targetWidth_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomResizeMethod);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomResizeMethod other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (TargetHeight != other.TargetHeight) return false;
      if (TargetWidth != other.TargetWidth) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (TargetHeight != 0) hash ^= TargetHeight.GetHashCode();
      if (TargetWidth != 0) hash ^= TargetWidth.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (TargetHeight != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(TargetHeight);
      }
      if (TargetWidth != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(TargetWidth);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (TargetHeight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TargetHeight);
      }
      if (TargetWidth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(TargetWidth);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomResizeMethod other) {
      if (other == null) {
        return;
      }
      if (other.TargetHeight != 0) {
        TargetHeight = other.TargetHeight;
      }
      if (other.TargetWidth != 0) {
        TargetWidth = other.TargetWidth;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            TargetHeight = input.ReadInt32();
            break;
          }
          case 16: {
            TargetWidth = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Converts the RGB image to a grayscale image. This also converts the image
  /// depth from 3 to 1, unlike RandomRGBtoGray which does not change the image
  /// depth.
  /// </summary>
  public sealed partial class RGBtoGray : pb::IMessage<RGBtoGray> {
    private static readonly pb::MessageParser<RGBtoGray> _parser = new pb::MessageParser<RGBtoGray>(() => new RGBtoGray());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RGBtoGray> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[21]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RGBtoGray() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RGBtoGray(RGBtoGray other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RGBtoGray Clone() {
      return new RGBtoGray(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RGBtoGray);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RGBtoGray other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RGBtoGray other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Scales boxes from normalized coordinates to pixel coordinates.
  /// </summary>
  public sealed partial class ScaleBoxesToPixelCoordinates : pb::IMessage<ScaleBoxesToPixelCoordinates> {
    private static readonly pb::MessageParser<ScaleBoxesToPixelCoordinates> _parser = new pb::MessageParser<ScaleBoxesToPixelCoordinates>(() => new ScaleBoxesToPixelCoordinates());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ScaleBoxesToPixelCoordinates> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[22]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScaleBoxesToPixelCoordinates() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScaleBoxesToPixelCoordinates(ScaleBoxesToPixelCoordinates other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ScaleBoxesToPixelCoordinates Clone() {
      return new ScaleBoxesToPixelCoordinates(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ScaleBoxesToPixelCoordinates);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ScaleBoxesToPixelCoordinates other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ScaleBoxesToPixelCoordinates other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Resizes images to [new_height, new_width].
  /// </summary>
  public sealed partial class ResizeImage : pb::IMessage<ResizeImage> {
    private static readonly pb::MessageParser<ResizeImage> _parser = new pb::MessageParser<ResizeImage>(() => new ResizeImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ResizeImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[23]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResizeImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResizeImage(ResizeImage other) : this() {
      newHeight_ = other.newHeight_;
      newWidth_ = other.newWidth_;
      method_ = other.method_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ResizeImage Clone() {
      return new ResizeImage(this);
    }

    /// <summary>Field number for the "new_height" field.</summary>
    public const int NewHeightFieldNumber = 1;
    private int newHeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NewHeight {
      get { return newHeight_; }
      set {
        newHeight_ = value;
      }
    }

    /// <summary>Field number for the "new_width" field.</summary>
    public const int NewWidthFieldNumber = 2;
    private int newWidth_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NewWidth {
      get { return newWidth_; }
      set {
        newWidth_ = value;
      }
    }

    /// <summary>Field number for the "method" field.</summary>
    public const int MethodFieldNumber = 3;
    private global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage.Types.Method method_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage.Types.Method Method {
      get { return method_; }
      set {
        method_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ResizeImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ResizeImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NewHeight != other.NewHeight) return false;
      if (NewWidth != other.NewWidth) return false;
      if (Method != other.Method) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NewHeight != 0) hash ^= NewHeight.GetHashCode();
      if (NewWidth != 0) hash ^= NewWidth.GetHashCode();
      if (Method != 0) hash ^= Method.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (NewHeight != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(NewHeight);
      }
      if (NewWidth != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NewWidth);
      }
      if (Method != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) Method);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NewHeight != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NewHeight);
      }
      if (NewWidth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NewWidth);
      }
      if (Method != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) Method);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ResizeImage other) {
      if (other == null) {
        return;
      }
      if (other.NewHeight != 0) {
        NewHeight = other.NewHeight;
      }
      if (other.NewWidth != 0) {
        NewWidth = other.NewWidth;
      }
      if (other.Method != 0) {
        Method = other.Method;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NewHeight = input.ReadInt32();
            break;
          }
          case 16: {
            NewWidth = input.ReadInt32();
            break;
          }
          case 24: {
            method_ = (global::Tensorflow.Models.ObjectDetection.Protos.ResizeImage.Types.Method) input.ReadEnum();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ResizeImage message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum Method {
        [pbr::OriginalName("NONE")] None = 0,
        [pbr::OriginalName("AREA")] Area = 1,
        [pbr::OriginalName("BICUBIC")] Bicubic = 2,
        [pbr::OriginalName("BILINEAR")] Bilinear = 3,
        [pbr::OriginalName("NEAREST_NEIGHBOR")] NearestNeighbor = 4,
      }

    }
    #endregion

  }

  /// <summary>
  /// Normalizes an image by subtracting a mean from each channel.
  /// </summary>
  public sealed partial class SubtractChannelMean : pb::IMessage<SubtractChannelMean> {
    private static readonly pb::MessageParser<SubtractChannelMean> _parser = new pb::MessageParser<SubtractChannelMean>(() => new SubtractChannelMean());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SubtractChannelMean> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[24]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubtractChannelMean() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubtractChannelMean(SubtractChannelMean other) : this() {
      means_ = other.means_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SubtractChannelMean Clone() {
      return new SubtractChannelMean(this);
    }

    /// <summary>Field number for the "means" field.</summary>
    public const int MeansFieldNumber = 1;
    private static readonly pb::FieldCodec<float> _repeated_means_codec
        = pb::FieldCodec.ForFloat(10);
    private readonly pbc::RepeatedField<float> means_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// The mean to subtract from each channel. Should be of same dimension of
    /// channels in the input image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> Means {
      get { return means_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SubtractChannelMean);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SubtractChannelMean other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!means_.Equals(other.means_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= means_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      means_.WriteTo(output, _repeated_means_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += means_.CalculateSize(_repeated_means_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SubtractChannelMean other) {
      if (other == null) {
        return;
      }
      means_.Add(other.means_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 13: {
            means_.AddEntriesFrom(input, _repeated_means_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class SSDRandomCropOperation : pb::IMessage<SSDRandomCropOperation> {
    private static readonly pb::MessageParser<SSDRandomCropOperation> _parser = new pb::MessageParser<SSDRandomCropOperation>(() => new SSDRandomCropOperation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SSDRandomCropOperation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[25]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropOperation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropOperation(SSDRandomCropOperation other) : this() {
      minObjectCovered_ = other.minObjectCovered_;
      minAspectRatio_ = other.minAspectRatio_;
      maxAspectRatio_ = other.maxAspectRatio_;
      minArea_ = other.minArea_;
      maxArea_ = other.maxArea_;
      overlapThresh_ = other.overlapThresh_;
      clipBoxes_ = other.clipBoxes_;
      randomCoef_ = other.randomCoef_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropOperation Clone() {
      return new SSDRandomCropOperation(this);
    }

    /// <summary>Field number for the "min_object_covered" field.</summary>
    public const int MinObjectCoveredFieldNumber = 1;
    private float minObjectCovered_;
    /// <summary>
    /// Cropped image must cover at least this fraction of one original bounding
    /// box.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinObjectCovered {
      get { return minObjectCovered_; }
      set {
        minObjectCovered_ = value;
      }
    }

    /// <summary>Field number for the "min_aspect_ratio" field.</summary>
    public const int MinAspectRatioFieldNumber = 2;
    private float minAspectRatio_;
    /// <summary>
    /// The aspect ratio of the cropped image must be within the range of
    /// [min_aspect_ratio, max_aspect_ratio].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinAspectRatio {
      get { return minAspectRatio_; }
      set {
        minAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "max_aspect_ratio" field.</summary>
    public const int MaxAspectRatioFieldNumber = 3;
    private float maxAspectRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxAspectRatio {
      get { return maxAspectRatio_; }
      set {
        maxAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "min_area" field.</summary>
    public const int MinAreaFieldNumber = 4;
    private float minArea_;
    /// <summary>
    /// The area of the cropped image must be within the range of
    /// [min_area, max_area].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinArea {
      get { return minArea_; }
      set {
        minArea_ = value;
      }
    }

    /// <summary>Field number for the "max_area" field.</summary>
    public const int MaxAreaFieldNumber = 5;
    private float maxArea_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxArea {
      get { return maxArea_; }
      set {
        maxArea_ = value;
      }
    }

    /// <summary>Field number for the "overlap_thresh" field.</summary>
    public const int OverlapThreshFieldNumber = 6;
    private float overlapThresh_;
    /// <summary>
    /// Cropped box area ratio must be above this threhold to be kept.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OverlapThresh {
      get { return overlapThresh_; }
      set {
        overlapThresh_ = value;
      }
    }

    /// <summary>Field number for the "clip_boxes" field.</summary>
    public const int ClipBoxesFieldNumber = 8;
    private bool clipBoxes_;
    /// <summary>
    /// Whether to clip the boxes to the cropped image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ClipBoxes {
      get { return clipBoxes_; }
      set {
        clipBoxes_ = value;
      }
    }

    /// <summary>Field number for the "random_coef" field.</summary>
    public const int RandomCoefFieldNumber = 7;
    private float randomCoef_;
    /// <summary>
    /// Probability a crop operation is skipped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomCoef {
      get { return randomCoef_; }
      set {
        randomCoef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SSDRandomCropOperation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SSDRandomCropOperation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinObjectCovered, other.MinObjectCovered)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinAspectRatio, other.MinAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxAspectRatio, other.MaxAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinArea, other.MinArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxArea, other.MaxArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlapThresh, other.OverlapThresh)) return false;
      if (ClipBoxes != other.ClipBoxes) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RandomCoef, other.RandomCoef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinObjectCovered != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinObjectCovered);
      if (MinAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinAspectRatio);
      if (MaxAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxAspectRatio);
      if (MinArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinArea);
      if (MaxArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxArea);
      if (OverlapThresh != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlapThresh);
      if (ClipBoxes != false) hash ^= ClipBoxes.GetHashCode();
      if (RandomCoef != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RandomCoef);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinObjectCovered != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinObjectCovered);
      }
      if (MinAspectRatio != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(MinAspectRatio);
      }
      if (MaxAspectRatio != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(MaxAspectRatio);
      }
      if (MinArea != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(MinArea);
      }
      if (MaxArea != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(MaxArea);
      }
      if (OverlapThresh != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(OverlapThresh);
      }
      if (RandomCoef != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(RandomCoef);
      }
      if (ClipBoxes != false) {
        output.WriteRawTag(64);
        output.WriteBool(ClipBoxes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinObjectCovered != 0F) {
        size += 1 + 4;
      }
      if (MinAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MaxAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MinArea != 0F) {
        size += 1 + 4;
      }
      if (MaxArea != 0F) {
        size += 1 + 4;
      }
      if (OverlapThresh != 0F) {
        size += 1 + 4;
      }
      if (ClipBoxes != false) {
        size += 1 + 1;
      }
      if (RandomCoef != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SSDRandomCropOperation other) {
      if (other == null) {
        return;
      }
      if (other.MinObjectCovered != 0F) {
        MinObjectCovered = other.MinObjectCovered;
      }
      if (other.MinAspectRatio != 0F) {
        MinAspectRatio = other.MinAspectRatio;
      }
      if (other.MaxAspectRatio != 0F) {
        MaxAspectRatio = other.MaxAspectRatio;
      }
      if (other.MinArea != 0F) {
        MinArea = other.MinArea;
      }
      if (other.MaxArea != 0F) {
        MaxArea = other.MaxArea;
      }
      if (other.OverlapThresh != 0F) {
        OverlapThresh = other.OverlapThresh;
      }
      if (other.ClipBoxes != false) {
        ClipBoxes = other.ClipBoxes;
      }
      if (other.RandomCoef != 0F) {
        RandomCoef = other.RandomCoef;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinObjectCovered = input.ReadFloat();
            break;
          }
          case 21: {
            MinAspectRatio = input.ReadFloat();
            break;
          }
          case 29: {
            MaxAspectRatio = input.ReadFloat();
            break;
          }
          case 37: {
            MinArea = input.ReadFloat();
            break;
          }
          case 45: {
            MaxArea = input.ReadFloat();
            break;
          }
          case 53: {
            OverlapThresh = input.ReadFloat();
            break;
          }
          case 61: {
            RandomCoef = input.ReadFloat();
            break;
          }
          case 64: {
            ClipBoxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly crops a image according to:
  ///     Liu et al., SSD: Single shot multibox detector.
  /// This preprocessing step defines multiple SSDRandomCropOperations. Only one
  /// operation (chosen at random) is actually performed on an image.
  /// </summary>
  public sealed partial class SSDRandomCrop : pb::IMessage<SSDRandomCrop> {
    private static readonly pb::MessageParser<SSDRandomCrop> _parser = new pb::MessageParser<SSDRandomCrop>(() => new SSDRandomCrop());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SSDRandomCrop> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[26]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCrop() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCrop(SSDRandomCrop other) : this() {
      operations_ = other.operations_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCrop Clone() {
      return new SSDRandomCrop(this);
    }

    /// <summary>Field number for the "operations" field.</summary>
    public const int OperationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropOperation> _repeated_operations_codec
        = pb::FieldCodec.ForMessage(10, global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropOperation.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropOperation> operations_ = new pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropOperation>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropOperation> Operations {
      get { return operations_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SSDRandomCrop);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SSDRandomCrop other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!operations_.Equals(other.operations_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= operations_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      operations_.WriteTo(output, _repeated_operations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += operations_.CalculateSize(_repeated_operations_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SSDRandomCrop other) {
      if (other == null) {
        return;
      }
      operations_.Add(other.operations_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            operations_.AddEntriesFrom(input, _repeated_operations_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class SSDRandomCropPadOperation : pb::IMessage<SSDRandomCropPadOperation> {
    private static readonly pb::MessageParser<SSDRandomCropPadOperation> _parser = new pb::MessageParser<SSDRandomCropPadOperation>(() => new SSDRandomCropPadOperation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SSDRandomCropPadOperation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[27]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadOperation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadOperation(SSDRandomCropPadOperation other) : this() {
      minObjectCovered_ = other.minObjectCovered_;
      minAspectRatio_ = other.minAspectRatio_;
      maxAspectRatio_ = other.maxAspectRatio_;
      minArea_ = other.minArea_;
      maxArea_ = other.maxArea_;
      overlapThresh_ = other.overlapThresh_;
      clipBoxes_ = other.clipBoxes_;
      randomCoef_ = other.randomCoef_;
      minPaddedSizeRatio_ = other.minPaddedSizeRatio_.Clone();
      maxPaddedSizeRatio_ = other.maxPaddedSizeRatio_.Clone();
      padColorR_ = other.padColorR_;
      padColorG_ = other.padColorG_;
      padColorB_ = other.padColorB_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadOperation Clone() {
      return new SSDRandomCropPadOperation(this);
    }

    /// <summary>Field number for the "min_object_covered" field.</summary>
    public const int MinObjectCoveredFieldNumber = 1;
    private float minObjectCovered_;
    /// <summary>
    /// Cropped image must cover at least this fraction of one original bounding
    /// box.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinObjectCovered {
      get { return minObjectCovered_; }
      set {
        minObjectCovered_ = value;
      }
    }

    /// <summary>Field number for the "min_aspect_ratio" field.</summary>
    public const int MinAspectRatioFieldNumber = 2;
    private float minAspectRatio_;
    /// <summary>
    /// The aspect ratio of the cropped image must be within the range of
    /// [min_aspect_ratio, max_aspect_ratio].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinAspectRatio {
      get { return minAspectRatio_; }
      set {
        minAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "max_aspect_ratio" field.</summary>
    public const int MaxAspectRatioFieldNumber = 3;
    private float maxAspectRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxAspectRatio {
      get { return maxAspectRatio_; }
      set {
        maxAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "min_area" field.</summary>
    public const int MinAreaFieldNumber = 4;
    private float minArea_;
    /// <summary>
    /// The area of the cropped image must be within the range of
    /// [min_area, max_area].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinArea {
      get { return minArea_; }
      set {
        minArea_ = value;
      }
    }

    /// <summary>Field number for the "max_area" field.</summary>
    public const int MaxAreaFieldNumber = 5;
    private float maxArea_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxArea {
      get { return maxArea_; }
      set {
        maxArea_ = value;
      }
    }

    /// <summary>Field number for the "overlap_thresh" field.</summary>
    public const int OverlapThreshFieldNumber = 6;
    private float overlapThresh_;
    /// <summary>
    /// Cropped box area ratio must be above this threhold to be kept.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OverlapThresh {
      get { return overlapThresh_; }
      set {
        overlapThresh_ = value;
      }
    }

    /// <summary>Field number for the "clip_boxes" field.</summary>
    public const int ClipBoxesFieldNumber = 13;
    private bool clipBoxes_;
    /// <summary>
    /// Whether to clip the boxes to the cropped image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ClipBoxes {
      get { return clipBoxes_; }
      set {
        clipBoxes_ = value;
      }
    }

    /// <summary>Field number for the "random_coef" field.</summary>
    public const int RandomCoefFieldNumber = 7;
    private float randomCoef_;
    /// <summary>
    /// Probability a crop operation is skipped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomCoef {
      get { return randomCoef_; }
      set {
        randomCoef_ = value;
      }
    }

    /// <summary>Field number for the "min_padded_size_ratio" field.</summary>
    public const int MinPaddedSizeRatioFieldNumber = 8;
    private static readonly pb::FieldCodec<float> _repeated_minPaddedSizeRatio_codec
        = pb::FieldCodec.ForFloat(66);
    private readonly pbc::RepeatedField<float> minPaddedSizeRatio_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Min ratio of padded image height and width to the input image's height and
    /// width. Two entries per operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> MinPaddedSizeRatio {
      get { return minPaddedSizeRatio_; }
    }

    /// <summary>Field number for the "max_padded_size_ratio" field.</summary>
    public const int MaxPaddedSizeRatioFieldNumber = 9;
    private static readonly pb::FieldCodec<float> _repeated_maxPaddedSizeRatio_codec
        = pb::FieldCodec.ForFloat(74);
    private readonly pbc::RepeatedField<float> maxPaddedSizeRatio_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Max ratio of padded image height and width to the input image's height and
    /// width. Two entries per operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> MaxPaddedSizeRatio {
      get { return maxPaddedSizeRatio_; }
    }

    /// <summary>Field number for the "pad_color_r" field.</summary>
    public const int PadColorRFieldNumber = 10;
    private float padColorR_;
    /// <summary>
    /// Padding color.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PadColorR {
      get { return padColorR_; }
      set {
        padColorR_ = value;
      }
    }

    /// <summary>Field number for the "pad_color_g" field.</summary>
    public const int PadColorGFieldNumber = 11;
    private float padColorG_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PadColorG {
      get { return padColorG_; }
      set {
        padColorG_ = value;
      }
    }

    /// <summary>Field number for the "pad_color_b" field.</summary>
    public const int PadColorBFieldNumber = 12;
    private float padColorB_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PadColorB {
      get { return padColorB_; }
      set {
        padColorB_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SSDRandomCropPadOperation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SSDRandomCropPadOperation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinObjectCovered, other.MinObjectCovered)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinAspectRatio, other.MinAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxAspectRatio, other.MaxAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinArea, other.MinArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxArea, other.MaxArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlapThresh, other.OverlapThresh)) return false;
      if (ClipBoxes != other.ClipBoxes) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RandomCoef, other.RandomCoef)) return false;
      if(!minPaddedSizeRatio_.Equals(other.minPaddedSizeRatio_)) return false;
      if(!maxPaddedSizeRatio_.Equals(other.maxPaddedSizeRatio_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PadColorR, other.PadColorR)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PadColorG, other.PadColorG)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PadColorB, other.PadColorB)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinObjectCovered != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinObjectCovered);
      if (MinAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinAspectRatio);
      if (MaxAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxAspectRatio);
      if (MinArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinArea);
      if (MaxArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxArea);
      if (OverlapThresh != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlapThresh);
      if (ClipBoxes != false) hash ^= ClipBoxes.GetHashCode();
      if (RandomCoef != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RandomCoef);
      hash ^= minPaddedSizeRatio_.GetHashCode();
      hash ^= maxPaddedSizeRatio_.GetHashCode();
      if (PadColorR != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PadColorR);
      if (PadColorG != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PadColorG);
      if (PadColorB != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PadColorB);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinObjectCovered != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinObjectCovered);
      }
      if (MinAspectRatio != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(MinAspectRatio);
      }
      if (MaxAspectRatio != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(MaxAspectRatio);
      }
      if (MinArea != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(MinArea);
      }
      if (MaxArea != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(MaxArea);
      }
      if (OverlapThresh != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(OverlapThresh);
      }
      if (RandomCoef != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(RandomCoef);
      }
      minPaddedSizeRatio_.WriteTo(output, _repeated_minPaddedSizeRatio_codec);
      maxPaddedSizeRatio_.WriteTo(output, _repeated_maxPaddedSizeRatio_codec);
      if (PadColorR != 0F) {
        output.WriteRawTag(85);
        output.WriteFloat(PadColorR);
      }
      if (PadColorG != 0F) {
        output.WriteRawTag(93);
        output.WriteFloat(PadColorG);
      }
      if (PadColorB != 0F) {
        output.WriteRawTag(101);
        output.WriteFloat(PadColorB);
      }
      if (ClipBoxes != false) {
        output.WriteRawTag(104);
        output.WriteBool(ClipBoxes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinObjectCovered != 0F) {
        size += 1 + 4;
      }
      if (MinAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MaxAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MinArea != 0F) {
        size += 1 + 4;
      }
      if (MaxArea != 0F) {
        size += 1 + 4;
      }
      if (OverlapThresh != 0F) {
        size += 1 + 4;
      }
      if (ClipBoxes != false) {
        size += 1 + 1;
      }
      if (RandomCoef != 0F) {
        size += 1 + 4;
      }
      size += minPaddedSizeRatio_.CalculateSize(_repeated_minPaddedSizeRatio_codec);
      size += maxPaddedSizeRatio_.CalculateSize(_repeated_maxPaddedSizeRatio_codec);
      if (PadColorR != 0F) {
        size += 1 + 4;
      }
      if (PadColorG != 0F) {
        size += 1 + 4;
      }
      if (PadColorB != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SSDRandomCropPadOperation other) {
      if (other == null) {
        return;
      }
      if (other.MinObjectCovered != 0F) {
        MinObjectCovered = other.MinObjectCovered;
      }
      if (other.MinAspectRatio != 0F) {
        MinAspectRatio = other.MinAspectRatio;
      }
      if (other.MaxAspectRatio != 0F) {
        MaxAspectRatio = other.MaxAspectRatio;
      }
      if (other.MinArea != 0F) {
        MinArea = other.MinArea;
      }
      if (other.MaxArea != 0F) {
        MaxArea = other.MaxArea;
      }
      if (other.OverlapThresh != 0F) {
        OverlapThresh = other.OverlapThresh;
      }
      if (other.ClipBoxes != false) {
        ClipBoxes = other.ClipBoxes;
      }
      if (other.RandomCoef != 0F) {
        RandomCoef = other.RandomCoef;
      }
      minPaddedSizeRatio_.Add(other.minPaddedSizeRatio_);
      maxPaddedSizeRatio_.Add(other.maxPaddedSizeRatio_);
      if (other.PadColorR != 0F) {
        PadColorR = other.PadColorR;
      }
      if (other.PadColorG != 0F) {
        PadColorG = other.PadColorG;
      }
      if (other.PadColorB != 0F) {
        PadColorB = other.PadColorB;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinObjectCovered = input.ReadFloat();
            break;
          }
          case 21: {
            MinAspectRatio = input.ReadFloat();
            break;
          }
          case 29: {
            MaxAspectRatio = input.ReadFloat();
            break;
          }
          case 37: {
            MinArea = input.ReadFloat();
            break;
          }
          case 45: {
            MaxArea = input.ReadFloat();
            break;
          }
          case 53: {
            OverlapThresh = input.ReadFloat();
            break;
          }
          case 61: {
            RandomCoef = input.ReadFloat();
            break;
          }
          case 66:
          case 69: {
            minPaddedSizeRatio_.AddEntriesFrom(input, _repeated_minPaddedSizeRatio_codec);
            break;
          }
          case 74:
          case 77: {
            maxPaddedSizeRatio_.AddEntriesFrom(input, _repeated_maxPaddedSizeRatio_codec);
            break;
          }
          case 85: {
            PadColorR = input.ReadFloat();
            break;
          }
          case 93: {
            PadColorG = input.ReadFloat();
            break;
          }
          case 101: {
            PadColorB = input.ReadFloat();
            break;
          }
          case 104: {
            ClipBoxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly crops and pads an image according to:
  ///     Liu et al., SSD: Single shot multibox detector.
  /// This preprocessing step defines multiple SSDRandomCropPadOperations. Only one
  /// operation (chosen at random) is actually performed on an image.
  /// </summary>
  public sealed partial class SSDRandomCropPad : pb::IMessage<SSDRandomCropPad> {
    private static readonly pb::MessageParser<SSDRandomCropPad> _parser = new pb::MessageParser<SSDRandomCropPad>(() => new SSDRandomCropPad());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SSDRandomCropPad> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[28]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPad() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPad(SSDRandomCropPad other) : this() {
      operations_ = other.operations_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPad Clone() {
      return new SSDRandomCropPad(this);
    }

    /// <summary>Field number for the "operations" field.</summary>
    public const int OperationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadOperation> _repeated_operations_codec
        = pb::FieldCodec.ForMessage(10, global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadOperation.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadOperation> operations_ = new pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadOperation>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadOperation> Operations {
      get { return operations_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SSDRandomCropPad);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SSDRandomCropPad other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!operations_.Equals(other.operations_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= operations_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      operations_.WriteTo(output, _repeated_operations_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += operations_.CalculateSize(_repeated_operations_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SSDRandomCropPad other) {
      if (other == null) {
        return;
      }
      operations_.Add(other.operations_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            operations_.AddEntriesFrom(input, _repeated_operations_codec);
            break;
          }
        }
      }
    }

  }

  public sealed partial class SSDRandomCropFixedAspectRatioOperation : pb::IMessage<SSDRandomCropFixedAspectRatioOperation> {
    private static readonly pb::MessageParser<SSDRandomCropFixedAspectRatioOperation> _parser = new pb::MessageParser<SSDRandomCropFixedAspectRatioOperation>(() => new SSDRandomCropFixedAspectRatioOperation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SSDRandomCropFixedAspectRatioOperation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[29]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropFixedAspectRatioOperation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropFixedAspectRatioOperation(SSDRandomCropFixedAspectRatioOperation other) : this() {
      minObjectCovered_ = other.minObjectCovered_;
      minArea_ = other.minArea_;
      maxArea_ = other.maxArea_;
      overlapThresh_ = other.overlapThresh_;
      clipBoxes_ = other.clipBoxes_;
      randomCoef_ = other.randomCoef_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropFixedAspectRatioOperation Clone() {
      return new SSDRandomCropFixedAspectRatioOperation(this);
    }

    /// <summary>Field number for the "min_object_covered" field.</summary>
    public const int MinObjectCoveredFieldNumber = 1;
    private float minObjectCovered_;
    /// <summary>
    /// Cropped image must cover at least this fraction of one original bounding
    /// box.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinObjectCovered {
      get { return minObjectCovered_; }
      set {
        minObjectCovered_ = value;
      }
    }

    /// <summary>Field number for the "min_area" field.</summary>
    public const int MinAreaFieldNumber = 4;
    private float minArea_;
    /// <summary>
    /// The area of the cropped image must be within the range of
    /// [min_area, max_area].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinArea {
      get { return minArea_; }
      set {
        minArea_ = value;
      }
    }

    /// <summary>Field number for the "max_area" field.</summary>
    public const int MaxAreaFieldNumber = 5;
    private float maxArea_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxArea {
      get { return maxArea_; }
      set {
        maxArea_ = value;
      }
    }

    /// <summary>Field number for the "overlap_thresh" field.</summary>
    public const int OverlapThreshFieldNumber = 6;
    private float overlapThresh_;
    /// <summary>
    /// Cropped box area ratio must be above this threhold to be kept.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OverlapThresh {
      get { return overlapThresh_; }
      set {
        overlapThresh_ = value;
      }
    }

    /// <summary>Field number for the "clip_boxes" field.</summary>
    public const int ClipBoxesFieldNumber = 8;
    private bool clipBoxes_;
    /// <summary>
    /// Whether to clip the boxes to the cropped image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ClipBoxes {
      get { return clipBoxes_; }
      set {
        clipBoxes_ = value;
      }
    }

    /// <summary>Field number for the "random_coef" field.</summary>
    public const int RandomCoefFieldNumber = 7;
    private float randomCoef_;
    /// <summary>
    /// Probability a crop operation is skipped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomCoef {
      get { return randomCoef_; }
      set {
        randomCoef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SSDRandomCropFixedAspectRatioOperation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SSDRandomCropFixedAspectRatioOperation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinObjectCovered, other.MinObjectCovered)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinArea, other.MinArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxArea, other.MaxArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlapThresh, other.OverlapThresh)) return false;
      if (ClipBoxes != other.ClipBoxes) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RandomCoef, other.RandomCoef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinObjectCovered != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinObjectCovered);
      if (MinArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinArea);
      if (MaxArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxArea);
      if (OverlapThresh != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlapThresh);
      if (ClipBoxes != false) hash ^= ClipBoxes.GetHashCode();
      if (RandomCoef != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RandomCoef);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinObjectCovered != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinObjectCovered);
      }
      if (MinArea != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(MinArea);
      }
      if (MaxArea != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(MaxArea);
      }
      if (OverlapThresh != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(OverlapThresh);
      }
      if (RandomCoef != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(RandomCoef);
      }
      if (ClipBoxes != false) {
        output.WriteRawTag(64);
        output.WriteBool(ClipBoxes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinObjectCovered != 0F) {
        size += 1 + 4;
      }
      if (MinArea != 0F) {
        size += 1 + 4;
      }
      if (MaxArea != 0F) {
        size += 1 + 4;
      }
      if (OverlapThresh != 0F) {
        size += 1 + 4;
      }
      if (ClipBoxes != false) {
        size += 1 + 1;
      }
      if (RandomCoef != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SSDRandomCropFixedAspectRatioOperation other) {
      if (other == null) {
        return;
      }
      if (other.MinObjectCovered != 0F) {
        MinObjectCovered = other.MinObjectCovered;
      }
      if (other.MinArea != 0F) {
        MinArea = other.MinArea;
      }
      if (other.MaxArea != 0F) {
        MaxArea = other.MaxArea;
      }
      if (other.OverlapThresh != 0F) {
        OverlapThresh = other.OverlapThresh;
      }
      if (other.ClipBoxes != false) {
        ClipBoxes = other.ClipBoxes;
      }
      if (other.RandomCoef != 0F) {
        RandomCoef = other.RandomCoef;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinObjectCovered = input.ReadFloat();
            break;
          }
          case 37: {
            MinArea = input.ReadFloat();
            break;
          }
          case 45: {
            MaxArea = input.ReadFloat();
            break;
          }
          case 53: {
            OverlapThresh = input.ReadFloat();
            break;
          }
          case 61: {
            RandomCoef = input.ReadFloat();
            break;
          }
          case 64: {
            ClipBoxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly crops a image to a fixed aspect ratio according to:
  ///     Liu et al., SSD: Single shot multibox detector.
  /// Multiple SSDRandomCropFixedAspectRatioOperations are defined by this
  /// preprocessing step. Only one operation (chosen at random) is actually
  /// performed on an image.
  /// </summary>
  public sealed partial class SSDRandomCropFixedAspectRatio : pb::IMessage<SSDRandomCropFixedAspectRatio> {
    private static readonly pb::MessageParser<SSDRandomCropFixedAspectRatio> _parser = new pb::MessageParser<SSDRandomCropFixedAspectRatio>(() => new SSDRandomCropFixedAspectRatio());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SSDRandomCropFixedAspectRatio> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[30]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropFixedAspectRatio() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropFixedAspectRatio(SSDRandomCropFixedAspectRatio other) : this() {
      operations_ = other.operations_.Clone();
      aspectRatio_ = other.aspectRatio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropFixedAspectRatio Clone() {
      return new SSDRandomCropFixedAspectRatio(this);
    }

    /// <summary>Field number for the "operations" field.</summary>
    public const int OperationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatioOperation> _repeated_operations_codec
        = pb::FieldCodec.ForMessage(10, global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatioOperation.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatioOperation> operations_ = new pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatioOperation>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropFixedAspectRatioOperation> Operations {
      get { return operations_; }
    }

    /// <summary>Field number for the "aspect_ratio" field.</summary>
    public const int AspectRatioFieldNumber = 2;
    private float aspectRatio_;
    /// <summary>
    /// Aspect ratio to crop to. This value is used for all crop operations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float AspectRatio {
      get { return aspectRatio_; }
      set {
        aspectRatio_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SSDRandomCropFixedAspectRatio);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SSDRandomCropFixedAspectRatio other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!operations_.Equals(other.operations_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AspectRatio, other.AspectRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= operations_.GetHashCode();
      if (AspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AspectRatio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      operations_.WriteTo(output, _repeated_operations_codec);
      if (AspectRatio != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(AspectRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += operations_.CalculateSize(_repeated_operations_codec);
      if (AspectRatio != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SSDRandomCropFixedAspectRatio other) {
      if (other == null) {
        return;
      }
      operations_.Add(other.operations_);
      if (other.AspectRatio != 0F) {
        AspectRatio = other.AspectRatio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            operations_.AddEntriesFrom(input, _repeated_operations_codec);
            break;
          }
          case 21: {
            AspectRatio = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SSDRandomCropPadFixedAspectRatioOperation : pb::IMessage<SSDRandomCropPadFixedAspectRatioOperation> {
    private static readonly pb::MessageParser<SSDRandomCropPadFixedAspectRatioOperation> _parser = new pb::MessageParser<SSDRandomCropPadFixedAspectRatioOperation>(() => new SSDRandomCropPadFixedAspectRatioOperation());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SSDRandomCropPadFixedAspectRatioOperation> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[31]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadFixedAspectRatioOperation() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadFixedAspectRatioOperation(SSDRandomCropPadFixedAspectRatioOperation other) : this() {
      minObjectCovered_ = other.minObjectCovered_;
      minAspectRatio_ = other.minAspectRatio_;
      maxAspectRatio_ = other.maxAspectRatio_;
      minArea_ = other.minArea_;
      maxArea_ = other.maxArea_;
      overlapThresh_ = other.overlapThresh_;
      clipBoxes_ = other.clipBoxes_;
      randomCoef_ = other.randomCoef_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadFixedAspectRatioOperation Clone() {
      return new SSDRandomCropPadFixedAspectRatioOperation(this);
    }

    /// <summary>Field number for the "min_object_covered" field.</summary>
    public const int MinObjectCoveredFieldNumber = 1;
    private float minObjectCovered_;
    /// <summary>
    /// Cropped image must cover at least this fraction of one original bounding
    /// box.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinObjectCovered {
      get { return minObjectCovered_; }
      set {
        minObjectCovered_ = value;
      }
    }

    /// <summary>Field number for the "min_aspect_ratio" field.</summary>
    public const int MinAspectRatioFieldNumber = 2;
    private float minAspectRatio_;
    /// <summary>
    /// The aspect ratio of the cropped image must be within the range of
    /// [min_aspect_ratio, max_aspect_ratio].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinAspectRatio {
      get { return minAspectRatio_; }
      set {
        minAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "max_aspect_ratio" field.</summary>
    public const int MaxAspectRatioFieldNumber = 3;
    private float maxAspectRatio_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxAspectRatio {
      get { return maxAspectRatio_; }
      set {
        maxAspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "min_area" field.</summary>
    public const int MinAreaFieldNumber = 4;
    private float minArea_;
    /// <summary>
    /// The area of the cropped image must be within the range of
    /// [min_area, max_area].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinArea {
      get { return minArea_; }
      set {
        minArea_ = value;
      }
    }

    /// <summary>Field number for the "max_area" field.</summary>
    public const int MaxAreaFieldNumber = 5;
    private float maxArea_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MaxArea {
      get { return maxArea_; }
      set {
        maxArea_ = value;
      }
    }

    /// <summary>Field number for the "overlap_thresh" field.</summary>
    public const int OverlapThreshFieldNumber = 6;
    private float overlapThresh_;
    /// <summary>
    /// Cropped box area ratio must be above this threhold to be kept.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float OverlapThresh {
      get { return overlapThresh_; }
      set {
        overlapThresh_ = value;
      }
    }

    /// <summary>Field number for the "clip_boxes" field.</summary>
    public const int ClipBoxesFieldNumber = 8;
    private bool clipBoxes_;
    /// <summary>
    /// Whether to clip the boxes to the cropped image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ClipBoxes {
      get { return clipBoxes_; }
      set {
        clipBoxes_ = value;
      }
    }

    /// <summary>Field number for the "random_coef" field.</summary>
    public const int RandomCoefFieldNumber = 7;
    private float randomCoef_;
    /// <summary>
    /// Probability a crop operation is skipped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RandomCoef {
      get { return randomCoef_; }
      set {
        randomCoef_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SSDRandomCropPadFixedAspectRatioOperation);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SSDRandomCropPadFixedAspectRatioOperation other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinObjectCovered, other.MinObjectCovered)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinAspectRatio, other.MinAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxAspectRatio, other.MaxAspectRatio)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinArea, other.MinArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaxArea, other.MaxArea)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(OverlapThresh, other.OverlapThresh)) return false;
      if (ClipBoxes != other.ClipBoxes) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RandomCoef, other.RandomCoef)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinObjectCovered != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinObjectCovered);
      if (MinAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinAspectRatio);
      if (MaxAspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxAspectRatio);
      if (MinArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinArea);
      if (MaxArea != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaxArea);
      if (OverlapThresh != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(OverlapThresh);
      if (ClipBoxes != false) hash ^= ClipBoxes.GetHashCode();
      if (RandomCoef != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RandomCoef);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinObjectCovered != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(MinObjectCovered);
      }
      if (MinAspectRatio != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(MinAspectRatio);
      }
      if (MaxAspectRatio != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(MaxAspectRatio);
      }
      if (MinArea != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(MinArea);
      }
      if (MaxArea != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(MaxArea);
      }
      if (OverlapThresh != 0F) {
        output.WriteRawTag(53);
        output.WriteFloat(OverlapThresh);
      }
      if (RandomCoef != 0F) {
        output.WriteRawTag(61);
        output.WriteFloat(RandomCoef);
      }
      if (ClipBoxes != false) {
        output.WriteRawTag(64);
        output.WriteBool(ClipBoxes);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinObjectCovered != 0F) {
        size += 1 + 4;
      }
      if (MinAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MaxAspectRatio != 0F) {
        size += 1 + 4;
      }
      if (MinArea != 0F) {
        size += 1 + 4;
      }
      if (MaxArea != 0F) {
        size += 1 + 4;
      }
      if (OverlapThresh != 0F) {
        size += 1 + 4;
      }
      if (ClipBoxes != false) {
        size += 1 + 1;
      }
      if (RandomCoef != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SSDRandomCropPadFixedAspectRatioOperation other) {
      if (other == null) {
        return;
      }
      if (other.MinObjectCovered != 0F) {
        MinObjectCovered = other.MinObjectCovered;
      }
      if (other.MinAspectRatio != 0F) {
        MinAspectRatio = other.MinAspectRatio;
      }
      if (other.MaxAspectRatio != 0F) {
        MaxAspectRatio = other.MaxAspectRatio;
      }
      if (other.MinArea != 0F) {
        MinArea = other.MinArea;
      }
      if (other.MaxArea != 0F) {
        MaxArea = other.MaxArea;
      }
      if (other.OverlapThresh != 0F) {
        OverlapThresh = other.OverlapThresh;
      }
      if (other.ClipBoxes != false) {
        ClipBoxes = other.ClipBoxes;
      }
      if (other.RandomCoef != 0F) {
        RandomCoef = other.RandomCoef;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            MinObjectCovered = input.ReadFloat();
            break;
          }
          case 21: {
            MinAspectRatio = input.ReadFloat();
            break;
          }
          case 29: {
            MaxAspectRatio = input.ReadFloat();
            break;
          }
          case 37: {
            MinArea = input.ReadFloat();
            break;
          }
          case 45: {
            MaxArea = input.ReadFloat();
            break;
          }
          case 53: {
            OverlapThresh = input.ReadFloat();
            break;
          }
          case 61: {
            RandomCoef = input.ReadFloat();
            break;
          }
          case 64: {
            ClipBoxes = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly crops and pads an image to a fixed aspect ratio according to:
  ///     Liu et al., SSD: Single shot multibox detector.
  /// Multiple SSDRandomCropPadFixedAspectRatioOperations are defined by this
  /// preprocessing step. Only one operation (chosen at random) is actually
  /// performed on an image.
  /// </summary>
  public sealed partial class SSDRandomCropPadFixedAspectRatio : pb::IMessage<SSDRandomCropPadFixedAspectRatio> {
    private static readonly pb::MessageParser<SSDRandomCropPadFixedAspectRatio> _parser = new pb::MessageParser<SSDRandomCropPadFixedAspectRatio>(() => new SSDRandomCropPadFixedAspectRatio());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SSDRandomCropPadFixedAspectRatio> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[32]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadFixedAspectRatio() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadFixedAspectRatio(SSDRandomCropPadFixedAspectRatio other) : this() {
      operations_ = other.operations_.Clone();
      aspectRatio_ = other.aspectRatio_;
      minPaddedSizeRatio_ = other.minPaddedSizeRatio_.Clone();
      maxPaddedSizeRatio_ = other.maxPaddedSizeRatio_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SSDRandomCropPadFixedAspectRatio Clone() {
      return new SSDRandomCropPadFixedAspectRatio(this);
    }

    /// <summary>Field number for the "operations" field.</summary>
    public const int OperationsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatioOperation> _repeated_operations_codec
        = pb::FieldCodec.ForMessage(10, global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatioOperation.Parser);
    private readonly pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatioOperation> operations_ = new pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatioOperation>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::Tensorflow.Models.ObjectDetection.Protos.SSDRandomCropPadFixedAspectRatioOperation> Operations {
      get { return operations_; }
    }

    /// <summary>Field number for the "aspect_ratio" field.</summary>
    public const int AspectRatioFieldNumber = 2;
    private float aspectRatio_;
    /// <summary>
    /// Aspect ratio to pad to. This value is used for all crop and pad operations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float AspectRatio {
      get { return aspectRatio_; }
      set {
        aspectRatio_ = value;
      }
    }

    /// <summary>Field number for the "min_padded_size_ratio" field.</summary>
    public const int MinPaddedSizeRatioFieldNumber = 3;
    private static readonly pb::FieldCodec<float> _repeated_minPaddedSizeRatio_codec
        = pb::FieldCodec.ForFloat(26);
    private readonly pbc::RepeatedField<float> minPaddedSizeRatio_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Min ratio of padded image height and width to the input image's height and
    /// width. Two entries per operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> MinPaddedSizeRatio {
      get { return minPaddedSizeRatio_; }
    }

    /// <summary>Field number for the "max_padded_size_ratio" field.</summary>
    public const int MaxPaddedSizeRatioFieldNumber = 4;
    private static readonly pb::FieldCodec<float> _repeated_maxPaddedSizeRatio_codec
        = pb::FieldCodec.ForFloat(34);
    private readonly pbc::RepeatedField<float> maxPaddedSizeRatio_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Max ratio of padded image height and width to the input image's height and
    /// width. Two entries per operation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> MaxPaddedSizeRatio {
      get { return maxPaddedSizeRatio_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SSDRandomCropPadFixedAspectRatio);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SSDRandomCropPadFixedAspectRatio other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!operations_.Equals(other.operations_)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AspectRatio, other.AspectRatio)) return false;
      if(!minPaddedSizeRatio_.Equals(other.minPaddedSizeRatio_)) return false;
      if(!maxPaddedSizeRatio_.Equals(other.maxPaddedSizeRatio_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= operations_.GetHashCode();
      if (AspectRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AspectRatio);
      hash ^= minPaddedSizeRatio_.GetHashCode();
      hash ^= maxPaddedSizeRatio_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      operations_.WriteTo(output, _repeated_operations_codec);
      if (AspectRatio != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(AspectRatio);
      }
      minPaddedSizeRatio_.WriteTo(output, _repeated_minPaddedSizeRatio_codec);
      maxPaddedSizeRatio_.WriteTo(output, _repeated_maxPaddedSizeRatio_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += operations_.CalculateSize(_repeated_operations_codec);
      if (AspectRatio != 0F) {
        size += 1 + 4;
      }
      size += minPaddedSizeRatio_.CalculateSize(_repeated_minPaddedSizeRatio_codec);
      size += maxPaddedSizeRatio_.CalculateSize(_repeated_maxPaddedSizeRatio_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SSDRandomCropPadFixedAspectRatio other) {
      if (other == null) {
        return;
      }
      operations_.Add(other.operations_);
      if (other.AspectRatio != 0F) {
        AspectRatio = other.AspectRatio;
      }
      minPaddedSizeRatio_.Add(other.minPaddedSizeRatio_);
      maxPaddedSizeRatio_.Add(other.maxPaddedSizeRatio_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            operations_.AddEntriesFrom(input, _repeated_operations_codec);
            break;
          }
          case 21: {
            AspectRatio = input.ReadFloat();
            break;
          }
          case 26:
          case 29: {
            minPaddedSizeRatio_.AddEntriesFrom(input, _repeated_minPaddedSizeRatio_codec);
            break;
          }
          case 34:
          case 37: {
            maxPaddedSizeRatio_.AddEntriesFrom(input, _repeated_maxPaddedSizeRatio_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Converts class logits to softmax optionally scaling the values by temperature
  /// first.
  /// </summary>
  public sealed partial class ConvertClassLogitsToSoftmax : pb::IMessage<ConvertClassLogitsToSoftmax> {
    private static readonly pb::MessageParser<ConvertClassLogitsToSoftmax> _parser = new pb::MessageParser<ConvertClassLogitsToSoftmax>(() => new ConvertClassLogitsToSoftmax());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ConvertClassLogitsToSoftmax> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[33]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvertClassLogitsToSoftmax() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvertClassLogitsToSoftmax(ConvertClassLogitsToSoftmax other) : this() {
      temperature_ = other.temperature_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ConvertClassLogitsToSoftmax Clone() {
      return new ConvertClassLogitsToSoftmax(this);
    }

    /// <summary>Field number for the "temperature" field.</summary>
    public const int TemperatureFieldNumber = 1;
    private float temperature_;
    /// <summary>
    /// Scale to use on logits before applying softmax.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Temperature {
      get { return temperature_; }
      set {
        temperature_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ConvertClassLogitsToSoftmax);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ConvertClassLogitsToSoftmax other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Temperature, other.Temperature)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Temperature != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Temperature);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Temperature != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Temperature);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Temperature != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ConvertClassLogitsToSoftmax other) {
      if (other == null) {
        return;
      }
      if (other.Temperature != 0F) {
        Temperature = other.Temperature;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Temperature = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly concatenates the image with itself horizontally and/or vertically.
  /// </summary>
  public sealed partial class RandomSelfConcatImage : pb::IMessage<RandomSelfConcatImage> {
    private static readonly pb::MessageParser<RandomSelfConcatImage> _parser = new pb::MessageParser<RandomSelfConcatImage>(() => new RandomSelfConcatImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomSelfConcatImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[34]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomSelfConcatImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomSelfConcatImage(RandomSelfConcatImage other) : this() {
      concatVerticalProbability_ = other.concatVerticalProbability_;
      concatHorizontalProbability_ = other.concatHorizontalProbability_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomSelfConcatImage Clone() {
      return new RandomSelfConcatImage(this);
    }

    /// <summary>Field number for the "concat_vertical_probability" field.</summary>
    public const int ConcatVerticalProbabilityFieldNumber = 1;
    private float concatVerticalProbability_;
    /// <summary>
    /// Probability of concatenating the image vertically.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ConcatVerticalProbability {
      get { return concatVerticalProbability_; }
      set {
        concatVerticalProbability_ = value;
      }
    }

    /// <summary>Field number for the "concat_horizontal_probability" field.</summary>
    public const int ConcatHorizontalProbabilityFieldNumber = 2;
    private float concatHorizontalProbability_;
    /// <summary>
    /// Probability of concatenating the image horizontally.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ConcatHorizontalProbability {
      get { return concatHorizontalProbability_; }
      set {
        concatHorizontalProbability_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomSelfConcatImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomSelfConcatImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ConcatVerticalProbability, other.ConcatVerticalProbability)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ConcatHorizontalProbability, other.ConcatHorizontalProbability)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ConcatVerticalProbability != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ConcatVerticalProbability);
      if (ConcatHorizontalProbability != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ConcatHorizontalProbability);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ConcatVerticalProbability != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(ConcatVerticalProbability);
      }
      if (ConcatHorizontalProbability != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(ConcatHorizontalProbability);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ConcatVerticalProbability != 0F) {
        size += 1 + 4;
      }
      if (ConcatHorizontalProbability != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomSelfConcatImage other) {
      if (other == null) {
        return;
      }
      if (other.ConcatVerticalProbability != 0F) {
        ConcatVerticalProbability = other.ConcatVerticalProbability;
      }
      if (other.ConcatHorizontalProbability != 0F) {
        ConcatHorizontalProbability = other.ConcatHorizontalProbability;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            ConcatVerticalProbability = input.ReadFloat();
            break;
          }
          case 21: {
            ConcatHorizontalProbability = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Apply an Autoaugment policy to the image and bounding boxes.
  /// </summary>
  public sealed partial class AutoAugmentImage : pb::IMessage<AutoAugmentImage> {
    private static readonly pb::MessageParser<AutoAugmentImage> _parser = new pb::MessageParser<AutoAugmentImage>(() => new AutoAugmentImage());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AutoAugmentImage> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[35]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoAugmentImage() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoAugmentImage(AutoAugmentImage other) : this() {
      policyName_ = other.policyName_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AutoAugmentImage Clone() {
      return new AutoAugmentImage(this);
    }

    /// <summary>Field number for the "policy_name" field.</summary>
    public const int PolicyNameFieldNumber = 1;
    private string policyName_ = "";
    /// <summary>
    /// What AutoAugment policy to apply to the Image
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string PolicyName {
      get { return policyName_; }
      set {
        policyName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AutoAugmentImage);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AutoAugmentImage other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (PolicyName != other.PolicyName) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (PolicyName.Length != 0) hash ^= PolicyName.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (PolicyName.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(PolicyName);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (PolicyName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(PolicyName);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AutoAugmentImage other) {
      if (other == null) {
        return;
      }
      if (other.PolicyName.Length != 0) {
        PolicyName = other.PolicyName;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            PolicyName = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Randomly drops ground truth boxes for a label with some probability.
  /// </summary>
  public sealed partial class DropLabelProbabilistically : pb::IMessage<DropLabelProbabilistically> {
    private static readonly pb::MessageParser<DropLabelProbabilistically> _parser = new pb::MessageParser<DropLabelProbabilistically>(() => new DropLabelProbabilistically());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<DropLabelProbabilistically> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[36]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DropLabelProbabilistically() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DropLabelProbabilistically(DropLabelProbabilistically other) : this() {
      label_ = other.label_;
      dropProbability_ = other.dropProbability_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public DropLabelProbabilistically Clone() {
      return new DropLabelProbabilistically(this);
    }

    /// <summary>Field number for the "label" field.</summary>
    public const int LabelFieldNumber = 1;
    private int label_;
    /// <summary>
    /// The label that should be dropped. This corresponds to one of the entries
    /// in the label map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int Label {
      get { return label_; }
      set {
        label_ = value;
      }
    }

    /// <summary>Field number for the "drop_probability" field.</summary>
    public const int DropProbabilityFieldNumber = 2;
    private float dropProbability_;
    /// <summary>
    /// Probability of dropping the label.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DropProbability {
      get { return dropProbability_; }
      set {
        dropProbability_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as DropLabelProbabilistically);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(DropLabelProbabilistically other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Label != other.Label) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DropProbability, other.DropProbability)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Label != 0) hash ^= Label.GetHashCode();
      if (DropProbability != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DropProbability);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Label != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(Label);
      }
      if (DropProbability != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(DropProbability);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Label != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Label);
      }
      if (DropProbability != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(DropLabelProbabilistically other) {
      if (other == null) {
        return;
      }
      if (other.Label != 0) {
        Label = other.Label;
      }
      if (other.DropProbability != 0F) {
        DropProbability = other.DropProbability;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            Label = input.ReadInt32();
            break;
          }
          case 21: {
            DropProbability = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///Remap a set of labels to a new label.
  /// </summary>
  public sealed partial class RemapLabels : pb::IMessage<RemapLabels> {
    private static readonly pb::MessageParser<RemapLabels> _parser = new pb::MessageParser<RemapLabels>(() => new RemapLabels());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RemapLabels> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PreprocessorReflection.Descriptor.MessageTypes[37]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemapLabels() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemapLabels(RemapLabels other) : this() {
      originalLabels_ = other.originalLabels_.Clone();
      newLabel_ = other.newLabel_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RemapLabels Clone() {
      return new RemapLabels(this);
    }

    /// <summary>Field number for the "original_labels" field.</summary>
    public const int OriginalLabelsFieldNumber = 1;
    private static readonly pb::FieldCodec<int> _repeated_originalLabels_codec
        = pb::FieldCodec.ForInt32(10);
    private readonly pbc::RepeatedField<int> originalLabels_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// Labels to be remapped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> OriginalLabels {
      get { return originalLabels_; }
    }

    /// <summary>Field number for the "new_label" field.</summary>
    public const int NewLabelFieldNumber = 2;
    private int newLabel_;
    /// <summary>
    /// Label to map to.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NewLabel {
      get { return newLabel_; }
      set {
        newLabel_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RemapLabels);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RemapLabels other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!originalLabels_.Equals(other.originalLabels_)) return false;
      if (NewLabel != other.NewLabel) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= originalLabels_.GetHashCode();
      if (NewLabel != 0) hash ^= NewLabel.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      originalLabels_.WriteTo(output, _repeated_originalLabels_codec);
      if (NewLabel != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(NewLabel);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += originalLabels_.CalculateSize(_repeated_originalLabels_codec);
      if (NewLabel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NewLabel);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RemapLabels other) {
      if (other == null) {
        return;
      }
      originalLabels_.Add(other.originalLabels_);
      if (other.NewLabel != 0) {
        NewLabel = other.NewLabel;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10:
          case 8: {
            originalLabels_.AddEntriesFrom(input, _repeated_originalLabels_codec);
            break;
          }
          case 16: {
            NewLabel = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
