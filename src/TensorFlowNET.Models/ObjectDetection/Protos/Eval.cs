// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: object_detection/protos/eval.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Models.ObjectDetection.Protos {

  /// <summary>Holder for reflection information generated from object_detection/protos/eval.proto</summary>
  public static partial class EvalReflection {

    #region Descriptor
    /// <summary>File descriptor for object_detection/protos/eval.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static EvalReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiJvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9ldmFsLnByb3RvEhdvYmplY3Rf",
            "ZGV0ZWN0aW9uLnByb3RvcyK3BQoKRXZhbENvbmZpZxISCgpiYXRjaF9zaXpl",
            "GBkgASgNEhoKEm51bV92aXN1YWxpemF0aW9ucxgBIAEoDRIUCgxudW1fZXhh",
            "bXBsZXMYAiABKA0SGgoSZXZhbF9pbnRlcnZhbF9zZWNzGAMgASgNEhEKCW1h",
            "eF9ldmFscxgEIAEoDRISCgpzYXZlX2dyYXBoGAUgASgIEiAKGHZpc3VhbGl6",
            "YXRpb25fZXhwb3J0X2RpchgGIAEoCRITCgtldmFsX21hc3RlchgHIAEoCRIT",
            "CgttZXRyaWNzX3NldBgIIAMoCRITCgtleHBvcnRfcGF0aBgJIAEoCRIaChJp",
            "Z25vcmVfZ3JvdW5kdHJ1dGgYCiABKAgSGwoTdXNlX21vdmluZ19hdmVyYWdl",
            "cxgLIAEoCBIbChNldmFsX2luc3RhbmNlX21hc2tzGAwgASgIEhsKE21pbl9z",
            "Y29yZV90aHJlc2hvbGQYDSABKAISIgoabWF4X251bV9ib3hlc190b192aXN1",
            "YWxpemUYDiABKAUSEwoLc2tpcF9zY29yZXMYDyABKAgSEwoLc2tpcF9sYWJl",
            "bHMYECABKAgSIwobdmlzdWFsaXplX2dyb3VuZHRydXRoX2JveGVzGBEgASgI",
            "EisKI2dyb3VuZHRydXRoX2JveF92aXN1YWxpemF0aW9uX2NvbG9yGBIgASgJ",
            "Ei4KJmtlZXBfaW1hZ2VfaWRfZm9yX3Zpc3VhbGl6YXRpb25fZXhwb3J0GBMg",
            "ASgIEh4KFnJldGFpbl9vcmlnaW5hbF9pbWFnZXMYFyABKAgSJAocaW5jbHVk",
            "ZV9tZXRyaWNzX3Blcl9jYXRlZ29yeRgYIAEoCBIaChJyZWNhbGxfbG93ZXJf",
            "Ym91bmQYGiABKAISGgoScmVjYWxsX3VwcGVyX2JvdW5kGBsgASgCYgZwcm90",
            "bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.EvalConfig), global::Tensorflow.Models.ObjectDetection.Protos.EvalConfig.Parser, new[]{ "BatchSize", "NumVisualizations", "NumExamples", "EvalIntervalSecs", "MaxEvals", "SaveGraph", "VisualizationExportDir", "EvalMaster", "MetricsSet", "ExportPath", "IgnoreGroundtruth", "UseMovingAverages", "EvalInstanceMasks", "MinScoreThreshold", "MaxNumBoxesToVisualize", "SkipScores", "SkipLabels", "VisualizeGroundtruthBoxes", "GroundtruthBoxVisualizationColor", "KeepImageIdForVisualizationExport", "RetainOriginalImages", "IncludeMetricsPerCategory", "RecallLowerBound", "RecallUpperBound" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Message for configuring DetectionModel evaluation jobs (eval.py).
  /// </summary>
  public sealed partial class EvalConfig : pb::IMessage<EvalConfig> {
    private static readonly pb::MessageParser<EvalConfig> _parser = new pb::MessageParser<EvalConfig>(() => new EvalConfig());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<EvalConfig> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.EvalReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EvalConfig() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EvalConfig(EvalConfig other) : this() {
      batchSize_ = other.batchSize_;
      numVisualizations_ = other.numVisualizations_;
      numExamples_ = other.numExamples_;
      evalIntervalSecs_ = other.evalIntervalSecs_;
      maxEvals_ = other.maxEvals_;
      saveGraph_ = other.saveGraph_;
      visualizationExportDir_ = other.visualizationExportDir_;
      evalMaster_ = other.evalMaster_;
      metricsSet_ = other.metricsSet_.Clone();
      exportPath_ = other.exportPath_;
      ignoreGroundtruth_ = other.ignoreGroundtruth_;
      useMovingAverages_ = other.useMovingAverages_;
      evalInstanceMasks_ = other.evalInstanceMasks_;
      minScoreThreshold_ = other.minScoreThreshold_;
      maxNumBoxesToVisualize_ = other.maxNumBoxesToVisualize_;
      skipScores_ = other.skipScores_;
      skipLabels_ = other.skipLabels_;
      visualizeGroundtruthBoxes_ = other.visualizeGroundtruthBoxes_;
      groundtruthBoxVisualizationColor_ = other.groundtruthBoxVisualizationColor_;
      keepImageIdForVisualizationExport_ = other.keepImageIdForVisualizationExport_;
      retainOriginalImages_ = other.retainOriginalImages_;
      includeMetricsPerCategory_ = other.includeMetricsPerCategory_;
      recallLowerBound_ = other.recallLowerBound_;
      recallUpperBound_ = other.recallUpperBound_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public EvalConfig Clone() {
      return new EvalConfig(this);
    }

    /// <summary>Field number for the "batch_size" field.</summary>
    public const int BatchSizeFieldNumber = 25;
    private uint batchSize_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint BatchSize {
      get { return batchSize_; }
      set {
        batchSize_ = value;
      }
    }

    /// <summary>Field number for the "num_visualizations" field.</summary>
    public const int NumVisualizationsFieldNumber = 1;
    private uint numVisualizations_;
    /// <summary>
    /// Number of visualization images to generate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NumVisualizations {
      get { return numVisualizations_; }
      set {
        numVisualizations_ = value;
      }
    }

    /// <summary>Field number for the "num_examples" field.</summary>
    public const int NumExamplesFieldNumber = 2;
    private uint numExamples_;
    /// <summary>
    /// Number of examples to process of evaluation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NumExamples {
      get { return numExamples_; }
      set {
        numExamples_ = value;
      }
    }

    /// <summary>Field number for the "eval_interval_secs" field.</summary>
    public const int EvalIntervalSecsFieldNumber = 3;
    private uint evalIntervalSecs_;
    /// <summary>
    /// How often to run evaluation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint EvalIntervalSecs {
      get { return evalIntervalSecs_; }
      set {
        evalIntervalSecs_ = value;
      }
    }

    /// <summary>Field number for the "max_evals" field.</summary>
    public const int MaxEvalsFieldNumber = 4;
    private uint maxEvals_;
    /// <summary>
    /// Maximum number of times to run evaluation. If set to 0, will run forever.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MaxEvals {
      get { return maxEvals_; }
      set {
        maxEvals_ = value;
      }
    }

    /// <summary>Field number for the "save_graph" field.</summary>
    public const int SaveGraphFieldNumber = 5;
    private bool saveGraph_;
    /// <summary>
    /// Whether the TensorFlow graph used for evaluation should be saved to disk.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SaveGraph {
      get { return saveGraph_; }
      set {
        saveGraph_ = value;
      }
    }

    /// <summary>Field number for the "visualization_export_dir" field.</summary>
    public const int VisualizationExportDirFieldNumber = 6;
    private string visualizationExportDir_ = "";
    /// <summary>
    /// Path to directory to store visualizations in. If empty, visualization
    /// images are not exported (only shown on Tensorboard).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string VisualizationExportDir {
      get { return visualizationExportDir_; }
      set {
        visualizationExportDir_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "eval_master" field.</summary>
    public const int EvalMasterFieldNumber = 7;
    private string evalMaster_ = "";
    /// <summary>
    /// BNS name of the TensorFlow master.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string EvalMaster {
      get { return evalMaster_; }
      set {
        evalMaster_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "metrics_set" field.</summary>
    public const int MetricsSetFieldNumber = 8;
    private static readonly pb::FieldCodec<string> _repeated_metricsSet_codec
        = pb::FieldCodec.ForString(66);
    private readonly pbc::RepeatedField<string> metricsSet_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Type of metrics to use for evaluation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> MetricsSet {
      get { return metricsSet_; }
    }

    /// <summary>Field number for the "export_path" field.</summary>
    public const int ExportPathFieldNumber = 9;
    private string exportPath_ = "";
    /// <summary>
    /// Path to export detections to COCO compatible JSON format.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ExportPath {
      get { return exportPath_; }
      set {
        exportPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "ignore_groundtruth" field.</summary>
    public const int IgnoreGroundtruthFieldNumber = 10;
    private bool ignoreGroundtruth_;
    /// <summary>
    /// Option to not read groundtruth labels and only export detections to
    /// COCO-compatible JSON file.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IgnoreGroundtruth {
      get { return ignoreGroundtruth_; }
      set {
        ignoreGroundtruth_ = value;
      }
    }

    /// <summary>Field number for the "use_moving_averages" field.</summary>
    public const int UseMovingAveragesFieldNumber = 11;
    private bool useMovingAverages_;
    /// <summary>
    /// Use exponential moving averages of variables for evaluation.
    /// TODO(rathodv): When this is false make sure the model is constructed
    /// without moving averages in restore_fn.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseMovingAverages {
      get { return useMovingAverages_; }
      set {
        useMovingAverages_ = value;
      }
    }

    /// <summary>Field number for the "eval_instance_masks" field.</summary>
    public const int EvalInstanceMasksFieldNumber = 12;
    private bool evalInstanceMasks_;
    /// <summary>
    /// Whether to evaluate instance masks.
    /// Note that since there is no evaluation code currently for instance
    /// segmenation this option is unused.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EvalInstanceMasks {
      get { return evalInstanceMasks_; }
      set {
        evalInstanceMasks_ = value;
      }
    }

    /// <summary>Field number for the "min_score_threshold" field.</summary>
    public const int MinScoreThresholdFieldNumber = 13;
    private float minScoreThreshold_;
    /// <summary>
    /// Minimum score threshold for a detected object box to be visualized
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinScoreThreshold {
      get { return minScoreThreshold_; }
      set {
        minScoreThreshold_ = value;
      }
    }

    /// <summary>Field number for the "max_num_boxes_to_visualize" field.</summary>
    public const int MaxNumBoxesToVisualizeFieldNumber = 14;
    private int maxNumBoxesToVisualize_;
    /// <summary>
    /// Maximum number of detections to visualize
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxNumBoxesToVisualize {
      get { return maxNumBoxesToVisualize_; }
      set {
        maxNumBoxesToVisualize_ = value;
      }
    }

    /// <summary>Field number for the "skip_scores" field.</summary>
    public const int SkipScoresFieldNumber = 15;
    private bool skipScores_;
    /// <summary>
    /// When drawing a single detection, each label is by default visualized as
    /// &lt;label name> : &lt;label score>. One can skip the name or/and score using the
    /// following fields:
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SkipScores {
      get { return skipScores_; }
      set {
        skipScores_ = value;
      }
    }

    /// <summary>Field number for the "skip_labels" field.</summary>
    public const int SkipLabelsFieldNumber = 16;
    private bool skipLabels_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool SkipLabels {
      get { return skipLabels_; }
      set {
        skipLabels_ = value;
      }
    }

    /// <summary>Field number for the "visualize_groundtruth_boxes" field.</summary>
    public const int VisualizeGroundtruthBoxesFieldNumber = 17;
    private bool visualizeGroundtruthBoxes_;
    /// <summary>
    /// Whether to show groundtruth boxes in addition to detected boxes in
    /// visualizations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool VisualizeGroundtruthBoxes {
      get { return visualizeGroundtruthBoxes_; }
      set {
        visualizeGroundtruthBoxes_ = value;
      }
    }

    /// <summary>Field number for the "groundtruth_box_visualization_color" field.</summary>
    public const int GroundtruthBoxVisualizationColorFieldNumber = 18;
    private string groundtruthBoxVisualizationColor_ = "";
    /// <summary>
    /// Box color for visualizing groundtruth boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string GroundtruthBoxVisualizationColor {
      get { return groundtruthBoxVisualizationColor_; }
      set {
        groundtruthBoxVisualizationColor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "keep_image_id_for_visualization_export" field.</summary>
    public const int KeepImageIdForVisualizationExportFieldNumber = 19;
    private bool keepImageIdForVisualizationExport_;
    /// <summary>
    /// Whether to keep image identifier in filename when exported to
    /// visualization_export_dir.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool KeepImageIdForVisualizationExport {
      get { return keepImageIdForVisualizationExport_; }
      set {
        keepImageIdForVisualizationExport_ = value;
      }
    }

    /// <summary>Field number for the "retain_original_images" field.</summary>
    public const int RetainOriginalImagesFieldNumber = 23;
    private bool retainOriginalImages_;
    /// <summary>
    /// Whether to retain original images (i.e. not pre-processed) in the tensor
    /// dictionary, so that they can be displayed in Tensorboard.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool RetainOriginalImages {
      get { return retainOriginalImages_; }
      set {
        retainOriginalImages_ = value;
      }
    }

    /// <summary>Field number for the "include_metrics_per_category" field.</summary>
    public const int IncludeMetricsPerCategoryFieldNumber = 24;
    private bool includeMetricsPerCategory_;
    /// <summary>
    /// If True, additionally include per-category metrics.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool IncludeMetricsPerCategory {
      get { return includeMetricsPerCategory_; }
      set {
        includeMetricsPerCategory_ = value;
      }
    }

    /// <summary>Field number for the "recall_lower_bound" field.</summary>
    public const int RecallLowerBoundFieldNumber = 26;
    private float recallLowerBound_;
    /// <summary>
    /// Recall range within which precision should be computed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RecallLowerBound {
      get { return recallLowerBound_; }
      set {
        recallLowerBound_ = value;
      }
    }

    /// <summary>Field number for the "recall_upper_bound" field.</summary>
    public const int RecallUpperBoundFieldNumber = 27;
    private float recallUpperBound_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float RecallUpperBound {
      get { return recallUpperBound_; }
      set {
        recallUpperBound_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as EvalConfig);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(EvalConfig other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (BatchSize != other.BatchSize) return false;
      if (NumVisualizations != other.NumVisualizations) return false;
      if (NumExamples != other.NumExamples) return false;
      if (EvalIntervalSecs != other.EvalIntervalSecs) return false;
      if (MaxEvals != other.MaxEvals) return false;
      if (SaveGraph != other.SaveGraph) return false;
      if (VisualizationExportDir != other.VisualizationExportDir) return false;
      if (EvalMaster != other.EvalMaster) return false;
      if(!metricsSet_.Equals(other.metricsSet_)) return false;
      if (ExportPath != other.ExportPath) return false;
      if (IgnoreGroundtruth != other.IgnoreGroundtruth) return false;
      if (UseMovingAverages != other.UseMovingAverages) return false;
      if (EvalInstanceMasks != other.EvalInstanceMasks) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinScoreThreshold, other.MinScoreThreshold)) return false;
      if (MaxNumBoxesToVisualize != other.MaxNumBoxesToVisualize) return false;
      if (SkipScores != other.SkipScores) return false;
      if (SkipLabels != other.SkipLabels) return false;
      if (VisualizeGroundtruthBoxes != other.VisualizeGroundtruthBoxes) return false;
      if (GroundtruthBoxVisualizationColor != other.GroundtruthBoxVisualizationColor) return false;
      if (KeepImageIdForVisualizationExport != other.KeepImageIdForVisualizationExport) return false;
      if (RetainOriginalImages != other.RetainOriginalImages) return false;
      if (IncludeMetricsPerCategory != other.IncludeMetricsPerCategory) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RecallLowerBound, other.RecallLowerBound)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(RecallUpperBound, other.RecallUpperBound)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (BatchSize != 0) hash ^= BatchSize.GetHashCode();
      if (NumVisualizations != 0) hash ^= NumVisualizations.GetHashCode();
      if (NumExamples != 0) hash ^= NumExamples.GetHashCode();
      if (EvalIntervalSecs != 0) hash ^= EvalIntervalSecs.GetHashCode();
      if (MaxEvals != 0) hash ^= MaxEvals.GetHashCode();
      if (SaveGraph != false) hash ^= SaveGraph.GetHashCode();
      if (VisualizationExportDir.Length != 0) hash ^= VisualizationExportDir.GetHashCode();
      if (EvalMaster.Length != 0) hash ^= EvalMaster.GetHashCode();
      hash ^= metricsSet_.GetHashCode();
      if (ExportPath.Length != 0) hash ^= ExportPath.GetHashCode();
      if (IgnoreGroundtruth != false) hash ^= IgnoreGroundtruth.GetHashCode();
      if (UseMovingAverages != false) hash ^= UseMovingAverages.GetHashCode();
      if (EvalInstanceMasks != false) hash ^= EvalInstanceMasks.GetHashCode();
      if (MinScoreThreshold != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinScoreThreshold);
      if (MaxNumBoxesToVisualize != 0) hash ^= MaxNumBoxesToVisualize.GetHashCode();
      if (SkipScores != false) hash ^= SkipScores.GetHashCode();
      if (SkipLabels != false) hash ^= SkipLabels.GetHashCode();
      if (VisualizeGroundtruthBoxes != false) hash ^= VisualizeGroundtruthBoxes.GetHashCode();
      if (GroundtruthBoxVisualizationColor.Length != 0) hash ^= GroundtruthBoxVisualizationColor.GetHashCode();
      if (KeepImageIdForVisualizationExport != false) hash ^= KeepImageIdForVisualizationExport.GetHashCode();
      if (RetainOriginalImages != false) hash ^= RetainOriginalImages.GetHashCode();
      if (IncludeMetricsPerCategory != false) hash ^= IncludeMetricsPerCategory.GetHashCode();
      if (RecallLowerBound != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RecallLowerBound);
      if (RecallUpperBound != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(RecallUpperBound);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (NumVisualizations != 0) {
        output.WriteRawTag(8);
        output.WriteUInt32(NumVisualizations);
      }
      if (NumExamples != 0) {
        output.WriteRawTag(16);
        output.WriteUInt32(NumExamples);
      }
      if (EvalIntervalSecs != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(EvalIntervalSecs);
      }
      if (MaxEvals != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(MaxEvals);
      }
      if (SaveGraph != false) {
        output.WriteRawTag(40);
        output.WriteBool(SaveGraph);
      }
      if (VisualizationExportDir.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(VisualizationExportDir);
      }
      if (EvalMaster.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(EvalMaster);
      }
      metricsSet_.WriteTo(output, _repeated_metricsSet_codec);
      if (ExportPath.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(ExportPath);
      }
      if (IgnoreGroundtruth != false) {
        output.WriteRawTag(80);
        output.WriteBool(IgnoreGroundtruth);
      }
      if (UseMovingAverages != false) {
        output.WriteRawTag(88);
        output.WriteBool(UseMovingAverages);
      }
      if (EvalInstanceMasks != false) {
        output.WriteRawTag(96);
        output.WriteBool(EvalInstanceMasks);
      }
      if (MinScoreThreshold != 0F) {
        output.WriteRawTag(109);
        output.WriteFloat(MinScoreThreshold);
      }
      if (MaxNumBoxesToVisualize != 0) {
        output.WriteRawTag(112);
        output.WriteInt32(MaxNumBoxesToVisualize);
      }
      if (SkipScores != false) {
        output.WriteRawTag(120);
        output.WriteBool(SkipScores);
      }
      if (SkipLabels != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(SkipLabels);
      }
      if (VisualizeGroundtruthBoxes != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(VisualizeGroundtruthBoxes);
      }
      if (GroundtruthBoxVisualizationColor.Length != 0) {
        output.WriteRawTag(146, 1);
        output.WriteString(GroundtruthBoxVisualizationColor);
      }
      if (KeepImageIdForVisualizationExport != false) {
        output.WriteRawTag(152, 1);
        output.WriteBool(KeepImageIdForVisualizationExport);
      }
      if (RetainOriginalImages != false) {
        output.WriteRawTag(184, 1);
        output.WriteBool(RetainOriginalImages);
      }
      if (IncludeMetricsPerCategory != false) {
        output.WriteRawTag(192, 1);
        output.WriteBool(IncludeMetricsPerCategory);
      }
      if (BatchSize != 0) {
        output.WriteRawTag(200, 1);
        output.WriteUInt32(BatchSize);
      }
      if (RecallLowerBound != 0F) {
        output.WriteRawTag(213, 1);
        output.WriteFloat(RecallLowerBound);
      }
      if (RecallUpperBound != 0F) {
        output.WriteRawTag(221, 1);
        output.WriteFloat(RecallUpperBound);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (BatchSize != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(BatchSize);
      }
      if (NumVisualizations != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumVisualizations);
      }
      if (NumExamples != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumExamples);
      }
      if (EvalIntervalSecs != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(EvalIntervalSecs);
      }
      if (MaxEvals != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MaxEvals);
      }
      if (SaveGraph != false) {
        size += 1 + 1;
      }
      if (VisualizationExportDir.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(VisualizationExportDir);
      }
      if (EvalMaster.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(EvalMaster);
      }
      size += metricsSet_.CalculateSize(_repeated_metricsSet_codec);
      if (ExportPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ExportPath);
      }
      if (IgnoreGroundtruth != false) {
        size += 1 + 1;
      }
      if (UseMovingAverages != false) {
        size += 1 + 1;
      }
      if (EvalInstanceMasks != false) {
        size += 1 + 1;
      }
      if (MinScoreThreshold != 0F) {
        size += 1 + 4;
      }
      if (MaxNumBoxesToVisualize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxNumBoxesToVisualize);
      }
      if (SkipScores != false) {
        size += 1 + 1;
      }
      if (SkipLabels != false) {
        size += 2 + 1;
      }
      if (VisualizeGroundtruthBoxes != false) {
        size += 2 + 1;
      }
      if (GroundtruthBoxVisualizationColor.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(GroundtruthBoxVisualizationColor);
      }
      if (KeepImageIdForVisualizationExport != false) {
        size += 2 + 1;
      }
      if (RetainOriginalImages != false) {
        size += 2 + 1;
      }
      if (IncludeMetricsPerCategory != false) {
        size += 2 + 1;
      }
      if (RecallLowerBound != 0F) {
        size += 2 + 4;
      }
      if (RecallUpperBound != 0F) {
        size += 2 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(EvalConfig other) {
      if (other == null) {
        return;
      }
      if (other.BatchSize != 0) {
        BatchSize = other.BatchSize;
      }
      if (other.NumVisualizations != 0) {
        NumVisualizations = other.NumVisualizations;
      }
      if (other.NumExamples != 0) {
        NumExamples = other.NumExamples;
      }
      if (other.EvalIntervalSecs != 0) {
        EvalIntervalSecs = other.EvalIntervalSecs;
      }
      if (other.MaxEvals != 0) {
        MaxEvals = other.MaxEvals;
      }
      if (other.SaveGraph != false) {
        SaveGraph = other.SaveGraph;
      }
      if (other.VisualizationExportDir.Length != 0) {
        VisualizationExportDir = other.VisualizationExportDir;
      }
      if (other.EvalMaster.Length != 0) {
        EvalMaster = other.EvalMaster;
      }
      metricsSet_.Add(other.metricsSet_);
      if (other.ExportPath.Length != 0) {
        ExportPath = other.ExportPath;
      }
      if (other.IgnoreGroundtruth != false) {
        IgnoreGroundtruth = other.IgnoreGroundtruth;
      }
      if (other.UseMovingAverages != false) {
        UseMovingAverages = other.UseMovingAverages;
      }
      if (other.EvalInstanceMasks != false) {
        EvalInstanceMasks = other.EvalInstanceMasks;
      }
      if (other.MinScoreThreshold != 0F) {
        MinScoreThreshold = other.MinScoreThreshold;
      }
      if (other.MaxNumBoxesToVisualize != 0) {
        MaxNumBoxesToVisualize = other.MaxNumBoxesToVisualize;
      }
      if (other.SkipScores != false) {
        SkipScores = other.SkipScores;
      }
      if (other.SkipLabels != false) {
        SkipLabels = other.SkipLabels;
      }
      if (other.VisualizeGroundtruthBoxes != false) {
        VisualizeGroundtruthBoxes = other.VisualizeGroundtruthBoxes;
      }
      if (other.GroundtruthBoxVisualizationColor.Length != 0) {
        GroundtruthBoxVisualizationColor = other.GroundtruthBoxVisualizationColor;
      }
      if (other.KeepImageIdForVisualizationExport != false) {
        KeepImageIdForVisualizationExport = other.KeepImageIdForVisualizationExport;
      }
      if (other.RetainOriginalImages != false) {
        RetainOriginalImages = other.RetainOriginalImages;
      }
      if (other.IncludeMetricsPerCategory != false) {
        IncludeMetricsPerCategory = other.IncludeMetricsPerCategory;
      }
      if (other.RecallLowerBound != 0F) {
        RecallLowerBound = other.RecallLowerBound;
      }
      if (other.RecallUpperBound != 0F) {
        RecallUpperBound = other.RecallUpperBound;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NumVisualizations = input.ReadUInt32();
            break;
          }
          case 16: {
            NumExamples = input.ReadUInt32();
            break;
          }
          case 24: {
            EvalIntervalSecs = input.ReadUInt32();
            break;
          }
          case 32: {
            MaxEvals = input.ReadUInt32();
            break;
          }
          case 40: {
            SaveGraph = input.ReadBool();
            break;
          }
          case 50: {
            VisualizationExportDir = input.ReadString();
            break;
          }
          case 58: {
            EvalMaster = input.ReadString();
            break;
          }
          case 66: {
            metricsSet_.AddEntriesFrom(input, _repeated_metricsSet_codec);
            break;
          }
          case 74: {
            ExportPath = input.ReadString();
            break;
          }
          case 80: {
            IgnoreGroundtruth = input.ReadBool();
            break;
          }
          case 88: {
            UseMovingAverages = input.ReadBool();
            break;
          }
          case 96: {
            EvalInstanceMasks = input.ReadBool();
            break;
          }
          case 109: {
            MinScoreThreshold = input.ReadFloat();
            break;
          }
          case 112: {
            MaxNumBoxesToVisualize = input.ReadInt32();
            break;
          }
          case 120: {
            SkipScores = input.ReadBool();
            break;
          }
          case 128: {
            SkipLabels = input.ReadBool();
            break;
          }
          case 136: {
            VisualizeGroundtruthBoxes = input.ReadBool();
            break;
          }
          case 146: {
            GroundtruthBoxVisualizationColor = input.ReadString();
            break;
          }
          case 152: {
            KeepImageIdForVisualizationExport = input.ReadBool();
            break;
          }
          case 184: {
            RetainOriginalImages = input.ReadBool();
            break;
          }
          case 192: {
            IncludeMetricsPerCategory = input.ReadBool();
            break;
          }
          case 200: {
            BatchSize = input.ReadUInt32();
            break;
          }
          case 213: {
            RecallLowerBound = input.ReadFloat();
            break;
          }
          case 221: {
            RecallUpperBound = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
