// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: object_detection/protos/post_processing.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Models.ObjectDetection.Protos {

  /// <summary>Holder for reflection information generated from object_detection/protos/post_processing.proto</summary>
  public static partial class PostProcessingReflection {

    #region Descriptor
    /// <summary>File descriptor for object_detection/protos/post_processing.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static PostProcessingReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "Ci1vYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9wb3N0X3Byb2Nlc3NpbmcucHJv",
            "dG8SF29iamVjdF9kZXRlY3Rpb24ucHJvdG9zGilvYmplY3RfZGV0ZWN0aW9u",
            "L3Byb3Rvcy9jYWxpYnJhdGlvbi5wcm90byL+AQoWQmF0Y2hOb25NYXhTdXBw",
            "cmVzc2lvbhIXCg9zY29yZV90aHJlc2hvbGQYASABKAISFQoNaW91X3RocmVz",
            "aG9sZBgCIAEoAhIgChhtYXhfZGV0ZWN0aW9uc19wZXJfY2xhc3MYAyABKAUS",
            "HAoUbWF4X3RvdGFsX2RldGVjdGlvbnMYBSABKAUSGQoRdXNlX3N0YXRpY19z",
            "aGFwZXMYBiABKAgSHgoWdXNlX2NsYXNzX2Fnbm9zdGljX25tcxgHIAEoCBIh",
            "ChltYXhfY2xhc3Nlc19wZXJfZGV0ZWN0aW9uGAggASgFEhYKDnNvZnRfbm1z",
            "X3NpZ21hGAkgASgCIswCCg5Qb3N0UHJvY2Vzc2luZxJSChliYXRjaF9ub25f",
            "bWF4X3N1cHByZXNzaW9uGAEgASgLMi8ub2JqZWN0X2RldGVjdGlvbi5wcm90",
            "b3MuQmF0Y2hOb25NYXhTdXBwcmVzc2lvbhJPCg9zY29yZV9jb252ZXJ0ZXIY",
            "AiABKA4yNi5vYmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5Qb3N0UHJvY2Vzc2lu",
            "Zy5TY29yZUNvbnZlcnRlchITCgtsb2dpdF9zY2FsZRgDIAEoAhJGChJjYWxp",
            "YnJhdGlvbl9jb25maWcYBCABKAsyKi5vYmplY3RfZGV0ZWN0aW9uLnByb3Rv",
            "cy5DYWxpYnJhdGlvbkNvbmZpZyI4Cg5TY29yZUNvbnZlcnRlchIMCghJREVO",
            "VElUWRAAEgsKB1NJR01PSUQQARILCgdTT0ZUTUFYEAJiBnByb3RvMw=="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorflow.Models.ObjectDetection.Protos.CalibrationReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.BatchNonMaxSuppression), global::Tensorflow.Models.ObjectDetection.Protos.BatchNonMaxSuppression.Parser, new[]{ "ScoreThreshold", "IouThreshold", "MaxDetectionsPerClass", "MaxTotalDetections", "UseStaticShapes", "UseClassAgnosticNms", "MaxClassesPerDetection", "SoftNmsSigma" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing), global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing.Parser, new[]{ "BatchNonMaxSuppression", "ScoreConverter", "LogitScale", "CalibrationConfig" }, null, new[]{ typeof(global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing.Types.ScoreConverter) }, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration proto for non-max-suppression operation on a batch of
  /// detections.
  /// </summary>
  public sealed partial class BatchNonMaxSuppression : pb::IMessage<BatchNonMaxSuppression> {
    private static readonly pb::MessageParser<BatchNonMaxSuppression> _parser = new pb::MessageParser<BatchNonMaxSuppression>(() => new BatchNonMaxSuppression());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BatchNonMaxSuppression> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PostProcessingReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatchNonMaxSuppression() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatchNonMaxSuppression(BatchNonMaxSuppression other) : this() {
      scoreThreshold_ = other.scoreThreshold_;
      iouThreshold_ = other.iouThreshold_;
      maxDetectionsPerClass_ = other.maxDetectionsPerClass_;
      maxTotalDetections_ = other.maxTotalDetections_;
      useStaticShapes_ = other.useStaticShapes_;
      useClassAgnosticNms_ = other.useClassAgnosticNms_;
      maxClassesPerDetection_ = other.maxClassesPerDetection_;
      softNmsSigma_ = other.softNmsSigma_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BatchNonMaxSuppression Clone() {
      return new BatchNonMaxSuppression(this);
    }

    /// <summary>Field number for the "score_threshold" field.</summary>
    public const int ScoreThresholdFieldNumber = 1;
    private float scoreThreshold_;
    /// <summary>
    /// Scalar threshold for score (low scoring boxes are removed).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ScoreThreshold {
      get { return scoreThreshold_; }
      set {
        scoreThreshold_ = value;
      }
    }

    /// <summary>Field number for the "iou_threshold" field.</summary>
    public const int IouThresholdFieldNumber = 2;
    private float iouThreshold_;
    /// <summary>
    /// Scalar threshold for IOU (boxes that have high IOU overlap
    /// with previously selected boxes are removed).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float IouThreshold {
      get { return iouThreshold_; }
      set {
        iouThreshold_ = value;
      }
    }

    /// <summary>Field number for the "max_detections_per_class" field.</summary>
    public const int MaxDetectionsPerClassFieldNumber = 3;
    private int maxDetectionsPerClass_;
    /// <summary>
    /// Maximum number of detections to retain per class.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxDetectionsPerClass {
      get { return maxDetectionsPerClass_; }
      set {
        maxDetectionsPerClass_ = value;
      }
    }

    /// <summary>Field number for the "max_total_detections" field.</summary>
    public const int MaxTotalDetectionsFieldNumber = 5;
    private int maxTotalDetections_;
    /// <summary>
    /// Maximum number of detections to retain across all classes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxTotalDetections {
      get { return maxTotalDetections_; }
      set {
        maxTotalDetections_ = value;
      }
    }

    /// <summary>Field number for the "use_static_shapes" field.</summary>
    public const int UseStaticShapesFieldNumber = 6;
    private bool useStaticShapes_;
    /// <summary>
    /// Whether to use the implementation of NMS that guarantees static shapes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseStaticShapes {
      get { return useStaticShapes_; }
      set {
        useStaticShapes_ = value;
      }
    }

    /// <summary>Field number for the "use_class_agnostic_nms" field.</summary>
    public const int UseClassAgnosticNmsFieldNumber = 7;
    private bool useClassAgnosticNms_;
    /// <summary>
    /// Whether to use class agnostic NMS.
    /// Class-agnostic NMS function implements a class-agnostic version
    /// of Non Maximal Suppression where if max_classes_per_detection=k,
    /// 1) we keep the top-k scores for each detection and
    /// 2) during NMS, each detection only uses the highest class score for sorting.
    /// 3) Compared to regular NMS, the worst runtime of this version is O(N^2)
    /// instead of O(KN^2) where N is the number of detections and K the number of
    /// classes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseClassAgnosticNms {
      get { return useClassAgnosticNms_; }
      set {
        useClassAgnosticNms_ = value;
      }
    }

    /// <summary>Field number for the "max_classes_per_detection" field.</summary>
    public const int MaxClassesPerDetectionFieldNumber = 8;
    private int maxClassesPerDetection_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxClassesPerDetection {
      get { return maxClassesPerDetection_; }
      set {
        maxClassesPerDetection_ = value;
      }
    }

    /// <summary>Field number for the "soft_nms_sigma" field.</summary>
    public const int SoftNmsSigmaFieldNumber = 9;
    private float softNmsSigma_;
    /// <summary>
    /// Soft NMS sigma parameter; Bodla et al, https://arxiv.org/abs/1704.04503)
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float SoftNmsSigma {
      get { return softNmsSigma_; }
      set {
        softNmsSigma_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BatchNonMaxSuppression);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BatchNonMaxSuppression other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ScoreThreshold, other.ScoreThreshold)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(IouThreshold, other.IouThreshold)) return false;
      if (MaxDetectionsPerClass != other.MaxDetectionsPerClass) return false;
      if (MaxTotalDetections != other.MaxTotalDetections) return false;
      if (UseStaticShapes != other.UseStaticShapes) return false;
      if (UseClassAgnosticNms != other.UseClassAgnosticNms) return false;
      if (MaxClassesPerDetection != other.MaxClassesPerDetection) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(SoftNmsSigma, other.SoftNmsSigma)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (ScoreThreshold != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ScoreThreshold);
      if (IouThreshold != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(IouThreshold);
      if (MaxDetectionsPerClass != 0) hash ^= MaxDetectionsPerClass.GetHashCode();
      if (MaxTotalDetections != 0) hash ^= MaxTotalDetections.GetHashCode();
      if (UseStaticShapes != false) hash ^= UseStaticShapes.GetHashCode();
      if (UseClassAgnosticNms != false) hash ^= UseClassAgnosticNms.GetHashCode();
      if (MaxClassesPerDetection != 0) hash ^= MaxClassesPerDetection.GetHashCode();
      if (SoftNmsSigma != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(SoftNmsSigma);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (ScoreThreshold != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(ScoreThreshold);
      }
      if (IouThreshold != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(IouThreshold);
      }
      if (MaxDetectionsPerClass != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(MaxDetectionsPerClass);
      }
      if (MaxTotalDetections != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(MaxTotalDetections);
      }
      if (UseStaticShapes != false) {
        output.WriteRawTag(48);
        output.WriteBool(UseStaticShapes);
      }
      if (UseClassAgnosticNms != false) {
        output.WriteRawTag(56);
        output.WriteBool(UseClassAgnosticNms);
      }
      if (MaxClassesPerDetection != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(MaxClassesPerDetection);
      }
      if (SoftNmsSigma != 0F) {
        output.WriteRawTag(77);
        output.WriteFloat(SoftNmsSigma);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (ScoreThreshold != 0F) {
        size += 1 + 4;
      }
      if (IouThreshold != 0F) {
        size += 1 + 4;
      }
      if (MaxDetectionsPerClass != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxDetectionsPerClass);
      }
      if (MaxTotalDetections != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxTotalDetections);
      }
      if (UseStaticShapes != false) {
        size += 1 + 1;
      }
      if (UseClassAgnosticNms != false) {
        size += 1 + 1;
      }
      if (MaxClassesPerDetection != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxClassesPerDetection);
      }
      if (SoftNmsSigma != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BatchNonMaxSuppression other) {
      if (other == null) {
        return;
      }
      if (other.ScoreThreshold != 0F) {
        ScoreThreshold = other.ScoreThreshold;
      }
      if (other.IouThreshold != 0F) {
        IouThreshold = other.IouThreshold;
      }
      if (other.MaxDetectionsPerClass != 0) {
        MaxDetectionsPerClass = other.MaxDetectionsPerClass;
      }
      if (other.MaxTotalDetections != 0) {
        MaxTotalDetections = other.MaxTotalDetections;
      }
      if (other.UseStaticShapes != false) {
        UseStaticShapes = other.UseStaticShapes;
      }
      if (other.UseClassAgnosticNms != false) {
        UseClassAgnosticNms = other.UseClassAgnosticNms;
      }
      if (other.MaxClassesPerDetection != 0) {
        MaxClassesPerDetection = other.MaxClassesPerDetection;
      }
      if (other.SoftNmsSigma != 0F) {
        SoftNmsSigma = other.SoftNmsSigma;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            ScoreThreshold = input.ReadFloat();
            break;
          }
          case 21: {
            IouThreshold = input.ReadFloat();
            break;
          }
          case 24: {
            MaxDetectionsPerClass = input.ReadInt32();
            break;
          }
          case 40: {
            MaxTotalDetections = input.ReadInt32();
            break;
          }
          case 48: {
            UseStaticShapes = input.ReadBool();
            break;
          }
          case 56: {
            UseClassAgnosticNms = input.ReadBool();
            break;
          }
          case 64: {
            MaxClassesPerDetection = input.ReadInt32();
            break;
          }
          case 77: {
            SoftNmsSigma = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration proto for post-processing predicted boxes and
  /// scores.
  /// </summary>
  public sealed partial class PostProcessing : pb::IMessage<PostProcessing> {
    private static readonly pb::MessageParser<PostProcessing> _parser = new pb::MessageParser<PostProcessing>(() => new PostProcessing());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<PostProcessing> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.PostProcessingReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PostProcessing() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PostProcessing(PostProcessing other) : this() {
      batchNonMaxSuppression_ = other.batchNonMaxSuppression_ != null ? other.batchNonMaxSuppression_.Clone() : null;
      scoreConverter_ = other.scoreConverter_;
      logitScale_ = other.logitScale_;
      calibrationConfig_ = other.calibrationConfig_ != null ? other.calibrationConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public PostProcessing Clone() {
      return new PostProcessing(this);
    }

    /// <summary>Field number for the "batch_non_max_suppression" field.</summary>
    public const int BatchNonMaxSuppressionFieldNumber = 1;
    private global::Tensorflow.Models.ObjectDetection.Protos.BatchNonMaxSuppression batchNonMaxSuppression_;
    /// <summary>
    /// Non max suppression parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.BatchNonMaxSuppression BatchNonMaxSuppression {
      get { return batchNonMaxSuppression_; }
      set {
        batchNonMaxSuppression_ = value;
      }
    }

    /// <summary>Field number for the "score_converter" field.</summary>
    public const int ScoreConverterFieldNumber = 2;
    private global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing.Types.ScoreConverter scoreConverter_ = 0;
    /// <summary>
    /// Score converter to use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing.Types.ScoreConverter ScoreConverter {
      get { return scoreConverter_; }
      set {
        scoreConverter_ = value;
      }
    }

    /// <summary>Field number for the "logit_scale" field.</summary>
    public const int LogitScaleFieldNumber = 3;
    private float logitScale_;
    /// <summary>
    /// Scale logit (input) value before conversion in post-processing step.
    /// Typically used for softmax distillation, though can be used to scale for
    /// other reasons.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LogitScale {
      get { return logitScale_; }
      set {
        logitScale_ = value;
      }
    }

    /// <summary>Field number for the "calibration_config" field.</summary>
    public const int CalibrationConfigFieldNumber = 4;
    private global::Tensorflow.Models.ObjectDetection.Protos.CalibrationConfig calibrationConfig_;
    /// <summary>
    /// Calibrate score outputs. Calibration is applied after score converter
    /// and before non max suppression.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.CalibrationConfig CalibrationConfig {
      get { return calibrationConfig_; }
      set {
        calibrationConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as PostProcessing);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(PostProcessing other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(BatchNonMaxSuppression, other.BatchNonMaxSuppression)) return false;
      if (ScoreConverter != other.ScoreConverter) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LogitScale, other.LogitScale)) return false;
      if (!object.Equals(CalibrationConfig, other.CalibrationConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (batchNonMaxSuppression_ != null) hash ^= BatchNonMaxSuppression.GetHashCode();
      if (ScoreConverter != 0) hash ^= ScoreConverter.GetHashCode();
      if (LogitScale != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LogitScale);
      if (calibrationConfig_ != null) hash ^= CalibrationConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (batchNonMaxSuppression_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(BatchNonMaxSuppression);
      }
      if (ScoreConverter != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) ScoreConverter);
      }
      if (LogitScale != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(LogitScale);
      }
      if (calibrationConfig_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(CalibrationConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (batchNonMaxSuppression_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BatchNonMaxSuppression);
      }
      if (ScoreConverter != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ScoreConverter);
      }
      if (LogitScale != 0F) {
        size += 1 + 4;
      }
      if (calibrationConfig_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(CalibrationConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(PostProcessing other) {
      if (other == null) {
        return;
      }
      if (other.batchNonMaxSuppression_ != null) {
        if (batchNonMaxSuppression_ == null) {
          batchNonMaxSuppression_ = new global::Tensorflow.Models.ObjectDetection.Protos.BatchNonMaxSuppression();
        }
        BatchNonMaxSuppression.MergeFrom(other.BatchNonMaxSuppression);
      }
      if (other.ScoreConverter != 0) {
        ScoreConverter = other.ScoreConverter;
      }
      if (other.LogitScale != 0F) {
        LogitScale = other.LogitScale;
      }
      if (other.calibrationConfig_ != null) {
        if (calibrationConfig_ == null) {
          calibrationConfig_ = new global::Tensorflow.Models.ObjectDetection.Protos.CalibrationConfig();
        }
        CalibrationConfig.MergeFrom(other.CalibrationConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (batchNonMaxSuppression_ == null) {
              batchNonMaxSuppression_ = new global::Tensorflow.Models.ObjectDetection.Protos.BatchNonMaxSuppression();
            }
            input.ReadMessage(batchNonMaxSuppression_);
            break;
          }
          case 16: {
            scoreConverter_ = (global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing.Types.ScoreConverter) input.ReadEnum();
            break;
          }
          case 29: {
            LogitScale = input.ReadFloat();
            break;
          }
          case 34: {
            if (calibrationConfig_ == null) {
              calibrationConfig_ = new global::Tensorflow.Models.ObjectDetection.Protos.CalibrationConfig();
            }
            input.ReadMessage(calibrationConfig_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the PostProcessing message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Enum to specify how to convert the detection scores.
      /// </summary>
      public enum ScoreConverter {
        /// <summary>
        /// Input scores equals output scores.
        /// </summary>
        [pbr::OriginalName("IDENTITY")] Identity = 0,
        /// <summary>
        /// Applies a sigmoid on input scores.
        /// </summary>
        [pbr::OriginalName("SIGMOID")] Sigmoid = 1,
        /// <summary>
        /// Applies a softmax on input scores
        /// </summary>
        [pbr::OriginalName("SOFTMAX")] Softmax = 2,
      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
