// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: object_detection/protos/losses.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Models.ObjectDetection.Protos {

  /// <summary>Holder for reflection information generated from object_detection/protos/losses.proto</summary>
  public static partial class LossesReflection {

    #region Descriptor
    /// <summary>File descriptor for object_detection/protos/losses.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static LossesReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiRvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9sb3NzZXMucHJvdG8SF29iamVj",
            "dF9kZXRlY3Rpb24ucHJvdG9zIukFCgRMb3NzEkQKEWxvY2FsaXphdGlvbl9s",
            "b3NzGAEgASgLMikub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuTG9jYWxpemF0",
            "aW9uTG9zcxJIChNjbGFzc2lmaWNhdGlvbl9sb3NzGAIgASgLMisub2JqZWN0",
            "X2RldGVjdGlvbi5wcm90b3MuQ2xhc3NpZmljYXRpb25Mb3NzEkUKEmhhcmRf",
            "ZXhhbXBsZV9taW5lchgDIAEoCzIpLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9z",
            "LkhhcmRFeGFtcGxlTWluZXISHQoVY2xhc3NpZmljYXRpb25fd2VpZ2h0GAQg",
            "ASgCEhsKE2xvY2FsaXphdGlvbl93ZWlnaHQYBSABKAISTQoWcmFuZG9tX2V4",
            "YW1wbGVfc2FtcGxlchgGIAEoCzItLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9z",
            "LlJhbmRvbUV4YW1wbGVTYW1wbGVyEkkKEWVxdWFsaXphdGlvbl9sb3NzGAcg",
            "ASgLMi4ub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuTG9zcy5FcXVhbGl6YXRp",
            "b25Mb3NzElAKFWV4cGVjdGVkX2xvc3Nfd2VpZ2h0cxgSIAEoDjIxLm9iamVj",
            "dF9kZXRlY3Rpb24ucHJvdG9zLkxvc3MuRXhwZWN0ZWRMb3NzV2VpZ2h0cxIg",
            "ChhtaW5fbnVtX25lZ2F0aXZlX3NhbXBsZXMYEyABKAISJwofZGVzaXJlZF9u",
            "ZWdhdGl2ZV9zYW1wbGluZ19yYXRpbxgUIAEoAho8ChBFcXVhbGl6YXRpb25M",
            "b3NzEg4KBndlaWdodBgBIAEoAhIYChBleGNsdWRlX3ByZWZpeGVzGAIgAygJ",
            "IlkKE0V4cGVjdGVkTG9zc1dlaWdodHMSCAoETk9ORRAAEhUKEUVYUEVDVEVE",
            "X1NBTVBMSU5HEAESIQodUkVXRUlHSFRJTkdfVU5NQVRDSEVEX0FOQ0hPUlMQ",
            "AiKaAgoQTG9jYWxpemF0aW9uTG9zcxJKCgt3ZWlnaHRlZF9sMhgBIAEoCzIz",
            "Lm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLldlaWdodGVkTDJMb2NhbGl6YXRp",
            "b25Mb3NzSAASVwoSd2VpZ2h0ZWRfc21vb3RoX2wxGAIgASgLMjkub2JqZWN0",
            "X2RldGVjdGlvbi5wcm90b3MuV2VpZ2h0ZWRTbW9vdGhMMUxvY2FsaXphdGlv",
            "bkxvc3NIABJMCgx3ZWlnaHRlZF9pb3UYAyABKAsyNC5vYmplY3RfZGV0ZWN0",
            "aW9uLnByb3Rvcy5XZWlnaHRlZElPVUxvY2FsaXphdGlvbkxvc3NIAEITChFs",
            "b2NhbGl6YXRpb25fbG9zcyI3ChpXZWlnaHRlZEwyTG9jYWxpemF0aW9uTG9z",
            "cxIZChFhbmNob3J3aXNlX291dHB1dBgBIAEoCCJMCiBXZWlnaHRlZFNtb290",
            "aEwxTG9jYWxpemF0aW9uTG9zcxIZChFhbmNob3J3aXNlX291dHB1dBgBIAEo",
            "CBINCgVkZWx0YRgCIAEoAiIdChtXZWlnaHRlZElPVUxvY2FsaXphdGlvbkxv",
            "c3MiggQKEkNsYXNzaWZpY2F0aW9uTG9zcxJWChB3ZWlnaHRlZF9zaWdtb2lk",
            "GAEgASgLMjoub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuV2VpZ2h0ZWRTaWdt",
            "b2lkQ2xhc3NpZmljYXRpb25Mb3NzSAASVgoQd2VpZ2h0ZWRfc29mdG1heBgC",
            "IAEoCzI6Lm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLldlaWdodGVkU29mdG1h",
            "eENsYXNzaWZpY2F0aW9uTG9zc0gAEmoKF3dlaWdodGVkX2xvZ2l0c19zb2Z0",
            "bWF4GAUgASgLMkcub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuV2VpZ2h0ZWRT",
            "b2Z0bWF4Q2xhc3NpZmljYXRpb25BZ2FpbnN0TG9naXRzTG9zc0gAEl4KFGJv",
            "b3RzdHJhcHBlZF9zaWdtb2lkGAMgASgLMj4ub2JqZWN0X2RldGVjdGlvbi5w",
            "cm90b3MuQm9vdHN0cmFwcGVkU2lnbW9pZENsYXNzaWZpY2F0aW9uTG9zc0gA",
            "ElkKFndlaWdodGVkX3NpZ21vaWRfZm9jYWwYBCABKAsyNy5vYmplY3RfZGV0",
            "ZWN0aW9uLnByb3Rvcy5TaWdtb2lkRm9jYWxDbGFzc2lmaWNhdGlvbkxvc3NI",
            "AEIVChNjbGFzc2lmaWNhdGlvbl9sb3NzIj4KIVdlaWdodGVkU2lnbW9pZENs",
            "YXNzaWZpY2F0aW9uTG9zcxIZChFhbmNob3J3aXNlX291dHB1dBgBIAEoCCJZ",
            "Ch5TaWdtb2lkRm9jYWxDbGFzc2lmaWNhdGlvbkxvc3MSGQoRYW5jaG9yd2lz",
            "ZV9vdXRwdXQYASABKAgSDQoFZ2FtbWEYAiABKAISDQoFYWxwaGEYAyABKAIi",
            "UwohV2VpZ2h0ZWRTb2Z0bWF4Q2xhc3NpZmljYXRpb25Mb3NzEhkKEWFuY2hv",
            "cndpc2Vfb3V0cHV0GAEgASgIEhMKC2xvZ2l0X3NjYWxlGAIgASgCImAKLldl",
            "aWdodGVkU29mdG1heENsYXNzaWZpY2F0aW9uQWdhaW5zdExvZ2l0c0xvc3MS",
            "GQoRYW5jaG9yd2lzZV9vdXRwdXQYASABKAgSEwoLbG9naXRfc2NhbGUYAiAB",
            "KAIiaQolQm9vdHN0cmFwcGVkU2lnbW9pZENsYXNzaWZpY2F0aW9uTG9zcxIN",
            "CgVhbHBoYRgBIAEoAhIWCg5oYXJkX2Jvb3RzdHJhcBgCIAEoCBIZChFhbmNo",
            "b3J3aXNlX291dHB1dBgDIAEoCCKMAgoQSGFyZEV4YW1wbGVNaW5lchIZChFu",
            "dW1faGFyZF9leGFtcGxlcxgBIAEoBRIVCg1pb3VfdGhyZXNob2xkGAIgASgC",
            "EkUKCWxvc3NfdHlwZRgDIAEoDjIyLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9z",
            "LkhhcmRFeGFtcGxlTWluZXIuTG9zc1R5cGUSIgoabWF4X25lZ2F0aXZlc19w",
            "ZXJfcG9zaXRpdmUYBCABKAUSHwoXbWluX25lZ2F0aXZlc19wZXJfaW1hZ2UY",
            "BSABKAUiOgoITG9zc1R5cGUSCAoEQk9USBAAEhIKDkNMQVNTSUZJQ0FUSU9O",
            "EAESEAoMTE9DQUxJWkFUSU9OEAIiOAoUUmFuZG9tRXhhbXBsZVNhbXBsZXIS",
            "IAoYcG9zaXRpdmVfc2FtcGxlX2ZyYWN0aW9uGAEgASgCYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.Loss), global::Tensorflow.Models.ObjectDetection.Protos.Loss.Parser, new[]{ "LocalizationLoss", "ClassificationLoss", "HardExampleMiner", "ClassificationWeight", "LocalizationWeight", "RandomExampleSampler", "EqualizationLoss", "ExpectedLossWeights", "MinNumNegativeSamples", "DesiredNegativeSamplingRatio" }, null, new[]{ typeof(global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.ExpectedLossWeights) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.EqualizationLoss), global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.EqualizationLoss.Parser, new[]{ "Weight", "ExcludePrefixes" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.LocalizationLoss), global::Tensorflow.Models.ObjectDetection.Protos.LocalizationLoss.Parser, new[]{ "WeightedL2", "WeightedSmoothL1", "WeightedIou" }, new[]{ "LocalizationLoss" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightedL2LocalizationLoss), global::Tensorflow.Models.ObjectDetection.Protos.WeightedL2LocalizationLoss.Parser, new[]{ "AnchorwiseOutput" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightedSmoothL1LocalizationLoss), global::Tensorflow.Models.ObjectDetection.Protos.WeightedSmoothL1LocalizationLoss.Parser, new[]{ "AnchorwiseOutput", "Delta" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightedIOULocalizationLoss), global::Tensorflow.Models.ObjectDetection.Protos.WeightedIOULocalizationLoss.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.ClassificationLoss), global::Tensorflow.Models.ObjectDetection.Protos.ClassificationLoss.Parser, new[]{ "WeightedSigmoid", "WeightedSoftmax", "WeightedLogitsSoftmax", "BootstrappedSigmoid", "WeightedSigmoidFocal" }, new[]{ "ClassificationLoss" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightedSigmoidClassificationLoss), global::Tensorflow.Models.ObjectDetection.Protos.WeightedSigmoidClassificationLoss.Parser, new[]{ "AnchorwiseOutput" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SigmoidFocalClassificationLoss), global::Tensorflow.Models.ObjectDetection.Protos.SigmoidFocalClassificationLoss.Parser, new[]{ "AnchorwiseOutput", "Gamma", "Alpha" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationLoss), global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationLoss.Parser, new[]{ "AnchorwiseOutput", "LogitScale" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationAgainstLogitsLoss), global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationAgainstLogitsLoss.Parser, new[]{ "AnchorwiseOutput", "LogitScale" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.BootstrappedSigmoidClassificationLoss), global::Tensorflow.Models.ObjectDetection.Protos.BootstrappedSigmoidClassificationLoss.Parser, new[]{ "Alpha", "HardBootstrap", "AnchorwiseOutput" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner), global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner.Parser, new[]{ "NumHardExamples", "IouThreshold", "LossType", "MaxNegativesPerPositive", "MinNegativesPerImage" }, null, new[]{ typeof(global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner.Types.LossType) }, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.RandomExampleSampler), global::Tensorflow.Models.ObjectDetection.Protos.RandomExampleSampler.Parser, new[]{ "PositiveSampleFraction" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Message for configuring the localization loss, classification loss and hard
  /// example miner used for training object detection models. See core/losses.py
  /// for details
  /// </summary>
  public sealed partial class Loss : pb::IMessage<Loss> {
    private static readonly pb::MessageParser<Loss> _parser = new pb::MessageParser<Loss>(() => new Loss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Loss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Loss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Loss(Loss other) : this() {
      localizationLoss_ = other.localizationLoss_ != null ? other.localizationLoss_.Clone() : null;
      classificationLoss_ = other.classificationLoss_ != null ? other.classificationLoss_.Clone() : null;
      hardExampleMiner_ = other.hardExampleMiner_ != null ? other.hardExampleMiner_.Clone() : null;
      classificationWeight_ = other.classificationWeight_;
      localizationWeight_ = other.localizationWeight_;
      randomExampleSampler_ = other.randomExampleSampler_ != null ? other.randomExampleSampler_.Clone() : null;
      equalizationLoss_ = other.equalizationLoss_ != null ? other.equalizationLoss_.Clone() : null;
      expectedLossWeights_ = other.expectedLossWeights_;
      minNumNegativeSamples_ = other.minNumNegativeSamples_;
      desiredNegativeSamplingRatio_ = other.desiredNegativeSamplingRatio_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Loss Clone() {
      return new Loss(this);
    }

    /// <summary>Field number for the "localization_loss" field.</summary>
    public const int LocalizationLossFieldNumber = 1;
    private global::Tensorflow.Models.ObjectDetection.Protos.LocalizationLoss localizationLoss_;
    /// <summary>
    /// Localization loss to use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.LocalizationLoss LocalizationLoss {
      get { return localizationLoss_; }
      set {
        localizationLoss_ = value;
      }
    }

    /// <summary>Field number for the "classification_loss" field.</summary>
    public const int ClassificationLossFieldNumber = 2;
    private global::Tensorflow.Models.ObjectDetection.Protos.ClassificationLoss classificationLoss_;
    /// <summary>
    /// Classification loss to use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ClassificationLoss ClassificationLoss {
      get { return classificationLoss_; }
      set {
        classificationLoss_ = value;
      }
    }

    /// <summary>Field number for the "hard_example_miner" field.</summary>
    public const int HardExampleMinerFieldNumber = 3;
    private global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner hardExampleMiner_;
    /// <summary>
    /// If not left to default, applies hard example mining.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner HardExampleMiner {
      get { return hardExampleMiner_; }
      set {
        hardExampleMiner_ = value;
      }
    }

    /// <summary>Field number for the "classification_weight" field.</summary>
    public const int ClassificationWeightFieldNumber = 4;
    private float classificationWeight_;
    /// <summary>
    /// Classification loss weight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ClassificationWeight {
      get { return classificationWeight_; }
      set {
        classificationWeight_ = value;
      }
    }

    /// <summary>Field number for the "localization_weight" field.</summary>
    public const int LocalizationWeightFieldNumber = 5;
    private float localizationWeight_;
    /// <summary>
    /// Localization loss weight.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LocalizationWeight {
      get { return localizationWeight_; }
      set {
        localizationWeight_ = value;
      }
    }

    /// <summary>Field number for the "random_example_sampler" field.</summary>
    public const int RandomExampleSamplerFieldNumber = 6;
    private global::Tensorflow.Models.ObjectDetection.Protos.RandomExampleSampler randomExampleSampler_;
    /// <summary>
    /// If not left to default, applies random example sampling.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RandomExampleSampler RandomExampleSampler {
      get { return randomExampleSampler_; }
      set {
        randomExampleSampler_ = value;
      }
    }

    /// <summary>Field number for the "equalization_loss" field.</summary>
    public const int EqualizationLossFieldNumber = 7;
    private global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.EqualizationLoss equalizationLoss_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.EqualizationLoss EqualizationLoss {
      get { return equalizationLoss_; }
      set {
        equalizationLoss_ = value;
      }
    }

    /// <summary>Field number for the "expected_loss_weights" field.</summary>
    public const int ExpectedLossWeightsFieldNumber = 18;
    private global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.ExpectedLossWeights expectedLossWeights_ = 0;
    /// <summary>
    /// Method to compute expected loss weights with respect to balanced
    /// positive/negative sampling scheme. If NONE, use explicit sampling.
    /// TODO(birdbrain): Move under ExpectedLossWeights.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.ExpectedLossWeights ExpectedLossWeights {
      get { return expectedLossWeights_; }
      set {
        expectedLossWeights_ = value;
      }
    }

    /// <summary>Field number for the "min_num_negative_samples" field.</summary>
    public const int MinNumNegativeSamplesFieldNumber = 19;
    private float minNumNegativeSamples_;
    /// <summary>
    /// Minimum number of effective negative samples.
    /// Only applies if expected_loss_weights is not NONE.
    /// TODO(birdbrain): Move under ExpectedLossWeights.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float MinNumNegativeSamples {
      get { return minNumNegativeSamples_; }
      set {
        minNumNegativeSamples_ = value;
      }
    }

    /// <summary>Field number for the "desired_negative_sampling_ratio" field.</summary>
    public const int DesiredNegativeSamplingRatioFieldNumber = 20;
    private float desiredNegativeSamplingRatio_;
    /// <summary>
    /// Desired number of effective negative samples per positive sample.
    /// Only applies if expected_loss_weights is not NONE.
    /// TODO(birdbrain): Move under ExpectedLossWeights.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DesiredNegativeSamplingRatio {
      get { return desiredNegativeSamplingRatio_; }
      set {
        desiredNegativeSamplingRatio_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Loss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Loss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(LocalizationLoss, other.LocalizationLoss)) return false;
      if (!object.Equals(ClassificationLoss, other.ClassificationLoss)) return false;
      if (!object.Equals(HardExampleMiner, other.HardExampleMiner)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ClassificationWeight, other.ClassificationWeight)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LocalizationWeight, other.LocalizationWeight)) return false;
      if (!object.Equals(RandomExampleSampler, other.RandomExampleSampler)) return false;
      if (!object.Equals(EqualizationLoss, other.EqualizationLoss)) return false;
      if (ExpectedLossWeights != other.ExpectedLossWeights) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MinNumNegativeSamples, other.MinNumNegativeSamples)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DesiredNegativeSamplingRatio, other.DesiredNegativeSamplingRatio)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (localizationLoss_ != null) hash ^= LocalizationLoss.GetHashCode();
      if (classificationLoss_ != null) hash ^= ClassificationLoss.GetHashCode();
      if (hardExampleMiner_ != null) hash ^= HardExampleMiner.GetHashCode();
      if (ClassificationWeight != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ClassificationWeight);
      if (LocalizationWeight != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LocalizationWeight);
      if (randomExampleSampler_ != null) hash ^= RandomExampleSampler.GetHashCode();
      if (equalizationLoss_ != null) hash ^= EqualizationLoss.GetHashCode();
      if (ExpectedLossWeights != 0) hash ^= ExpectedLossWeights.GetHashCode();
      if (MinNumNegativeSamples != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MinNumNegativeSamples);
      if (DesiredNegativeSamplingRatio != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DesiredNegativeSamplingRatio);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (localizationLoss_ != null) {
        output.WriteRawTag(10);
        output.WriteMessage(LocalizationLoss);
      }
      if (classificationLoss_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ClassificationLoss);
      }
      if (hardExampleMiner_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(HardExampleMiner);
      }
      if (ClassificationWeight != 0F) {
        output.WriteRawTag(37);
        output.WriteFloat(ClassificationWeight);
      }
      if (LocalizationWeight != 0F) {
        output.WriteRawTag(45);
        output.WriteFloat(LocalizationWeight);
      }
      if (randomExampleSampler_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(RandomExampleSampler);
      }
      if (equalizationLoss_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(EqualizationLoss);
      }
      if (ExpectedLossWeights != 0) {
        output.WriteRawTag(144, 1);
        output.WriteEnum((int) ExpectedLossWeights);
      }
      if (MinNumNegativeSamples != 0F) {
        output.WriteRawTag(157, 1);
        output.WriteFloat(MinNumNegativeSamples);
      }
      if (DesiredNegativeSamplingRatio != 0F) {
        output.WriteRawTag(165, 1);
        output.WriteFloat(DesiredNegativeSamplingRatio);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (localizationLoss_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(LocalizationLoss);
      }
      if (classificationLoss_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ClassificationLoss);
      }
      if (hardExampleMiner_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HardExampleMiner);
      }
      if (ClassificationWeight != 0F) {
        size += 1 + 4;
      }
      if (LocalizationWeight != 0F) {
        size += 1 + 4;
      }
      if (randomExampleSampler_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(RandomExampleSampler);
      }
      if (equalizationLoss_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(EqualizationLoss);
      }
      if (ExpectedLossWeights != 0) {
        size += 2 + pb::CodedOutputStream.ComputeEnumSize((int) ExpectedLossWeights);
      }
      if (MinNumNegativeSamples != 0F) {
        size += 2 + 4;
      }
      if (DesiredNegativeSamplingRatio != 0F) {
        size += 2 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Loss other) {
      if (other == null) {
        return;
      }
      if (other.localizationLoss_ != null) {
        if (localizationLoss_ == null) {
          localizationLoss_ = new global::Tensorflow.Models.ObjectDetection.Protos.LocalizationLoss();
        }
        LocalizationLoss.MergeFrom(other.LocalizationLoss);
      }
      if (other.classificationLoss_ != null) {
        if (classificationLoss_ == null) {
          classificationLoss_ = new global::Tensorflow.Models.ObjectDetection.Protos.ClassificationLoss();
        }
        ClassificationLoss.MergeFrom(other.ClassificationLoss);
      }
      if (other.hardExampleMiner_ != null) {
        if (hardExampleMiner_ == null) {
          hardExampleMiner_ = new global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner();
        }
        HardExampleMiner.MergeFrom(other.HardExampleMiner);
      }
      if (other.ClassificationWeight != 0F) {
        ClassificationWeight = other.ClassificationWeight;
      }
      if (other.LocalizationWeight != 0F) {
        LocalizationWeight = other.LocalizationWeight;
      }
      if (other.randomExampleSampler_ != null) {
        if (randomExampleSampler_ == null) {
          randomExampleSampler_ = new global::Tensorflow.Models.ObjectDetection.Protos.RandomExampleSampler();
        }
        RandomExampleSampler.MergeFrom(other.RandomExampleSampler);
      }
      if (other.equalizationLoss_ != null) {
        if (equalizationLoss_ == null) {
          equalizationLoss_ = new global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.EqualizationLoss();
        }
        EqualizationLoss.MergeFrom(other.EqualizationLoss);
      }
      if (other.ExpectedLossWeights != 0) {
        ExpectedLossWeights = other.ExpectedLossWeights;
      }
      if (other.MinNumNegativeSamples != 0F) {
        MinNumNegativeSamples = other.MinNumNegativeSamples;
      }
      if (other.DesiredNegativeSamplingRatio != 0F) {
        DesiredNegativeSamplingRatio = other.DesiredNegativeSamplingRatio;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            if (localizationLoss_ == null) {
              localizationLoss_ = new global::Tensorflow.Models.ObjectDetection.Protos.LocalizationLoss();
            }
            input.ReadMessage(localizationLoss_);
            break;
          }
          case 18: {
            if (classificationLoss_ == null) {
              classificationLoss_ = new global::Tensorflow.Models.ObjectDetection.Protos.ClassificationLoss();
            }
            input.ReadMessage(classificationLoss_);
            break;
          }
          case 26: {
            if (hardExampleMiner_ == null) {
              hardExampleMiner_ = new global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner();
            }
            input.ReadMessage(hardExampleMiner_);
            break;
          }
          case 37: {
            ClassificationWeight = input.ReadFloat();
            break;
          }
          case 45: {
            LocalizationWeight = input.ReadFloat();
            break;
          }
          case 50: {
            if (randomExampleSampler_ == null) {
              randomExampleSampler_ = new global::Tensorflow.Models.ObjectDetection.Protos.RandomExampleSampler();
            }
            input.ReadMessage(randomExampleSampler_);
            break;
          }
          case 58: {
            if (equalizationLoss_ == null) {
              equalizationLoss_ = new global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.EqualizationLoss();
            }
            input.ReadMessage(equalizationLoss_);
            break;
          }
          case 144: {
            expectedLossWeights_ = (global::Tensorflow.Models.ObjectDetection.Protos.Loss.Types.ExpectedLossWeights) input.ReadEnum();
            break;
          }
          case 157: {
            MinNumNegativeSamples = input.ReadFloat();
            break;
          }
          case 165: {
            DesiredNegativeSamplingRatio = input.ReadFloat();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Loss message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum ExpectedLossWeights {
        [pbr::OriginalName("NONE")] None = 0,
        /// <summary>
        /// Use expected_classification_loss_by_expected_sampling
        /// from third_party/tensorflow_models/object_detection/utils/ops.py
        /// </summary>
        [pbr::OriginalName("EXPECTED_SAMPLING")] ExpectedSampling = 1,
        /// <summary>
        /// Use expected_classification_loss_by_reweighting_unmatched_anchors
        /// from third_party/tensorflow_models/object_detection/utils/ops.py
        /// </summary>
        [pbr::OriginalName("REWEIGHTING_UNMATCHED_ANCHORS")] ReweightingUnmatchedAnchors = 2,
      }

      /// <summary>
      /// Equalization loss.
      /// </summary>
      public sealed partial class EqualizationLoss : pb::IMessage<EqualizationLoss> {
        private static readonly pb::MessageParser<EqualizationLoss> _parser = new pb::MessageParser<EqualizationLoss>(() => new EqualizationLoss());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<EqualizationLoss> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.Models.ObjectDetection.Protos.Loss.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EqualizationLoss() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EqualizationLoss(EqualizationLoss other) : this() {
          weight_ = other.weight_;
          excludePrefixes_ = other.excludePrefixes_.Clone();
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public EqualizationLoss Clone() {
          return new EqualizationLoss(this);
        }

        /// <summary>Field number for the "weight" field.</summary>
        public const int WeightFieldNumber = 1;
        private float weight_;
        /// <summary>
        /// Weight equalization loss strength.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float Weight {
          get { return weight_; }
          set {
            weight_ = value;
          }
        }

        /// <summary>Field number for the "exclude_prefixes" field.</summary>
        public const int ExcludePrefixesFieldNumber = 2;
        private static readonly pb::FieldCodec<string> _repeated_excludePrefixes_codec
            = pb::FieldCodec.ForString(18);
        private readonly pbc::RepeatedField<string> excludePrefixes_ = new pbc::RepeatedField<string>();
        /// <summary>
        /// When computing equalization loss, ops that start with
        /// equalization_exclude_prefixes will be ignored. Only used when
        /// equalization_weight > 0.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<string> ExcludePrefixes {
          get { return excludePrefixes_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as EqualizationLoss);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(EqualizationLoss other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Weight, other.Weight)) return false;
          if(!excludePrefixes_.Equals(other.excludePrefixes_)) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Weight != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Weight);
          hash ^= excludePrefixes_.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Weight != 0F) {
            output.WriteRawTag(13);
            output.WriteFloat(Weight);
          }
          excludePrefixes_.WriteTo(output, _repeated_excludePrefixes_codec);
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Weight != 0F) {
            size += 1 + 4;
          }
          size += excludePrefixes_.CalculateSize(_repeated_excludePrefixes_codec);
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(EqualizationLoss other) {
          if (other == null) {
            return;
          }
          if (other.Weight != 0F) {
            Weight = other.Weight;
          }
          excludePrefixes_.Add(other.excludePrefixes_);
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 13: {
                Weight = input.ReadFloat();
                break;
              }
              case 18: {
                excludePrefixes_.AddEntriesFrom(input, _repeated_excludePrefixes_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// Configuration for bounding box localization loss function.
  /// </summary>
  public sealed partial class LocalizationLoss : pb::IMessage<LocalizationLoss> {
    private static readonly pb::MessageParser<LocalizationLoss> _parser = new pb::MessageParser<LocalizationLoss>(() => new LocalizationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LocalizationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LocalizationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LocalizationLoss(LocalizationLoss other) : this() {
      switch (other.LocalizationLossCase) {
        case LocalizationLossOneofCase.WeightedL2:
          WeightedL2 = other.WeightedL2.Clone();
          break;
        case LocalizationLossOneofCase.WeightedSmoothL1:
          WeightedSmoothL1 = other.WeightedSmoothL1.Clone();
          break;
        case LocalizationLossOneofCase.WeightedIou:
          WeightedIou = other.WeightedIou.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LocalizationLoss Clone() {
      return new LocalizationLoss(this);
    }

    /// <summary>Field number for the "weighted_l2" field.</summary>
    public const int WeightedL2FieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightedL2LocalizationLoss WeightedL2 {
      get { return localizationLossCase_ == LocalizationLossOneofCase.WeightedL2 ? (global::Tensorflow.Models.ObjectDetection.Protos.WeightedL2LocalizationLoss) localizationLoss_ : null; }
      set {
        localizationLoss_ = value;
        localizationLossCase_ = value == null ? LocalizationLossOneofCase.None : LocalizationLossOneofCase.WeightedL2;
      }
    }

    /// <summary>Field number for the "weighted_smooth_l1" field.</summary>
    public const int WeightedSmoothL1FieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightedSmoothL1LocalizationLoss WeightedSmoothL1 {
      get { return localizationLossCase_ == LocalizationLossOneofCase.WeightedSmoothL1 ? (global::Tensorflow.Models.ObjectDetection.Protos.WeightedSmoothL1LocalizationLoss) localizationLoss_ : null; }
      set {
        localizationLoss_ = value;
        localizationLossCase_ = value == null ? LocalizationLossOneofCase.None : LocalizationLossOneofCase.WeightedSmoothL1;
      }
    }

    /// <summary>Field number for the "weighted_iou" field.</summary>
    public const int WeightedIouFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightedIOULocalizationLoss WeightedIou {
      get { return localizationLossCase_ == LocalizationLossOneofCase.WeightedIou ? (global::Tensorflow.Models.ObjectDetection.Protos.WeightedIOULocalizationLoss) localizationLoss_ : null; }
      set {
        localizationLoss_ = value;
        localizationLossCase_ = value == null ? LocalizationLossOneofCase.None : LocalizationLossOneofCase.WeightedIou;
      }
    }

    private object localizationLoss_;
    /// <summary>Enum of possible cases for the "localization_loss" oneof.</summary>
    public enum LocalizationLossOneofCase {
      None = 0,
      WeightedL2 = 1,
      WeightedSmoothL1 = 2,
      WeightedIou = 3,
    }
    private LocalizationLossOneofCase localizationLossCase_ = LocalizationLossOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LocalizationLossOneofCase LocalizationLossCase {
      get { return localizationLossCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearLocalizationLoss() {
      localizationLossCase_ = LocalizationLossOneofCase.None;
      localizationLoss_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LocalizationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LocalizationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(WeightedL2, other.WeightedL2)) return false;
      if (!object.Equals(WeightedSmoothL1, other.WeightedSmoothL1)) return false;
      if (!object.Equals(WeightedIou, other.WeightedIou)) return false;
      if (LocalizationLossCase != other.LocalizationLossCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedL2) hash ^= WeightedL2.GetHashCode();
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedSmoothL1) hash ^= WeightedSmoothL1.GetHashCode();
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedIou) hash ^= WeightedIou.GetHashCode();
      hash ^= (int) localizationLossCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedL2) {
        output.WriteRawTag(10);
        output.WriteMessage(WeightedL2);
      }
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedSmoothL1) {
        output.WriteRawTag(18);
        output.WriteMessage(WeightedSmoothL1);
      }
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedIou) {
        output.WriteRawTag(26);
        output.WriteMessage(WeightedIou);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedL2) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedL2);
      }
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedSmoothL1) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedSmoothL1);
      }
      if (localizationLossCase_ == LocalizationLossOneofCase.WeightedIou) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedIou);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LocalizationLoss other) {
      if (other == null) {
        return;
      }
      switch (other.LocalizationLossCase) {
        case LocalizationLossOneofCase.WeightedL2:
          if (WeightedL2 == null) {
            WeightedL2 = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedL2LocalizationLoss();
          }
          WeightedL2.MergeFrom(other.WeightedL2);
          break;
        case LocalizationLossOneofCase.WeightedSmoothL1:
          if (WeightedSmoothL1 == null) {
            WeightedSmoothL1 = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedSmoothL1LocalizationLoss();
          }
          WeightedSmoothL1.MergeFrom(other.WeightedSmoothL1);
          break;
        case LocalizationLossOneofCase.WeightedIou:
          if (WeightedIou == null) {
            WeightedIou = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedIOULocalizationLoss();
          }
          WeightedIou.MergeFrom(other.WeightedIou);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Tensorflow.Models.ObjectDetection.Protos.WeightedL2LocalizationLoss subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedL2LocalizationLoss();
            if (localizationLossCase_ == LocalizationLossOneofCase.WeightedL2) {
              subBuilder.MergeFrom(WeightedL2);
            }
            input.ReadMessage(subBuilder);
            WeightedL2 = subBuilder;
            break;
          }
          case 18: {
            global::Tensorflow.Models.ObjectDetection.Protos.WeightedSmoothL1LocalizationLoss subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedSmoothL1LocalizationLoss();
            if (localizationLossCase_ == LocalizationLossOneofCase.WeightedSmoothL1) {
              subBuilder.MergeFrom(WeightedSmoothL1);
            }
            input.ReadMessage(subBuilder);
            WeightedSmoothL1 = subBuilder;
            break;
          }
          case 26: {
            global::Tensorflow.Models.ObjectDetection.Protos.WeightedIOULocalizationLoss subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedIOULocalizationLoss();
            if (localizationLossCase_ == LocalizationLossOneofCase.WeightedIou) {
              subBuilder.MergeFrom(WeightedIou);
            }
            input.ReadMessage(subBuilder);
            WeightedIou = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// L2 location loss: 0.5 * ||weight * (a - b)|| ^ 2
  /// </summary>
  public sealed partial class WeightedL2LocalizationLoss : pb::IMessage<WeightedL2LocalizationLoss> {
    private static readonly pb::MessageParser<WeightedL2LocalizationLoss> _parser = new pb::MessageParser<WeightedL2LocalizationLoss>(() => new WeightedL2LocalizationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightedL2LocalizationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedL2LocalizationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedL2LocalizationLoss(WeightedL2LocalizationLoss other) : this() {
      anchorwiseOutput_ = other.anchorwiseOutput_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedL2LocalizationLoss Clone() {
      return new WeightedL2LocalizationLoss(this);
    }

    /// <summary>Field number for the "anchorwise_output" field.</summary>
    public const int AnchorwiseOutputFieldNumber = 1;
    private bool anchorwiseOutput_;
    /// <summary>
    /// DEPRECATED, do not use.
    /// Output loss per anchor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AnchorwiseOutput {
      get { return anchorwiseOutput_; }
      set {
        anchorwiseOutput_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightedL2LocalizationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightedL2LocalizationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AnchorwiseOutput != other.AnchorwiseOutput) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AnchorwiseOutput != false) hash ^= AnchorwiseOutput.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AnchorwiseOutput != false) {
        output.WriteRawTag(8);
        output.WriteBool(AnchorwiseOutput);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AnchorwiseOutput != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightedL2LocalizationLoss other) {
      if (other == null) {
        return;
      }
      if (other.AnchorwiseOutput != false) {
        AnchorwiseOutput = other.AnchorwiseOutput;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AnchorwiseOutput = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// SmoothL1 (Huber) location loss.
  /// The smooth L1_loss is defined elementwise as .5 x^2 if |x| &lt;= delta and
  /// delta * (|x|-0.5*delta) otherwise, where x is the difference between
  /// predictions and target.
  /// </summary>
  public sealed partial class WeightedSmoothL1LocalizationLoss : pb::IMessage<WeightedSmoothL1LocalizationLoss> {
    private static readonly pb::MessageParser<WeightedSmoothL1LocalizationLoss> _parser = new pb::MessageParser<WeightedSmoothL1LocalizationLoss>(() => new WeightedSmoothL1LocalizationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightedSmoothL1LocalizationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSmoothL1LocalizationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSmoothL1LocalizationLoss(WeightedSmoothL1LocalizationLoss other) : this() {
      anchorwiseOutput_ = other.anchorwiseOutput_;
      delta_ = other.delta_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSmoothL1LocalizationLoss Clone() {
      return new WeightedSmoothL1LocalizationLoss(this);
    }

    /// <summary>Field number for the "anchorwise_output" field.</summary>
    public const int AnchorwiseOutputFieldNumber = 1;
    private bool anchorwiseOutput_;
    /// <summary>
    /// DEPRECATED, do not use.
    /// Output loss per anchor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AnchorwiseOutput {
      get { return anchorwiseOutput_; }
      set {
        anchorwiseOutput_ = value;
      }
    }

    /// <summary>Field number for the "delta" field.</summary>
    public const int DeltaFieldNumber = 2;
    private float delta_;
    /// <summary>
    /// Delta value for huber loss.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Delta {
      get { return delta_; }
      set {
        delta_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightedSmoothL1LocalizationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightedSmoothL1LocalizationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AnchorwiseOutput != other.AnchorwiseOutput) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Delta, other.Delta)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AnchorwiseOutput != false) hash ^= AnchorwiseOutput.GetHashCode();
      if (Delta != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Delta);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AnchorwiseOutput != false) {
        output.WriteRawTag(8);
        output.WriteBool(AnchorwiseOutput);
      }
      if (Delta != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Delta);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AnchorwiseOutput != false) {
        size += 1 + 1;
      }
      if (Delta != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightedSmoothL1LocalizationLoss other) {
      if (other == null) {
        return;
      }
      if (other.AnchorwiseOutput != false) {
        AnchorwiseOutput = other.AnchorwiseOutput;
      }
      if (other.Delta != 0F) {
        Delta = other.Delta;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AnchorwiseOutput = input.ReadBool();
            break;
          }
          case 21: {
            Delta = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Intersection over union location loss: 1 - IOU
  /// </summary>
  public sealed partial class WeightedIOULocalizationLoss : pb::IMessage<WeightedIOULocalizationLoss> {
    private static readonly pb::MessageParser<WeightedIOULocalizationLoss> _parser = new pb::MessageParser<WeightedIOULocalizationLoss>(() => new WeightedIOULocalizationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightedIOULocalizationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedIOULocalizationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedIOULocalizationLoss(WeightedIOULocalizationLoss other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedIOULocalizationLoss Clone() {
      return new WeightedIOULocalizationLoss(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightedIOULocalizationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightedIOULocalizationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightedIOULocalizationLoss other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  /// <summary>
  /// Configuration for class prediction loss function.
  /// </summary>
  public sealed partial class ClassificationLoss : pb::IMessage<ClassificationLoss> {
    private static readonly pb::MessageParser<ClassificationLoss> _parser = new pb::MessageParser<ClassificationLoss>(() => new ClassificationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ClassificationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClassificationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClassificationLoss(ClassificationLoss other) : this() {
      switch (other.ClassificationLossCase) {
        case ClassificationLossOneofCase.WeightedSigmoid:
          WeightedSigmoid = other.WeightedSigmoid.Clone();
          break;
        case ClassificationLossOneofCase.WeightedSoftmax:
          WeightedSoftmax = other.WeightedSoftmax.Clone();
          break;
        case ClassificationLossOneofCase.WeightedLogitsSoftmax:
          WeightedLogitsSoftmax = other.WeightedLogitsSoftmax.Clone();
          break;
        case ClassificationLossOneofCase.BootstrappedSigmoid:
          BootstrappedSigmoid = other.BootstrappedSigmoid.Clone();
          break;
        case ClassificationLossOneofCase.WeightedSigmoidFocal:
          WeightedSigmoidFocal = other.WeightedSigmoidFocal.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClassificationLoss Clone() {
      return new ClassificationLoss(this);
    }

    /// <summary>Field number for the "weighted_sigmoid" field.</summary>
    public const int WeightedSigmoidFieldNumber = 1;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightedSigmoidClassificationLoss WeightedSigmoid {
      get { return classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoid ? (global::Tensorflow.Models.ObjectDetection.Protos.WeightedSigmoidClassificationLoss) classificationLoss_ : null; }
      set {
        classificationLoss_ = value;
        classificationLossCase_ = value == null ? ClassificationLossOneofCase.None : ClassificationLossOneofCase.WeightedSigmoid;
      }
    }

    /// <summary>Field number for the "weighted_softmax" field.</summary>
    public const int WeightedSoftmaxFieldNumber = 2;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationLoss WeightedSoftmax {
      get { return classificationLossCase_ == ClassificationLossOneofCase.WeightedSoftmax ? (global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationLoss) classificationLoss_ : null; }
      set {
        classificationLoss_ = value;
        classificationLossCase_ = value == null ? ClassificationLossOneofCase.None : ClassificationLossOneofCase.WeightedSoftmax;
      }
    }

    /// <summary>Field number for the "weighted_logits_softmax" field.</summary>
    public const int WeightedLogitsSoftmaxFieldNumber = 5;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationAgainstLogitsLoss WeightedLogitsSoftmax {
      get { return classificationLossCase_ == ClassificationLossOneofCase.WeightedLogitsSoftmax ? (global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationAgainstLogitsLoss) classificationLoss_ : null; }
      set {
        classificationLoss_ = value;
        classificationLossCase_ = value == null ? ClassificationLossOneofCase.None : ClassificationLossOneofCase.WeightedLogitsSoftmax;
      }
    }

    /// <summary>Field number for the "bootstrapped_sigmoid" field.</summary>
    public const int BootstrappedSigmoidFieldNumber = 3;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.BootstrappedSigmoidClassificationLoss BootstrappedSigmoid {
      get { return classificationLossCase_ == ClassificationLossOneofCase.BootstrappedSigmoid ? (global::Tensorflow.Models.ObjectDetection.Protos.BootstrappedSigmoidClassificationLoss) classificationLoss_ : null; }
      set {
        classificationLoss_ = value;
        classificationLossCase_ = value == null ? ClassificationLossOneofCase.None : ClassificationLossOneofCase.BootstrappedSigmoid;
      }
    }

    /// <summary>Field number for the "weighted_sigmoid_focal" field.</summary>
    public const int WeightedSigmoidFocalFieldNumber = 4;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.SigmoidFocalClassificationLoss WeightedSigmoidFocal {
      get { return classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoidFocal ? (global::Tensorflow.Models.ObjectDetection.Protos.SigmoidFocalClassificationLoss) classificationLoss_ : null; }
      set {
        classificationLoss_ = value;
        classificationLossCase_ = value == null ? ClassificationLossOneofCase.None : ClassificationLossOneofCase.WeightedSigmoidFocal;
      }
    }

    private object classificationLoss_;
    /// <summary>Enum of possible cases for the "classification_loss" oneof.</summary>
    public enum ClassificationLossOneofCase {
      None = 0,
      WeightedSigmoid = 1,
      WeightedSoftmax = 2,
      WeightedLogitsSoftmax = 5,
      BootstrappedSigmoid = 3,
      WeightedSigmoidFocal = 4,
    }
    private ClassificationLossOneofCase classificationLossCase_ = ClassificationLossOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ClassificationLossOneofCase ClassificationLossCase {
      get { return classificationLossCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearClassificationLoss() {
      classificationLossCase_ = ClassificationLossOneofCase.None;
      classificationLoss_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ClassificationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ClassificationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(WeightedSigmoid, other.WeightedSigmoid)) return false;
      if (!object.Equals(WeightedSoftmax, other.WeightedSoftmax)) return false;
      if (!object.Equals(WeightedLogitsSoftmax, other.WeightedLogitsSoftmax)) return false;
      if (!object.Equals(BootstrappedSigmoid, other.BootstrappedSigmoid)) return false;
      if (!object.Equals(WeightedSigmoidFocal, other.WeightedSigmoidFocal)) return false;
      if (ClassificationLossCase != other.ClassificationLossCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoid) hash ^= WeightedSigmoid.GetHashCode();
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSoftmax) hash ^= WeightedSoftmax.GetHashCode();
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedLogitsSoftmax) hash ^= WeightedLogitsSoftmax.GetHashCode();
      if (classificationLossCase_ == ClassificationLossOneofCase.BootstrappedSigmoid) hash ^= BootstrappedSigmoid.GetHashCode();
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoidFocal) hash ^= WeightedSigmoidFocal.GetHashCode();
      hash ^= (int) classificationLossCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoid) {
        output.WriteRawTag(10);
        output.WriteMessage(WeightedSigmoid);
      }
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSoftmax) {
        output.WriteRawTag(18);
        output.WriteMessage(WeightedSoftmax);
      }
      if (classificationLossCase_ == ClassificationLossOneofCase.BootstrappedSigmoid) {
        output.WriteRawTag(26);
        output.WriteMessage(BootstrappedSigmoid);
      }
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoidFocal) {
        output.WriteRawTag(34);
        output.WriteMessage(WeightedSigmoidFocal);
      }
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedLogitsSoftmax) {
        output.WriteRawTag(42);
        output.WriteMessage(WeightedLogitsSoftmax);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoid) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedSigmoid);
      }
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSoftmax) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedSoftmax);
      }
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedLogitsSoftmax) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedLogitsSoftmax);
      }
      if (classificationLossCase_ == ClassificationLossOneofCase.BootstrappedSigmoid) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BootstrappedSigmoid);
      }
      if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoidFocal) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(WeightedSigmoidFocal);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ClassificationLoss other) {
      if (other == null) {
        return;
      }
      switch (other.ClassificationLossCase) {
        case ClassificationLossOneofCase.WeightedSigmoid:
          if (WeightedSigmoid == null) {
            WeightedSigmoid = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedSigmoidClassificationLoss();
          }
          WeightedSigmoid.MergeFrom(other.WeightedSigmoid);
          break;
        case ClassificationLossOneofCase.WeightedSoftmax:
          if (WeightedSoftmax == null) {
            WeightedSoftmax = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationLoss();
          }
          WeightedSoftmax.MergeFrom(other.WeightedSoftmax);
          break;
        case ClassificationLossOneofCase.WeightedLogitsSoftmax:
          if (WeightedLogitsSoftmax == null) {
            WeightedLogitsSoftmax = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationAgainstLogitsLoss();
          }
          WeightedLogitsSoftmax.MergeFrom(other.WeightedLogitsSoftmax);
          break;
        case ClassificationLossOneofCase.BootstrappedSigmoid:
          if (BootstrappedSigmoid == null) {
            BootstrappedSigmoid = new global::Tensorflow.Models.ObjectDetection.Protos.BootstrappedSigmoidClassificationLoss();
          }
          BootstrappedSigmoid.MergeFrom(other.BootstrappedSigmoid);
          break;
        case ClassificationLossOneofCase.WeightedSigmoidFocal:
          if (WeightedSigmoidFocal == null) {
            WeightedSigmoidFocal = new global::Tensorflow.Models.ObjectDetection.Protos.SigmoidFocalClassificationLoss();
          }
          WeightedSigmoidFocal.MergeFrom(other.WeightedSigmoidFocal);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            global::Tensorflow.Models.ObjectDetection.Protos.WeightedSigmoidClassificationLoss subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedSigmoidClassificationLoss();
            if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoid) {
              subBuilder.MergeFrom(WeightedSigmoid);
            }
            input.ReadMessage(subBuilder);
            WeightedSigmoid = subBuilder;
            break;
          }
          case 18: {
            global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationLoss subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationLoss();
            if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSoftmax) {
              subBuilder.MergeFrom(WeightedSoftmax);
            }
            input.ReadMessage(subBuilder);
            WeightedSoftmax = subBuilder;
            break;
          }
          case 26: {
            global::Tensorflow.Models.ObjectDetection.Protos.BootstrappedSigmoidClassificationLoss subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.BootstrappedSigmoidClassificationLoss();
            if (classificationLossCase_ == ClassificationLossOneofCase.BootstrappedSigmoid) {
              subBuilder.MergeFrom(BootstrappedSigmoid);
            }
            input.ReadMessage(subBuilder);
            BootstrappedSigmoid = subBuilder;
            break;
          }
          case 34: {
            global::Tensorflow.Models.ObjectDetection.Protos.SigmoidFocalClassificationLoss subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.SigmoidFocalClassificationLoss();
            if (classificationLossCase_ == ClassificationLossOneofCase.WeightedSigmoidFocal) {
              subBuilder.MergeFrom(WeightedSigmoidFocal);
            }
            input.ReadMessage(subBuilder);
            WeightedSigmoidFocal = subBuilder;
            break;
          }
          case 42: {
            global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationAgainstLogitsLoss subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.WeightedSoftmaxClassificationAgainstLogitsLoss();
            if (classificationLossCase_ == ClassificationLossOneofCase.WeightedLogitsSoftmax) {
              subBuilder.MergeFrom(WeightedLogitsSoftmax);
            }
            input.ReadMessage(subBuilder);
            WeightedLogitsSoftmax = subBuilder;
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Classification loss using a sigmoid function over class predictions.
  /// </summary>
  public sealed partial class WeightedSigmoidClassificationLoss : pb::IMessage<WeightedSigmoidClassificationLoss> {
    private static readonly pb::MessageParser<WeightedSigmoidClassificationLoss> _parser = new pb::MessageParser<WeightedSigmoidClassificationLoss>(() => new WeightedSigmoidClassificationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightedSigmoidClassificationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSigmoidClassificationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSigmoidClassificationLoss(WeightedSigmoidClassificationLoss other) : this() {
      anchorwiseOutput_ = other.anchorwiseOutput_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSigmoidClassificationLoss Clone() {
      return new WeightedSigmoidClassificationLoss(this);
    }

    /// <summary>Field number for the "anchorwise_output" field.</summary>
    public const int AnchorwiseOutputFieldNumber = 1;
    private bool anchorwiseOutput_;
    /// <summary>
    /// DEPRECATED, do not use.
    /// Output loss per anchor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AnchorwiseOutput {
      get { return anchorwiseOutput_; }
      set {
        anchorwiseOutput_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightedSigmoidClassificationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightedSigmoidClassificationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AnchorwiseOutput != other.AnchorwiseOutput) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AnchorwiseOutput != false) hash ^= AnchorwiseOutput.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AnchorwiseOutput != false) {
        output.WriteRawTag(8);
        output.WriteBool(AnchorwiseOutput);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AnchorwiseOutput != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightedSigmoidClassificationLoss other) {
      if (other == null) {
        return;
      }
      if (other.AnchorwiseOutput != false) {
        AnchorwiseOutput = other.AnchorwiseOutput;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AnchorwiseOutput = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Sigmoid Focal cross entropy loss as described in
  /// https://arxiv.org/abs/1708.02002
  /// </summary>
  public sealed partial class SigmoidFocalClassificationLoss : pb::IMessage<SigmoidFocalClassificationLoss> {
    private static readonly pb::MessageParser<SigmoidFocalClassificationLoss> _parser = new pb::MessageParser<SigmoidFocalClassificationLoss>(() => new SigmoidFocalClassificationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SigmoidFocalClassificationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SigmoidFocalClassificationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SigmoidFocalClassificationLoss(SigmoidFocalClassificationLoss other) : this() {
      anchorwiseOutput_ = other.anchorwiseOutput_;
      gamma_ = other.gamma_;
      alpha_ = other.alpha_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SigmoidFocalClassificationLoss Clone() {
      return new SigmoidFocalClassificationLoss(this);
    }

    /// <summary>Field number for the "anchorwise_output" field.</summary>
    public const int AnchorwiseOutputFieldNumber = 1;
    private bool anchorwiseOutput_;
    /// <summary>
    /// DEPRECATED, do not use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AnchorwiseOutput {
      get { return anchorwiseOutput_; }
      set {
        anchorwiseOutput_ = value;
      }
    }

    /// <summary>Field number for the "gamma" field.</summary>
    public const int GammaFieldNumber = 2;
    private float gamma_;
    /// <summary>
    /// modulating factor for the loss.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Gamma {
      get { return gamma_; }
      set {
        gamma_ = value;
      }
    }

    /// <summary>Field number for the "alpha" field.</summary>
    public const int AlphaFieldNumber = 3;
    private float alpha_;
    /// <summary>
    /// alpha weighting factor for the loss.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Alpha {
      get { return alpha_; }
      set {
        alpha_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SigmoidFocalClassificationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SigmoidFocalClassificationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AnchorwiseOutput != other.AnchorwiseOutput) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Gamma, other.Gamma)) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Alpha, other.Alpha)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AnchorwiseOutput != false) hash ^= AnchorwiseOutput.GetHashCode();
      if (Gamma != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Gamma);
      if (Alpha != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Alpha);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AnchorwiseOutput != false) {
        output.WriteRawTag(8);
        output.WriteBool(AnchorwiseOutput);
      }
      if (Gamma != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(Gamma);
      }
      if (Alpha != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(Alpha);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AnchorwiseOutput != false) {
        size += 1 + 1;
      }
      if (Gamma != 0F) {
        size += 1 + 4;
      }
      if (Alpha != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SigmoidFocalClassificationLoss other) {
      if (other == null) {
        return;
      }
      if (other.AnchorwiseOutput != false) {
        AnchorwiseOutput = other.AnchorwiseOutput;
      }
      if (other.Gamma != 0F) {
        Gamma = other.Gamma;
      }
      if (other.Alpha != 0F) {
        Alpha = other.Alpha;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AnchorwiseOutput = input.ReadBool();
            break;
          }
          case 21: {
            Gamma = input.ReadFloat();
            break;
          }
          case 29: {
            Alpha = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Classification loss using a softmax function over class predictions.
  /// </summary>
  public sealed partial class WeightedSoftmaxClassificationLoss : pb::IMessage<WeightedSoftmaxClassificationLoss> {
    private static readonly pb::MessageParser<WeightedSoftmaxClassificationLoss> _parser = new pb::MessageParser<WeightedSoftmaxClassificationLoss>(() => new WeightedSoftmaxClassificationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightedSoftmaxClassificationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSoftmaxClassificationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSoftmaxClassificationLoss(WeightedSoftmaxClassificationLoss other) : this() {
      anchorwiseOutput_ = other.anchorwiseOutput_;
      logitScale_ = other.logitScale_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSoftmaxClassificationLoss Clone() {
      return new WeightedSoftmaxClassificationLoss(this);
    }

    /// <summary>Field number for the "anchorwise_output" field.</summary>
    public const int AnchorwiseOutputFieldNumber = 1;
    private bool anchorwiseOutput_;
    /// <summary>
    /// DEPRECATED, do not use.
    /// Output loss per anchor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AnchorwiseOutput {
      get { return anchorwiseOutput_; }
      set {
        anchorwiseOutput_ = value;
      }
    }

    /// <summary>Field number for the "logit_scale" field.</summary>
    public const int LogitScaleFieldNumber = 2;
    private float logitScale_;
    /// <summary>
    /// Scale logit (input) value before calculating softmax classification loss.
    /// Typically used for softmax distillation.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LogitScale {
      get { return logitScale_; }
      set {
        logitScale_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightedSoftmaxClassificationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightedSoftmaxClassificationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AnchorwiseOutput != other.AnchorwiseOutput) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LogitScale, other.LogitScale)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AnchorwiseOutput != false) hash ^= AnchorwiseOutput.GetHashCode();
      if (LogitScale != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LogitScale);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AnchorwiseOutput != false) {
        output.WriteRawTag(8);
        output.WriteBool(AnchorwiseOutput);
      }
      if (LogitScale != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(LogitScale);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AnchorwiseOutput != false) {
        size += 1 + 1;
      }
      if (LogitScale != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightedSoftmaxClassificationLoss other) {
      if (other == null) {
        return;
      }
      if (other.AnchorwiseOutput != false) {
        AnchorwiseOutput = other.AnchorwiseOutput;
      }
      if (other.LogitScale != 0F) {
        LogitScale = other.LogitScale;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AnchorwiseOutput = input.ReadBool();
            break;
          }
          case 21: {
            LogitScale = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Classification loss using a softmax function over class predictions and
  /// a softmax function over the groundtruth labels (assumed to be logits).
  /// </summary>
  public sealed partial class WeightedSoftmaxClassificationAgainstLogitsLoss : pb::IMessage<WeightedSoftmaxClassificationAgainstLogitsLoss> {
    private static readonly pb::MessageParser<WeightedSoftmaxClassificationAgainstLogitsLoss> _parser = new pb::MessageParser<WeightedSoftmaxClassificationAgainstLogitsLoss>(() => new WeightedSoftmaxClassificationAgainstLogitsLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<WeightedSoftmaxClassificationAgainstLogitsLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSoftmaxClassificationAgainstLogitsLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSoftmaxClassificationAgainstLogitsLoss(WeightedSoftmaxClassificationAgainstLogitsLoss other) : this() {
      anchorwiseOutput_ = other.anchorwiseOutput_;
      logitScale_ = other.logitScale_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public WeightedSoftmaxClassificationAgainstLogitsLoss Clone() {
      return new WeightedSoftmaxClassificationAgainstLogitsLoss(this);
    }

    /// <summary>Field number for the "anchorwise_output" field.</summary>
    public const int AnchorwiseOutputFieldNumber = 1;
    private bool anchorwiseOutput_;
    /// <summary>
    /// DEPRECATED, do not use.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AnchorwiseOutput {
      get { return anchorwiseOutput_; }
      set {
        anchorwiseOutput_ = value;
      }
    }

    /// <summary>Field number for the "logit_scale" field.</summary>
    public const int LogitScaleFieldNumber = 2;
    private float logitScale_;
    /// <summary>
    /// Scale and softmax groundtruth logits before calculating softmax
    /// classification loss. Typically used for softmax distillation with teacher
    /// annotations stored as logits.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float LogitScale {
      get { return logitScale_; }
      set {
        logitScale_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as WeightedSoftmaxClassificationAgainstLogitsLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(WeightedSoftmaxClassificationAgainstLogitsLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (AnchorwiseOutput != other.AnchorwiseOutput) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(LogitScale, other.LogitScale)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (AnchorwiseOutput != false) hash ^= AnchorwiseOutput.GetHashCode();
      if (LogitScale != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(LogitScale);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (AnchorwiseOutput != false) {
        output.WriteRawTag(8);
        output.WriteBool(AnchorwiseOutput);
      }
      if (LogitScale != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(LogitScale);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (AnchorwiseOutput != false) {
        size += 1 + 1;
      }
      if (LogitScale != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(WeightedSoftmaxClassificationAgainstLogitsLoss other) {
      if (other == null) {
        return;
      }
      if (other.AnchorwiseOutput != false) {
        AnchorwiseOutput = other.AnchorwiseOutput;
      }
      if (other.LogitScale != 0F) {
        LogitScale = other.LogitScale;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            AnchorwiseOutput = input.ReadBool();
            break;
          }
          case 21: {
            LogitScale = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Classification loss using a sigmoid function over the class prediction with
  /// the highest prediction score.
  /// </summary>
  public sealed partial class BootstrappedSigmoidClassificationLoss : pb::IMessage<BootstrappedSigmoidClassificationLoss> {
    private static readonly pb::MessageParser<BootstrappedSigmoidClassificationLoss> _parser = new pb::MessageParser<BootstrappedSigmoidClassificationLoss>(() => new BootstrappedSigmoidClassificationLoss());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<BootstrappedSigmoidClassificationLoss> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BootstrappedSigmoidClassificationLoss() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BootstrappedSigmoidClassificationLoss(BootstrappedSigmoidClassificationLoss other) : this() {
      alpha_ = other.alpha_;
      hardBootstrap_ = other.hardBootstrap_;
      anchorwiseOutput_ = other.anchorwiseOutput_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public BootstrappedSigmoidClassificationLoss Clone() {
      return new BootstrappedSigmoidClassificationLoss(this);
    }

    /// <summary>Field number for the "alpha" field.</summary>
    public const int AlphaFieldNumber = 1;
    private float alpha_;
    /// <summary>
    /// Interpolation weight between 0 and 1.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float Alpha {
      get { return alpha_; }
      set {
        alpha_ = value;
      }
    }

    /// <summary>Field number for the "hard_bootstrap" field.</summary>
    public const int HardBootstrapFieldNumber = 2;
    private bool hardBootstrap_;
    /// <summary>
    /// Whether hard boot strapping should be used or not. If true, will only use
    /// one class favored by model. Othewise, will use all predicted class
    /// probabilities.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool HardBootstrap {
      get { return hardBootstrap_; }
      set {
        hardBootstrap_ = value;
      }
    }

    /// <summary>Field number for the "anchorwise_output" field.</summary>
    public const int AnchorwiseOutputFieldNumber = 3;
    private bool anchorwiseOutput_;
    /// <summary>
    /// DEPRECATED, do not use.
    /// Output loss per anchor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AnchorwiseOutput {
      get { return anchorwiseOutput_; }
      set {
        anchorwiseOutput_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as BootstrappedSigmoidClassificationLoss);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(BootstrappedSigmoidClassificationLoss other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(Alpha, other.Alpha)) return false;
      if (HardBootstrap != other.HardBootstrap) return false;
      if (AnchorwiseOutput != other.AnchorwiseOutput) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Alpha != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(Alpha);
      if (HardBootstrap != false) hash ^= HardBootstrap.GetHashCode();
      if (AnchorwiseOutput != false) hash ^= AnchorwiseOutput.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Alpha != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(Alpha);
      }
      if (HardBootstrap != false) {
        output.WriteRawTag(16);
        output.WriteBool(HardBootstrap);
      }
      if (AnchorwiseOutput != false) {
        output.WriteRawTag(24);
        output.WriteBool(AnchorwiseOutput);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Alpha != 0F) {
        size += 1 + 4;
      }
      if (HardBootstrap != false) {
        size += 1 + 1;
      }
      if (AnchorwiseOutput != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(BootstrappedSigmoidClassificationLoss other) {
      if (other == null) {
        return;
      }
      if (other.Alpha != 0F) {
        Alpha = other.Alpha;
      }
      if (other.HardBootstrap != false) {
        HardBootstrap = other.HardBootstrap;
      }
      if (other.AnchorwiseOutput != false) {
        AnchorwiseOutput = other.AnchorwiseOutput;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            Alpha = input.ReadFloat();
            break;
          }
          case 16: {
            HardBootstrap = input.ReadBool();
            break;
          }
          case 24: {
            AnchorwiseOutput = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration for hard example miner.
  /// </summary>
  public sealed partial class HardExampleMiner : pb::IMessage<HardExampleMiner> {
    private static readonly pb::MessageParser<HardExampleMiner> _parser = new pb::MessageParser<HardExampleMiner>(() => new HardExampleMiner());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<HardExampleMiner> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HardExampleMiner() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HardExampleMiner(HardExampleMiner other) : this() {
      numHardExamples_ = other.numHardExamples_;
      iouThreshold_ = other.iouThreshold_;
      lossType_ = other.lossType_;
      maxNegativesPerPositive_ = other.maxNegativesPerPositive_;
      minNegativesPerImage_ = other.minNegativesPerImage_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public HardExampleMiner Clone() {
      return new HardExampleMiner(this);
    }

    /// <summary>Field number for the "num_hard_examples" field.</summary>
    public const int NumHardExamplesFieldNumber = 1;
    private int numHardExamples_;
    /// <summary>
    /// Maximum number of hard examples to be selected per image (prior to
    /// enforcing max negative to positive ratio constraint).  If set to 0,
    /// all examples obtained after NMS are considered.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumHardExamples {
      get { return numHardExamples_; }
      set {
        numHardExamples_ = value;
      }
    }

    /// <summary>Field number for the "iou_threshold" field.</summary>
    public const int IouThresholdFieldNumber = 2;
    private float iouThreshold_;
    /// <summary>
    /// Minimum intersection over union for an example to be discarded during NMS.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float IouThreshold {
      get { return iouThreshold_; }
      set {
        iouThreshold_ = value;
      }
    }

    /// <summary>Field number for the "loss_type" field.</summary>
    public const int LossTypeFieldNumber = 3;
    private global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner.Types.LossType lossType_ = 0;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner.Types.LossType LossType {
      get { return lossType_; }
      set {
        lossType_ = value;
      }
    }

    /// <summary>Field number for the "max_negatives_per_positive" field.</summary>
    public const int MaxNegativesPerPositiveFieldNumber = 4;
    private int maxNegativesPerPositive_;
    /// <summary>
    /// Maximum number of negatives to retain for each positive anchor. If
    /// num_negatives_per_positive is 0 no prespecified negative:positive ratio is
    /// enforced.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxNegativesPerPositive {
      get { return maxNegativesPerPositive_; }
      set {
        maxNegativesPerPositive_ = value;
      }
    }

    /// <summary>Field number for the "min_negatives_per_image" field.</summary>
    public const int MinNegativesPerImageFieldNumber = 5;
    private int minNegativesPerImage_;
    /// <summary>
    /// Minimum number of negative anchors to sample for a given image. Setting
    /// this to a positive number samples negatives in an image without any
    /// positive anchors and thus not bias the model towards having at least one
    /// detection per image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinNegativesPerImage {
      get { return minNegativesPerImage_; }
      set {
        minNegativesPerImage_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as HardExampleMiner);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(HardExampleMiner other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NumHardExamples != other.NumHardExamples) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(IouThreshold, other.IouThreshold)) return false;
      if (LossType != other.LossType) return false;
      if (MaxNegativesPerPositive != other.MaxNegativesPerPositive) return false;
      if (MinNegativesPerImage != other.MinNegativesPerImage) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NumHardExamples != 0) hash ^= NumHardExamples.GetHashCode();
      if (IouThreshold != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(IouThreshold);
      if (LossType != 0) hash ^= LossType.GetHashCode();
      if (MaxNegativesPerPositive != 0) hash ^= MaxNegativesPerPositive.GetHashCode();
      if (MinNegativesPerImage != 0) hash ^= MinNegativesPerImage.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (NumHardExamples != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(NumHardExamples);
      }
      if (IouThreshold != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(IouThreshold);
      }
      if (LossType != 0) {
        output.WriteRawTag(24);
        output.WriteEnum((int) LossType);
      }
      if (MaxNegativesPerPositive != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(MaxNegativesPerPositive);
      }
      if (MinNegativesPerImage != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(MinNegativesPerImage);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NumHardExamples != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumHardExamples);
      }
      if (IouThreshold != 0F) {
        size += 1 + 4;
      }
      if (LossType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) LossType);
      }
      if (MaxNegativesPerPositive != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxNegativesPerPositive);
      }
      if (MinNegativesPerImage != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinNegativesPerImage);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(HardExampleMiner other) {
      if (other == null) {
        return;
      }
      if (other.NumHardExamples != 0) {
        NumHardExamples = other.NumHardExamples;
      }
      if (other.IouThreshold != 0F) {
        IouThreshold = other.IouThreshold;
      }
      if (other.LossType != 0) {
        LossType = other.LossType;
      }
      if (other.MaxNegativesPerPositive != 0) {
        MaxNegativesPerPositive = other.MaxNegativesPerPositive;
      }
      if (other.MinNegativesPerImage != 0) {
        MinNegativesPerImage = other.MinNegativesPerImage;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NumHardExamples = input.ReadInt32();
            break;
          }
          case 21: {
            IouThreshold = input.ReadFloat();
            break;
          }
          case 24: {
            lossType_ = (global::Tensorflow.Models.ObjectDetection.Protos.HardExampleMiner.Types.LossType) input.ReadEnum();
            break;
          }
          case 32: {
            MaxNegativesPerPositive = input.ReadInt32();
            break;
          }
          case 40: {
            MinNegativesPerImage = input.ReadInt32();
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the HardExampleMiner message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Whether to use classification losses ('cls', default), localization losses
      /// ('loc') or both losses ('both'). In the case of 'both', cls_loss_weight and
      /// loc_loss_weight are used to compute weighted sum of the two losses.
      /// </summary>
      public enum LossType {
        [pbr::OriginalName("BOTH")] Both = 0,
        [pbr::OriginalName("CLASSIFICATION")] Classification = 1,
        [pbr::OriginalName("LOCALIZATION")] Localization = 2,
      }

    }
    #endregion

  }

  /// <summary>
  /// Configuration for random example sampler.
  /// </summary>
  public sealed partial class RandomExampleSampler : pb::IMessage<RandomExampleSampler> {
    private static readonly pb::MessageParser<RandomExampleSampler> _parser = new pb::MessageParser<RandomExampleSampler>(() => new RandomExampleSampler());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<RandomExampleSampler> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomExampleSampler() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomExampleSampler(RandomExampleSampler other) : this() {
      positiveSampleFraction_ = other.positiveSampleFraction_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public RandomExampleSampler Clone() {
      return new RandomExampleSampler(this);
    }

    /// <summary>Field number for the "positive_sample_fraction" field.</summary>
    public const int PositiveSampleFractionFieldNumber = 1;
    private float positiveSampleFraction_;
    /// <summary>
    /// The desired fraction of positive samples in batch when applying random
    /// example sampling.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float PositiveSampleFraction {
      get { return positiveSampleFraction_; }
      set {
        positiveSampleFraction_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as RandomExampleSampler);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(RandomExampleSampler other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(PositiveSampleFraction, other.PositiveSampleFraction)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (PositiveSampleFraction != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(PositiveSampleFraction);
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (PositiveSampleFraction != 0F) {
        output.WriteRawTag(13);
        output.WriteFloat(PositiveSampleFraction);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (PositiveSampleFraction != 0F) {
        size += 1 + 4;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(RandomExampleSampler other) {
      if (other == null) {
        return;
      }
      if (other.PositiveSampleFraction != 0F) {
        PositiveSampleFraction = other.PositiveSampleFraction;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 13: {
            PositiveSampleFraction = input.ReadFloat();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
