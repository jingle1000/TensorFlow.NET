// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: object_detection/protos/ssd.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Models.ObjectDetection.Protos {

  /// <summary>Holder for reflection information generated from object_detection/protos/ssd.proto</summary>
  public static partial class SsdReflection {

    #region Descriptor
    /// <summary>File descriptor for object_detection/protos/ssd.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static SsdReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CiFvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9zc2QucHJvdG8SF29iamVjdF9k",
            "ZXRlY3Rpb24ucHJvdG9zGi5vYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9hbmNo",
            "b3JfZ2VuZXJhdG9yLnByb3RvGidvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9i",
            "b3hfY29kZXIucHJvdG8aK29iamVjdF9kZXRlY3Rpb24vcHJvdG9zL2JveF9w",
            "cmVkaWN0b3IucHJvdG8aKW9iamVjdF9kZXRlY3Rpb24vcHJvdG9zL2h5cGVy",
            "cGFyYW1zLnByb3RvGitvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9pbWFnZV9y",
            "ZXNpemVyLnByb3RvGiRvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9sb3NzZXMu",
            "cHJvdG8aJW9iamVjdF9kZXRlY3Rpb24vcHJvdG9zL21hdGNoZXIucHJvdG8a",
            "LW9iamVjdF9kZXRlY3Rpb24vcHJvdG9zL3Bvc3RfcHJvY2Vzc2luZy5wcm90",
            "bxo6b2JqZWN0X2RldGVjdGlvbi9wcm90b3MvcmVnaW9uX3NpbWlsYXJpdHlf",
            "Y2FsY3VsYXRvci5wcm90byLDCgoDU3NkEhMKC251bV9jbGFzc2VzGAEgASgF",
            "EjwKDWltYWdlX3Jlc2l6ZXIYAiABKAsyJS5vYmplY3RfZGV0ZWN0aW9uLnBy",
            "b3Rvcy5JbWFnZVJlc2l6ZXISRwoRZmVhdHVyZV9leHRyYWN0b3IYAyABKAsy",
            "LC5vYmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5Tc2RGZWF0dXJlRXh0cmFjdG9y",
            "EjQKCWJveF9jb2RlchgEIAEoCzIhLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9z",
            "LkJveENvZGVyEjEKB21hdGNoZXIYBSABKAsyIC5vYmplY3RfZGV0ZWN0aW9u",
            "LnByb3Rvcy5NYXRjaGVyElIKFXNpbWlsYXJpdHlfY2FsY3VsYXRvchgGIAEo",
            "CzIzLm9iamVjdF9kZXRlY3Rpb24ucHJvdG9zLlJlZ2lvblNpbWlsYXJpdHlD",
            "YWxjdWxhdG9yEiIKGmVuY29kZV9iYWNrZ3JvdW5kX2FzX3plcm9zGAwgASgI",
            "Eh0KFW5lZ2F0aXZlX2NsYXNzX3dlaWdodBgNIAEoAhI8Cg1ib3hfcHJlZGlj",
            "dG9yGAcgASgLMiUub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuQm94UHJlZGlj",
            "dG9yEkIKEGFuY2hvcl9nZW5lcmF0b3IYCCABKAsyKC5vYmplY3RfZGV0ZWN0",
            "aW9uLnByb3Rvcy5BbmNob3JHZW5lcmF0b3ISQAoPcG9zdF9wcm9jZXNzaW5n",
            "GAkgASgLMicub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuUG9zdFByb2Nlc3Np",
            "bmcSJQodbm9ybWFsaXplX2xvc3NfYnlfbnVtX21hdGNoZXMYCiABKAgSJgoe",
            "bm9ybWFsaXplX2xvY19sb3NzX2J5X2NvZGVzaXplGA4gASgIEisKBGxvc3MY",
            "CyABKAsyHS5vYmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5Mb3NzEhgKEGZyZWV6",
            "ZV9iYXRjaG5vcm0YECABKAgSIAoYaW5wbGFjZV9iYXRjaG5vcm1fdXBkYXRl",
            "GA8gASgIEhwKFGFkZF9iYWNrZ3JvdW5kX2NsYXNzGBUgASgIEiEKGWV4cGxp",
            "Y2l0X2JhY2tncm91bmRfY2xhc3MYGCABKAgSIgoadXNlX2NvbmZpZGVuY2Vz",
            "X2FzX3RhcmdldHMYFiABKAgSHwoXaW1wbGljaXRfZXhhbXBsZV93ZWlnaHQY",
            "FyABKAISPwoQbWFza19oZWFkX2NvbmZpZxgZIAEoCzIlLm9iamVjdF9kZXRl",
            "Y3Rpb24ucHJvdG9zLlNzZC5NYXNrSGVhZBrcAgoITWFza0hlYWQSEwoLbWFz",
            "a19oZWlnaHQYASABKAUSEgoKbWFza193aWR0aBgCIAEoBRIgChhtYXNrc19h",
            "cmVfY2xhc3NfYWdub3N0aWMYAyABKAgSIgoabWFza19wcmVkaWN0aW9uX2Nv",
            "bnZfZGVwdGgYBCABKAUSJwofbWFza19wcmVkaWN0aW9uX251bV9jb252X2xh",
            "eWVycxgFIAEoBRIkChxjb252b2x2ZV90aGVuX3Vwc2FtcGxlX21hc2tzGAYg",
            "ASgIEhgKEG1hc2tfbG9zc193ZWlnaHQYByABKAISHQoVbWFza19sb3NzX3Nh",
            "bXBsZV9zaXplGAggASgFEj4KEGNvbnZfaHlwZXJwYXJhbXMYCSABKAsyJC5v",
            "YmplY3RfZGV0ZWN0aW9uLnByb3Rvcy5IeXBlcnBhcmFtcxIZChFpbml0aWFs",
            "X2Nyb3Bfc2l6ZRgKIAEoBSKaAwoTU3NkRmVhdHVyZUV4dHJhY3RvchIMCgR0",
            "eXBlGAEgASgJEhgKEGRlcHRoX211bHRpcGxpZXIYAiABKAISEQoJbWluX2Rl",
            "cHRoGAMgASgFEj4KEGNvbnZfaHlwZXJwYXJhbXMYBCABKAsyJC5vYmplY3Rf",
            "ZGV0ZWN0aW9uLnByb3Rvcy5IeXBlcnBhcmFtcxIzCitvdmVycmlkZV9iYXNl",
            "X2ZlYXR1cmVfZXh0cmFjdG9yX2h5cGVycGFyYW1zGAkgASgIEhcKD3BhZF90",
            "b19tdWx0aXBsZRgFIAEoBRIcChR1c2VfZXhwbGljaXRfcGFkZGluZxgHIAEo",
            "CBIVCg11c2VfZGVwdGh3aXNlGAggASgIEjwKA2ZwbhgKIAEoCzIvLm9iamVj",
            "dF9kZXRlY3Rpb24ucHJvdG9zLkZlYXR1cmVQeXJhbWlkTmV0d29ya3MSLQol",
            "cmVwbGFjZV9wcmVwcm9jZXNzb3Jfd2l0aF9wbGFjZWhvbGRlchgLIAEoCBIS",
            "CgpudW1fbGF5ZXJzGAwgASgFSgQIBhAHIl4KFkZlYXR1cmVQeXJhbWlkTmV0",
            "d29ya3MSEQoJbWluX2xldmVsGAEgASgFEhEKCW1heF9sZXZlbBgCIAEoBRIe",
            "ChZhZGRpdGlvbmFsX2xheWVyX2RlcHRoGAMgASgFYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { global::Tensorflow.Models.ObjectDetection.Protos.AnchorGeneratorReflection.Descriptor, global::Tensorflow.Models.ObjectDetection.Protos.BoxCoderReflection.Descriptor, global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictorReflection.Descriptor, global::Tensorflow.Models.ObjectDetection.Protos.HyperparamsReflection.Descriptor, global::Tensorflow.Models.ObjectDetection.Protos.ImageResizerReflection.Descriptor, global::Tensorflow.Models.ObjectDetection.Protos.LossesReflection.Descriptor, global::Tensorflow.Models.ObjectDetection.Protos.MatcherReflection.Descriptor, global::Tensorflow.Models.ObjectDetection.Protos.PostProcessingReflection.Descriptor, global::Tensorflow.Models.ObjectDetection.Protos.RegionSimilarityCalculatorReflection.Descriptor, },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.Ssd), global::Tensorflow.Models.ObjectDetection.Protos.Ssd.Parser, new[]{ "NumClasses", "ImageResizer", "FeatureExtractor", "BoxCoder", "Matcher", "SimilarityCalculator", "EncodeBackgroundAsZeros", "NegativeClassWeight", "BoxPredictor", "AnchorGenerator", "PostProcessing", "NormalizeLossByNumMatches", "NormalizeLocLossByCodesize", "Loss", "FreezeBatchnorm", "InplaceBatchnormUpdate", "AddBackgroundClass", "ExplicitBackgroundClass", "UseConfidencesAsTargets", "ImplicitExampleWeight", "MaskHeadConfig" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.Ssd.Types.MaskHead), global::Tensorflow.Models.ObjectDetection.Protos.Ssd.Types.MaskHead.Parser, new[]{ "MaskHeight", "MaskWidth", "MasksAreClassAgnostic", "MaskPredictionConvDepth", "MaskPredictionNumConvLayers", "ConvolveThenUpsampleMasks", "MaskLossWeight", "MaskLossSampleSize", "ConvHyperparams", "InitialCropSize" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.SsdFeatureExtractor), global::Tensorflow.Models.ObjectDetection.Protos.SsdFeatureExtractor.Parser, new[]{ "Type", "DepthMultiplier", "MinDepth", "ConvHyperparams", "OverrideBaseFeatureExtractorHyperparams", "PadToMultiple", "UseExplicitPadding", "UseDepthwise", "Fpn", "ReplacePreprocessorWithPlaceholder", "NumLayers" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.FeaturePyramidNetworks), global::Tensorflow.Models.ObjectDetection.Protos.FeaturePyramidNetworks.Parser, new[]{ "MinLevel", "MaxLevel", "AdditionalLayerDepth" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration for Single Shot Detection (SSD) models.
  /// Next id: 26
  /// </summary>
  public sealed partial class Ssd : pb::IMessage<Ssd> {
    private static readonly pb::MessageParser<Ssd> _parser = new pb::MessageParser<Ssd>(() => new Ssd());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<Ssd> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.SsdReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Ssd() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Ssd(Ssd other) : this() {
      numClasses_ = other.numClasses_;
      imageResizer_ = other.imageResizer_ != null ? other.imageResizer_.Clone() : null;
      featureExtractor_ = other.featureExtractor_ != null ? other.featureExtractor_.Clone() : null;
      boxCoder_ = other.boxCoder_ != null ? other.boxCoder_.Clone() : null;
      matcher_ = other.matcher_ != null ? other.matcher_.Clone() : null;
      similarityCalculator_ = other.similarityCalculator_ != null ? other.similarityCalculator_.Clone() : null;
      encodeBackgroundAsZeros_ = other.encodeBackgroundAsZeros_;
      negativeClassWeight_ = other.negativeClassWeight_;
      boxPredictor_ = other.boxPredictor_ != null ? other.boxPredictor_.Clone() : null;
      anchorGenerator_ = other.anchorGenerator_ != null ? other.anchorGenerator_.Clone() : null;
      postProcessing_ = other.postProcessing_ != null ? other.postProcessing_.Clone() : null;
      normalizeLossByNumMatches_ = other.normalizeLossByNumMatches_;
      normalizeLocLossByCodesize_ = other.normalizeLocLossByCodesize_;
      loss_ = other.loss_ != null ? other.loss_.Clone() : null;
      freezeBatchnorm_ = other.freezeBatchnorm_;
      inplaceBatchnormUpdate_ = other.inplaceBatchnormUpdate_;
      addBackgroundClass_ = other.addBackgroundClass_;
      explicitBackgroundClass_ = other.explicitBackgroundClass_;
      useConfidencesAsTargets_ = other.useConfidencesAsTargets_;
      implicitExampleWeight_ = other.implicitExampleWeight_;
      maskHeadConfig_ = other.maskHeadConfig_ != null ? other.maskHeadConfig_.Clone() : null;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public Ssd Clone() {
      return new Ssd(this);
    }

    /// <summary>Field number for the "num_classes" field.</summary>
    public const int NumClassesFieldNumber = 1;
    private int numClasses_;
    /// <summary>
    /// Number of classes to predict.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumClasses {
      get { return numClasses_; }
      set {
        numClasses_ = value;
      }
    }

    /// <summary>Field number for the "image_resizer" field.</summary>
    public const int ImageResizerFieldNumber = 2;
    private global::Tensorflow.Models.ObjectDetection.Protos.ImageResizer imageResizer_;
    /// <summary>
    /// Image resizer for preprocessing the input image.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ImageResizer ImageResizer {
      get { return imageResizer_; }
      set {
        imageResizer_ = value;
      }
    }

    /// <summary>Field number for the "feature_extractor" field.</summary>
    public const int FeatureExtractorFieldNumber = 3;
    private global::Tensorflow.Models.ObjectDetection.Protos.SsdFeatureExtractor featureExtractor_;
    /// <summary>
    /// Feature extractor config.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.SsdFeatureExtractor FeatureExtractor {
      get { return featureExtractor_; }
      set {
        featureExtractor_ = value;
      }
    }

    /// <summary>Field number for the "box_coder" field.</summary>
    public const int BoxCoderFieldNumber = 4;
    private global::Tensorflow.Models.ObjectDetection.Protos.BoxCoder boxCoder_;
    /// <summary>
    /// Box coder to encode the boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.BoxCoder BoxCoder {
      get { return boxCoder_; }
      set {
        boxCoder_ = value;
      }
    }

    /// <summary>Field number for the "matcher" field.</summary>
    public const int MatcherFieldNumber = 5;
    private global::Tensorflow.Models.ObjectDetection.Protos.Matcher matcher_;
    /// <summary>
    /// Matcher to match groundtruth with anchors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Matcher Matcher {
      get { return matcher_; }
      set {
        matcher_ = value;
      }
    }

    /// <summary>Field number for the "similarity_calculator" field.</summary>
    public const int SimilarityCalculatorFieldNumber = 6;
    private global::Tensorflow.Models.ObjectDetection.Protos.RegionSimilarityCalculator similarityCalculator_;
    /// <summary>
    /// Region similarity calculator to compute similarity of boxes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.RegionSimilarityCalculator SimilarityCalculator {
      get { return similarityCalculator_; }
      set {
        similarityCalculator_ = value;
      }
    }

    /// <summary>Field number for the "encode_background_as_zeros" field.</summary>
    public const int EncodeBackgroundAsZerosFieldNumber = 12;
    private bool encodeBackgroundAsZeros_;
    /// <summary>
    /// Whether background targets are to be encoded as an all
    /// zeros vector or a one-hot vector (where background is the 0th class).
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool EncodeBackgroundAsZeros {
      get { return encodeBackgroundAsZeros_; }
      set {
        encodeBackgroundAsZeros_ = value;
      }
    }

    /// <summary>Field number for the "negative_class_weight" field.</summary>
    public const int NegativeClassWeightFieldNumber = 13;
    private float negativeClassWeight_;
    /// <summary>
    /// classification weight to be associated to negative
    /// anchors (default: 1.0). The weight must be in [0., 1.].
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float NegativeClassWeight {
      get { return negativeClassWeight_; }
      set {
        negativeClassWeight_ = value;
      }
    }

    /// <summary>Field number for the "box_predictor" field.</summary>
    public const int BoxPredictorFieldNumber = 7;
    private global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictor boxPredictor_;
    /// <summary>
    /// Box predictor to attach to the features.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictor BoxPredictor {
      get { return boxPredictor_; }
      set {
        boxPredictor_ = value;
      }
    }

    /// <summary>Field number for the "anchor_generator" field.</summary>
    public const int AnchorGeneratorFieldNumber = 8;
    private global::Tensorflow.Models.ObjectDetection.Protos.AnchorGenerator anchorGenerator_;
    /// <summary>
    /// Anchor generator to compute anchors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.AnchorGenerator AnchorGenerator {
      get { return anchorGenerator_; }
      set {
        anchorGenerator_ = value;
      }
    }

    /// <summary>Field number for the "post_processing" field.</summary>
    public const int PostProcessingFieldNumber = 9;
    private global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing postProcessing_;
    /// <summary>
    /// Post processing to apply on the predictions.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing PostProcessing {
      get { return postProcessing_; }
      set {
        postProcessing_ = value;
      }
    }

    /// <summary>Field number for the "normalize_loss_by_num_matches" field.</summary>
    public const int NormalizeLossByNumMatchesFieldNumber = 10;
    private bool normalizeLossByNumMatches_;
    /// <summary>
    /// Whether to normalize the loss by number of groundtruth boxes that match to
    /// the anchors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NormalizeLossByNumMatches {
      get { return normalizeLossByNumMatches_; }
      set {
        normalizeLossByNumMatches_ = value;
      }
    }

    /// <summary>Field number for the "normalize_loc_loss_by_codesize" field.</summary>
    public const int NormalizeLocLossByCodesizeFieldNumber = 14;
    private bool normalizeLocLossByCodesize_;
    /// <summary>
    /// Whether to normalize the localization loss by the code size of the box
    /// encodings. This is applied along with other normalization factors.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NormalizeLocLossByCodesize {
      get { return normalizeLocLossByCodesize_; }
      set {
        normalizeLocLossByCodesize_ = value;
      }
    }

    /// <summary>Field number for the "loss" field.</summary>
    public const int LossFieldNumber = 11;
    private global::Tensorflow.Models.ObjectDetection.Protos.Loss loss_;
    /// <summary>
    /// Loss configuration for training.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Loss Loss {
      get { return loss_; }
      set {
        loss_ = value;
      }
    }

    /// <summary>Field number for the "freeze_batchnorm" field.</summary>
    public const int FreezeBatchnormFieldNumber = 16;
    private bool freezeBatchnorm_;
    /// <summary>
    /// Whether to update batch norm parameters during training or not.
    /// When training with a relative small batch size (e.g. 1), it is
    /// desirable to disable batch norm update and use pretrained batch norm
    /// params.
    ///
    /// Note: Some feature extractors are used with canned arg_scopes
    /// (e.g resnet arg scopes).  In these cases training behavior of batch norm
    /// variables may depend on both values of `batch_norm_trainable` and
    /// `is_training`.
    ///
    /// When canned arg_scopes are used with feature extractors `conv_hyperparams`
    /// will apply only to the additional layers that are added and are outside the
    /// canned arg_scope.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool FreezeBatchnorm {
      get { return freezeBatchnorm_; }
      set {
        freezeBatchnorm_ = value;
      }
    }

    /// <summary>Field number for the "inplace_batchnorm_update" field.</summary>
    public const int InplaceBatchnormUpdateFieldNumber = 15;
    private bool inplaceBatchnormUpdate_;
    /// <summary>
    /// Whether to update batch_norm inplace during training. This is required
    /// for batch norm to work correctly on TPUs. When this is false, user must add
    /// a control dependency on tf.GraphKeys.UPDATE_OPS for train/loss op in order
    /// to update the batch norm moving average parameters.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool InplaceBatchnormUpdate {
      get { return inplaceBatchnormUpdate_; }
      set {
        inplaceBatchnormUpdate_ = value;
      }
    }

    /// <summary>Field number for the "add_background_class" field.</summary>
    public const int AddBackgroundClassFieldNumber = 21;
    private bool addBackgroundClass_;
    /// <summary>
    /// Whether to add an implicit background class to one-hot encodings of
    /// groundtruth labels. Set to false if training a single
    /// class model or using an explicit background class.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool AddBackgroundClass {
      get { return addBackgroundClass_; }
      set {
        addBackgroundClass_ = value;
      }
    }

    /// <summary>Field number for the "explicit_background_class" field.</summary>
    public const int ExplicitBackgroundClassFieldNumber = 24;
    private bool explicitBackgroundClass_;
    /// <summary>
    /// Whether to use an explicit background class. Set to true if using
    /// groundtruth labels with an explicit background class, as in multiclass
    /// scores.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ExplicitBackgroundClass {
      get { return explicitBackgroundClass_; }
      set {
        explicitBackgroundClass_ = value;
      }
    }

    /// <summary>Field number for the "use_confidences_as_targets" field.</summary>
    public const int UseConfidencesAsTargetsFieldNumber = 22;
    private bool useConfidencesAsTargets_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseConfidencesAsTargets {
      get { return useConfidencesAsTargets_; }
      set {
        useConfidencesAsTargets_ = value;
      }
    }

    /// <summary>Field number for the "implicit_example_weight" field.</summary>
    public const int ImplicitExampleWeightFieldNumber = 23;
    private float implicitExampleWeight_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float ImplicitExampleWeight {
      get { return implicitExampleWeight_; }
      set {
        implicitExampleWeight_ = value;
      }
    }

    /// <summary>Field number for the "mask_head_config" field.</summary>
    public const int MaskHeadConfigFieldNumber = 25;
    private global::Tensorflow.Models.ObjectDetection.Protos.Ssd.Types.MaskHead maskHeadConfig_;
    /// <summary>
    /// Configs for mask head.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Ssd.Types.MaskHead MaskHeadConfig {
      get { return maskHeadConfig_; }
      set {
        maskHeadConfig_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as Ssd);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(Ssd other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (NumClasses != other.NumClasses) return false;
      if (!object.Equals(ImageResizer, other.ImageResizer)) return false;
      if (!object.Equals(FeatureExtractor, other.FeatureExtractor)) return false;
      if (!object.Equals(BoxCoder, other.BoxCoder)) return false;
      if (!object.Equals(Matcher, other.Matcher)) return false;
      if (!object.Equals(SimilarityCalculator, other.SimilarityCalculator)) return false;
      if (EncodeBackgroundAsZeros != other.EncodeBackgroundAsZeros) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(NegativeClassWeight, other.NegativeClassWeight)) return false;
      if (!object.Equals(BoxPredictor, other.BoxPredictor)) return false;
      if (!object.Equals(AnchorGenerator, other.AnchorGenerator)) return false;
      if (!object.Equals(PostProcessing, other.PostProcessing)) return false;
      if (NormalizeLossByNumMatches != other.NormalizeLossByNumMatches) return false;
      if (NormalizeLocLossByCodesize != other.NormalizeLocLossByCodesize) return false;
      if (!object.Equals(Loss, other.Loss)) return false;
      if (FreezeBatchnorm != other.FreezeBatchnorm) return false;
      if (InplaceBatchnormUpdate != other.InplaceBatchnormUpdate) return false;
      if (AddBackgroundClass != other.AddBackgroundClass) return false;
      if (ExplicitBackgroundClass != other.ExplicitBackgroundClass) return false;
      if (UseConfidencesAsTargets != other.UseConfidencesAsTargets) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(ImplicitExampleWeight, other.ImplicitExampleWeight)) return false;
      if (!object.Equals(MaskHeadConfig, other.MaskHeadConfig)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (NumClasses != 0) hash ^= NumClasses.GetHashCode();
      if (imageResizer_ != null) hash ^= ImageResizer.GetHashCode();
      if (featureExtractor_ != null) hash ^= FeatureExtractor.GetHashCode();
      if (boxCoder_ != null) hash ^= BoxCoder.GetHashCode();
      if (matcher_ != null) hash ^= Matcher.GetHashCode();
      if (similarityCalculator_ != null) hash ^= SimilarityCalculator.GetHashCode();
      if (EncodeBackgroundAsZeros != false) hash ^= EncodeBackgroundAsZeros.GetHashCode();
      if (NegativeClassWeight != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(NegativeClassWeight);
      if (boxPredictor_ != null) hash ^= BoxPredictor.GetHashCode();
      if (anchorGenerator_ != null) hash ^= AnchorGenerator.GetHashCode();
      if (postProcessing_ != null) hash ^= PostProcessing.GetHashCode();
      if (NormalizeLossByNumMatches != false) hash ^= NormalizeLossByNumMatches.GetHashCode();
      if (NormalizeLocLossByCodesize != false) hash ^= NormalizeLocLossByCodesize.GetHashCode();
      if (loss_ != null) hash ^= Loss.GetHashCode();
      if (FreezeBatchnorm != false) hash ^= FreezeBatchnorm.GetHashCode();
      if (InplaceBatchnormUpdate != false) hash ^= InplaceBatchnormUpdate.GetHashCode();
      if (AddBackgroundClass != false) hash ^= AddBackgroundClass.GetHashCode();
      if (ExplicitBackgroundClass != false) hash ^= ExplicitBackgroundClass.GetHashCode();
      if (UseConfidencesAsTargets != false) hash ^= UseConfidencesAsTargets.GetHashCode();
      if (ImplicitExampleWeight != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(ImplicitExampleWeight);
      if (maskHeadConfig_ != null) hash ^= MaskHeadConfig.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (NumClasses != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(NumClasses);
      }
      if (imageResizer_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(ImageResizer);
      }
      if (featureExtractor_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(FeatureExtractor);
      }
      if (boxCoder_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(BoxCoder);
      }
      if (matcher_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(Matcher);
      }
      if (similarityCalculator_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(SimilarityCalculator);
      }
      if (boxPredictor_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(BoxPredictor);
      }
      if (anchorGenerator_ != null) {
        output.WriteRawTag(66);
        output.WriteMessage(AnchorGenerator);
      }
      if (postProcessing_ != null) {
        output.WriteRawTag(74);
        output.WriteMessage(PostProcessing);
      }
      if (NormalizeLossByNumMatches != false) {
        output.WriteRawTag(80);
        output.WriteBool(NormalizeLossByNumMatches);
      }
      if (loss_ != null) {
        output.WriteRawTag(90);
        output.WriteMessage(Loss);
      }
      if (EncodeBackgroundAsZeros != false) {
        output.WriteRawTag(96);
        output.WriteBool(EncodeBackgroundAsZeros);
      }
      if (NegativeClassWeight != 0F) {
        output.WriteRawTag(109);
        output.WriteFloat(NegativeClassWeight);
      }
      if (NormalizeLocLossByCodesize != false) {
        output.WriteRawTag(112);
        output.WriteBool(NormalizeLocLossByCodesize);
      }
      if (InplaceBatchnormUpdate != false) {
        output.WriteRawTag(120);
        output.WriteBool(InplaceBatchnormUpdate);
      }
      if (FreezeBatchnorm != false) {
        output.WriteRawTag(128, 1);
        output.WriteBool(FreezeBatchnorm);
      }
      if (AddBackgroundClass != false) {
        output.WriteRawTag(168, 1);
        output.WriteBool(AddBackgroundClass);
      }
      if (UseConfidencesAsTargets != false) {
        output.WriteRawTag(176, 1);
        output.WriteBool(UseConfidencesAsTargets);
      }
      if (ImplicitExampleWeight != 0F) {
        output.WriteRawTag(189, 1);
        output.WriteFloat(ImplicitExampleWeight);
      }
      if (ExplicitBackgroundClass != false) {
        output.WriteRawTag(192, 1);
        output.WriteBool(ExplicitBackgroundClass);
      }
      if (maskHeadConfig_ != null) {
        output.WriteRawTag(202, 1);
        output.WriteMessage(MaskHeadConfig);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (NumClasses != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumClasses);
      }
      if (imageResizer_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ImageResizer);
      }
      if (featureExtractor_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(FeatureExtractor);
      }
      if (boxCoder_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoxCoder);
      }
      if (matcher_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Matcher);
      }
      if (similarityCalculator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SimilarityCalculator);
      }
      if (EncodeBackgroundAsZeros != false) {
        size += 1 + 1;
      }
      if (NegativeClassWeight != 0F) {
        size += 1 + 4;
      }
      if (boxPredictor_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(BoxPredictor);
      }
      if (anchorGenerator_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(AnchorGenerator);
      }
      if (postProcessing_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(PostProcessing);
      }
      if (NormalizeLossByNumMatches != false) {
        size += 1 + 1;
      }
      if (NormalizeLocLossByCodesize != false) {
        size += 1 + 1;
      }
      if (loss_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Loss);
      }
      if (FreezeBatchnorm != false) {
        size += 2 + 1;
      }
      if (InplaceBatchnormUpdate != false) {
        size += 1 + 1;
      }
      if (AddBackgroundClass != false) {
        size += 2 + 1;
      }
      if (ExplicitBackgroundClass != false) {
        size += 2 + 1;
      }
      if (UseConfidencesAsTargets != false) {
        size += 2 + 1;
      }
      if (ImplicitExampleWeight != 0F) {
        size += 2 + 4;
      }
      if (maskHeadConfig_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(MaskHeadConfig);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(Ssd other) {
      if (other == null) {
        return;
      }
      if (other.NumClasses != 0) {
        NumClasses = other.NumClasses;
      }
      if (other.imageResizer_ != null) {
        if (imageResizer_ == null) {
          imageResizer_ = new global::Tensorflow.Models.ObjectDetection.Protos.ImageResizer();
        }
        ImageResizer.MergeFrom(other.ImageResizer);
      }
      if (other.featureExtractor_ != null) {
        if (featureExtractor_ == null) {
          featureExtractor_ = new global::Tensorflow.Models.ObjectDetection.Protos.SsdFeatureExtractor();
        }
        FeatureExtractor.MergeFrom(other.FeatureExtractor);
      }
      if (other.boxCoder_ != null) {
        if (boxCoder_ == null) {
          boxCoder_ = new global::Tensorflow.Models.ObjectDetection.Protos.BoxCoder();
        }
        BoxCoder.MergeFrom(other.BoxCoder);
      }
      if (other.matcher_ != null) {
        if (matcher_ == null) {
          matcher_ = new global::Tensorflow.Models.ObjectDetection.Protos.Matcher();
        }
        Matcher.MergeFrom(other.Matcher);
      }
      if (other.similarityCalculator_ != null) {
        if (similarityCalculator_ == null) {
          similarityCalculator_ = new global::Tensorflow.Models.ObjectDetection.Protos.RegionSimilarityCalculator();
        }
        SimilarityCalculator.MergeFrom(other.SimilarityCalculator);
      }
      if (other.EncodeBackgroundAsZeros != false) {
        EncodeBackgroundAsZeros = other.EncodeBackgroundAsZeros;
      }
      if (other.NegativeClassWeight != 0F) {
        NegativeClassWeight = other.NegativeClassWeight;
      }
      if (other.boxPredictor_ != null) {
        if (boxPredictor_ == null) {
          boxPredictor_ = new global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictor();
        }
        BoxPredictor.MergeFrom(other.BoxPredictor);
      }
      if (other.anchorGenerator_ != null) {
        if (anchorGenerator_ == null) {
          anchorGenerator_ = new global::Tensorflow.Models.ObjectDetection.Protos.AnchorGenerator();
        }
        AnchorGenerator.MergeFrom(other.AnchorGenerator);
      }
      if (other.postProcessing_ != null) {
        if (postProcessing_ == null) {
          postProcessing_ = new global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing();
        }
        PostProcessing.MergeFrom(other.PostProcessing);
      }
      if (other.NormalizeLossByNumMatches != false) {
        NormalizeLossByNumMatches = other.NormalizeLossByNumMatches;
      }
      if (other.NormalizeLocLossByCodesize != false) {
        NormalizeLocLossByCodesize = other.NormalizeLocLossByCodesize;
      }
      if (other.loss_ != null) {
        if (loss_ == null) {
          loss_ = new global::Tensorflow.Models.ObjectDetection.Protos.Loss();
        }
        Loss.MergeFrom(other.Loss);
      }
      if (other.FreezeBatchnorm != false) {
        FreezeBatchnorm = other.FreezeBatchnorm;
      }
      if (other.InplaceBatchnormUpdate != false) {
        InplaceBatchnormUpdate = other.InplaceBatchnormUpdate;
      }
      if (other.AddBackgroundClass != false) {
        AddBackgroundClass = other.AddBackgroundClass;
      }
      if (other.ExplicitBackgroundClass != false) {
        ExplicitBackgroundClass = other.ExplicitBackgroundClass;
      }
      if (other.UseConfidencesAsTargets != false) {
        UseConfidencesAsTargets = other.UseConfidencesAsTargets;
      }
      if (other.ImplicitExampleWeight != 0F) {
        ImplicitExampleWeight = other.ImplicitExampleWeight;
      }
      if (other.maskHeadConfig_ != null) {
        if (maskHeadConfig_ == null) {
          maskHeadConfig_ = new global::Tensorflow.Models.ObjectDetection.Protos.Ssd.Types.MaskHead();
        }
        MaskHeadConfig.MergeFrom(other.MaskHeadConfig);
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            NumClasses = input.ReadInt32();
            break;
          }
          case 18: {
            if (imageResizer_ == null) {
              imageResizer_ = new global::Tensorflow.Models.ObjectDetection.Protos.ImageResizer();
            }
            input.ReadMessage(imageResizer_);
            break;
          }
          case 26: {
            if (featureExtractor_ == null) {
              featureExtractor_ = new global::Tensorflow.Models.ObjectDetection.Protos.SsdFeatureExtractor();
            }
            input.ReadMessage(featureExtractor_);
            break;
          }
          case 34: {
            if (boxCoder_ == null) {
              boxCoder_ = new global::Tensorflow.Models.ObjectDetection.Protos.BoxCoder();
            }
            input.ReadMessage(boxCoder_);
            break;
          }
          case 42: {
            if (matcher_ == null) {
              matcher_ = new global::Tensorflow.Models.ObjectDetection.Protos.Matcher();
            }
            input.ReadMessage(matcher_);
            break;
          }
          case 50: {
            if (similarityCalculator_ == null) {
              similarityCalculator_ = new global::Tensorflow.Models.ObjectDetection.Protos.RegionSimilarityCalculator();
            }
            input.ReadMessage(similarityCalculator_);
            break;
          }
          case 58: {
            if (boxPredictor_ == null) {
              boxPredictor_ = new global::Tensorflow.Models.ObjectDetection.Protos.BoxPredictor();
            }
            input.ReadMessage(boxPredictor_);
            break;
          }
          case 66: {
            if (anchorGenerator_ == null) {
              anchorGenerator_ = new global::Tensorflow.Models.ObjectDetection.Protos.AnchorGenerator();
            }
            input.ReadMessage(anchorGenerator_);
            break;
          }
          case 74: {
            if (postProcessing_ == null) {
              postProcessing_ = new global::Tensorflow.Models.ObjectDetection.Protos.PostProcessing();
            }
            input.ReadMessage(postProcessing_);
            break;
          }
          case 80: {
            NormalizeLossByNumMatches = input.ReadBool();
            break;
          }
          case 90: {
            if (loss_ == null) {
              loss_ = new global::Tensorflow.Models.ObjectDetection.Protos.Loss();
            }
            input.ReadMessage(loss_);
            break;
          }
          case 96: {
            EncodeBackgroundAsZeros = input.ReadBool();
            break;
          }
          case 109: {
            NegativeClassWeight = input.ReadFloat();
            break;
          }
          case 112: {
            NormalizeLocLossByCodesize = input.ReadBool();
            break;
          }
          case 120: {
            InplaceBatchnormUpdate = input.ReadBool();
            break;
          }
          case 128: {
            FreezeBatchnorm = input.ReadBool();
            break;
          }
          case 168: {
            AddBackgroundClass = input.ReadBool();
            break;
          }
          case 176: {
            UseConfidencesAsTargets = input.ReadBool();
            break;
          }
          case 189: {
            ImplicitExampleWeight = input.ReadFloat();
            break;
          }
          case 192: {
            ExplicitBackgroundClass = input.ReadBool();
            break;
          }
          case 202: {
            if (maskHeadConfig_ == null) {
              maskHeadConfig_ = new global::Tensorflow.Models.ObjectDetection.Protos.Ssd.Types.MaskHead();
            }
            input.ReadMessage(maskHeadConfig_);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the Ssd message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Configuration proto for MaskHead.
      /// Next id: 11
      /// </summary>
      public sealed partial class MaskHead : pb::IMessage<MaskHead> {
        private static readonly pb::MessageParser<MaskHead> _parser = new pb::MessageParser<MaskHead>(() => new MaskHead());
        private pb::UnknownFieldSet _unknownFields;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MaskHead> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::Tensorflow.Models.ObjectDetection.Protos.Ssd.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MaskHead() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MaskHead(MaskHead other) : this() {
          maskHeight_ = other.maskHeight_;
          maskWidth_ = other.maskWidth_;
          masksAreClassAgnostic_ = other.masksAreClassAgnostic_;
          maskPredictionConvDepth_ = other.maskPredictionConvDepth_;
          maskPredictionNumConvLayers_ = other.maskPredictionNumConvLayers_;
          convolveThenUpsampleMasks_ = other.convolveThenUpsampleMasks_;
          maskLossWeight_ = other.maskLossWeight_;
          maskLossSampleSize_ = other.maskLossSampleSize_;
          convHyperparams_ = other.convHyperparams_ != null ? other.convHyperparams_.Clone() : null;
          initialCropSize_ = other.initialCropSize_;
          _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MaskHead Clone() {
          return new MaskHead(this);
        }

        /// <summary>Field number for the "mask_height" field.</summary>
        public const int MaskHeightFieldNumber = 1;
        private int maskHeight_;
        /// <summary>
        /// The height and the width of the predicted mask. Only used when
        /// predict_instance_masks is true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MaskHeight {
          get { return maskHeight_; }
          set {
            maskHeight_ = value;
          }
        }

        /// <summary>Field number for the "mask_width" field.</summary>
        public const int MaskWidthFieldNumber = 2;
        private int maskWidth_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MaskWidth {
          get { return maskWidth_; }
          set {
            maskWidth_ = value;
          }
        }

        /// <summary>Field number for the "masks_are_class_agnostic" field.</summary>
        public const int MasksAreClassAgnosticFieldNumber = 3;
        private bool masksAreClassAgnostic_;
        /// <summary>
        /// Whether to predict class agnostic masks. Only used when
        /// predict_instance_masks is true.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool MasksAreClassAgnostic {
          get { return masksAreClassAgnostic_; }
          set {
            masksAreClassAgnostic_ = value;
          }
        }

        /// <summary>Field number for the "mask_prediction_conv_depth" field.</summary>
        public const int MaskPredictionConvDepthFieldNumber = 4;
        private int maskPredictionConvDepth_;
        /// <summary>
        /// The depth for the first conv2d_transpose op applied to the
        /// image_features in the mask prediction branch. If set to 0, the value
        /// will be set automatically based on the number of channels in the image
        /// features and the number of classes.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MaskPredictionConvDepth {
          get { return maskPredictionConvDepth_; }
          set {
            maskPredictionConvDepth_ = value;
          }
        }

        /// <summary>Field number for the "mask_prediction_num_conv_layers" field.</summary>
        public const int MaskPredictionNumConvLayersFieldNumber = 5;
        private int maskPredictionNumConvLayers_;
        /// <summary>
        /// The number of convolutions applied to image_features in the mask
        /// prediction branch.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MaskPredictionNumConvLayers {
          get { return maskPredictionNumConvLayers_; }
          set {
            maskPredictionNumConvLayers_ = value;
          }
        }

        /// <summary>Field number for the "convolve_then_upsample_masks" field.</summary>
        public const int ConvolveThenUpsampleMasksFieldNumber = 6;
        private bool convolveThenUpsampleMasks_;
        /// <summary>
        /// Whether to apply convolutions on mask features before upsampling using
        /// nearest neighbor resizing.
        /// By default, mask features are resized to [`mask_height`, `mask_width`]
        /// before applying convolutions and predicting masks.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool ConvolveThenUpsampleMasks {
          get { return convolveThenUpsampleMasks_; }
          set {
            convolveThenUpsampleMasks_ = value;
          }
        }

        /// <summary>Field number for the "mask_loss_weight" field.</summary>
        public const int MaskLossWeightFieldNumber = 7;
        private float maskLossWeight_;
        /// <summary>
        /// Mask loss weight.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public float MaskLossWeight {
          get { return maskLossWeight_; }
          set {
            maskLossWeight_ = value;
          }
        }

        /// <summary>Field number for the "mask_loss_sample_size" field.</summary>
        public const int MaskLossSampleSizeFieldNumber = 8;
        private int maskLossSampleSize_;
        /// <summary>
        /// Number of boxes to be generated at training time for computing mask loss.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int MaskLossSampleSize {
          get { return maskLossSampleSize_; }
          set {
            maskLossSampleSize_ = value;
          }
        }

        /// <summary>Field number for the "conv_hyperparams" field.</summary>
        public const int ConvHyperparamsFieldNumber = 9;
        private global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams convHyperparams_;
        /// <summary>
        /// Hyperparameters for convolution ops used in the box predictor.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams ConvHyperparams {
          get { return convHyperparams_; }
          set {
            convHyperparams_ = value;
          }
        }

        /// <summary>Field number for the "initial_crop_size" field.</summary>
        public const int InitialCropSizeFieldNumber = 10;
        private int initialCropSize_;
        /// <summary>
        /// Output size (width and height are set to be the same) of the initial
        /// bilinear interpolation based cropping during ROI pooling. Only used when
        /// we have second stage prediction head enabled (e.g. mask head).
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int InitialCropSize {
          get { return initialCropSize_; }
          set {
            initialCropSize_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MaskHead);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MaskHead other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (MaskHeight != other.MaskHeight) return false;
          if (MaskWidth != other.MaskWidth) return false;
          if (MasksAreClassAgnostic != other.MasksAreClassAgnostic) return false;
          if (MaskPredictionConvDepth != other.MaskPredictionConvDepth) return false;
          if (MaskPredictionNumConvLayers != other.MaskPredictionNumConvLayers) return false;
          if (ConvolveThenUpsampleMasks != other.ConvolveThenUpsampleMasks) return false;
          if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(MaskLossWeight, other.MaskLossWeight)) return false;
          if (MaskLossSampleSize != other.MaskLossSampleSize) return false;
          if (!object.Equals(ConvHyperparams, other.ConvHyperparams)) return false;
          if (InitialCropSize != other.InitialCropSize) return false;
          return Equals(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (MaskHeight != 0) hash ^= MaskHeight.GetHashCode();
          if (MaskWidth != 0) hash ^= MaskWidth.GetHashCode();
          if (MasksAreClassAgnostic != false) hash ^= MasksAreClassAgnostic.GetHashCode();
          if (MaskPredictionConvDepth != 0) hash ^= MaskPredictionConvDepth.GetHashCode();
          if (MaskPredictionNumConvLayers != 0) hash ^= MaskPredictionNumConvLayers.GetHashCode();
          if (ConvolveThenUpsampleMasks != false) hash ^= ConvolveThenUpsampleMasks.GetHashCode();
          if (MaskLossWeight != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(MaskLossWeight);
          if (MaskLossSampleSize != 0) hash ^= MaskLossSampleSize.GetHashCode();
          if (convHyperparams_ != null) hash ^= ConvHyperparams.GetHashCode();
          if (InitialCropSize != 0) hash ^= InitialCropSize.GetHashCode();
          if (_unknownFields != null) {
            hash ^= _unknownFields.GetHashCode();
          }
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (MaskHeight != 0) {
            output.WriteRawTag(8);
            output.WriteInt32(MaskHeight);
          }
          if (MaskWidth != 0) {
            output.WriteRawTag(16);
            output.WriteInt32(MaskWidth);
          }
          if (MasksAreClassAgnostic != false) {
            output.WriteRawTag(24);
            output.WriteBool(MasksAreClassAgnostic);
          }
          if (MaskPredictionConvDepth != 0) {
            output.WriteRawTag(32);
            output.WriteInt32(MaskPredictionConvDepth);
          }
          if (MaskPredictionNumConvLayers != 0) {
            output.WriteRawTag(40);
            output.WriteInt32(MaskPredictionNumConvLayers);
          }
          if (ConvolveThenUpsampleMasks != false) {
            output.WriteRawTag(48);
            output.WriteBool(ConvolveThenUpsampleMasks);
          }
          if (MaskLossWeight != 0F) {
            output.WriteRawTag(61);
            output.WriteFloat(MaskLossWeight);
          }
          if (MaskLossSampleSize != 0) {
            output.WriteRawTag(64);
            output.WriteInt32(MaskLossSampleSize);
          }
          if (convHyperparams_ != null) {
            output.WriteRawTag(74);
            output.WriteMessage(ConvHyperparams);
          }
          if (InitialCropSize != 0) {
            output.WriteRawTag(80);
            output.WriteInt32(InitialCropSize);
          }
          if (_unknownFields != null) {
            _unknownFields.WriteTo(output);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (MaskHeight != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskHeight);
          }
          if (MaskWidth != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskWidth);
          }
          if (MasksAreClassAgnostic != false) {
            size += 1 + 1;
          }
          if (MaskPredictionConvDepth != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskPredictionConvDepth);
          }
          if (MaskPredictionNumConvLayers != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskPredictionNumConvLayers);
          }
          if (ConvolveThenUpsampleMasks != false) {
            size += 1 + 1;
          }
          if (MaskLossWeight != 0F) {
            size += 1 + 4;
          }
          if (MaskLossSampleSize != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaskLossSampleSize);
          }
          if (convHyperparams_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConvHyperparams);
          }
          if (InitialCropSize != 0) {
            size += 1 + pb::CodedOutputStream.ComputeInt32Size(InitialCropSize);
          }
          if (_unknownFields != null) {
            size += _unknownFields.CalculateSize();
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MaskHead other) {
          if (other == null) {
            return;
          }
          if (other.MaskHeight != 0) {
            MaskHeight = other.MaskHeight;
          }
          if (other.MaskWidth != 0) {
            MaskWidth = other.MaskWidth;
          }
          if (other.MasksAreClassAgnostic != false) {
            MasksAreClassAgnostic = other.MasksAreClassAgnostic;
          }
          if (other.MaskPredictionConvDepth != 0) {
            MaskPredictionConvDepth = other.MaskPredictionConvDepth;
          }
          if (other.MaskPredictionNumConvLayers != 0) {
            MaskPredictionNumConvLayers = other.MaskPredictionNumConvLayers;
          }
          if (other.ConvolveThenUpsampleMasks != false) {
            ConvolveThenUpsampleMasks = other.ConvolveThenUpsampleMasks;
          }
          if (other.MaskLossWeight != 0F) {
            MaskLossWeight = other.MaskLossWeight;
          }
          if (other.MaskLossSampleSize != 0) {
            MaskLossSampleSize = other.MaskLossSampleSize;
          }
          if (other.convHyperparams_ != null) {
            if (convHyperparams_ == null) {
              convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
            }
            ConvHyperparams.MergeFrom(other.ConvHyperparams);
          }
          if (other.InitialCropSize != 0) {
            InitialCropSize = other.InitialCropSize;
          }
          _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
                break;
              case 8: {
                MaskHeight = input.ReadInt32();
                break;
              }
              case 16: {
                MaskWidth = input.ReadInt32();
                break;
              }
              case 24: {
                MasksAreClassAgnostic = input.ReadBool();
                break;
              }
              case 32: {
                MaskPredictionConvDepth = input.ReadInt32();
                break;
              }
              case 40: {
                MaskPredictionNumConvLayers = input.ReadInt32();
                break;
              }
              case 48: {
                ConvolveThenUpsampleMasks = input.ReadBool();
                break;
              }
              case 61: {
                MaskLossWeight = input.ReadFloat();
                break;
              }
              case 64: {
                MaskLossSampleSize = input.ReadInt32();
                break;
              }
              case 74: {
                if (convHyperparams_ == null) {
                  convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
                }
                input.ReadMessage(convHyperparams_);
                break;
              }
              case 80: {
                InitialCropSize = input.ReadInt32();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class SsdFeatureExtractor : pb::IMessage<SsdFeatureExtractor> {
    private static readonly pb::MessageParser<SsdFeatureExtractor> _parser = new pb::MessageParser<SsdFeatureExtractor>(() => new SsdFeatureExtractor());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SsdFeatureExtractor> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.SsdReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SsdFeatureExtractor() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SsdFeatureExtractor(SsdFeatureExtractor other) : this() {
      type_ = other.type_;
      depthMultiplier_ = other.depthMultiplier_;
      minDepth_ = other.minDepth_;
      convHyperparams_ = other.convHyperparams_ != null ? other.convHyperparams_.Clone() : null;
      overrideBaseFeatureExtractorHyperparams_ = other.overrideBaseFeatureExtractorHyperparams_;
      padToMultiple_ = other.padToMultiple_;
      useExplicitPadding_ = other.useExplicitPadding_;
      useDepthwise_ = other.useDepthwise_;
      fpn_ = other.fpn_ != null ? other.fpn_.Clone() : null;
      replacePreprocessorWithPlaceholder_ = other.replacePreprocessorWithPlaceholder_;
      numLayers_ = other.numLayers_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SsdFeatureExtractor Clone() {
      return new SsdFeatureExtractor(this);
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 1;
    private string type_ = "";
    /// <summary>
    /// Type of ssd feature extractor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Type {
      get { return type_; }
      set {
        type_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "depth_multiplier" field.</summary>
    public const int DepthMultiplierFieldNumber = 2;
    private float depthMultiplier_;
    /// <summary>
    /// The factor to alter the depth of the channels in the feature extractor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float DepthMultiplier {
      get { return depthMultiplier_; }
      set {
        depthMultiplier_ = value;
      }
    }

    /// <summary>Field number for the "min_depth" field.</summary>
    public const int MinDepthFieldNumber = 3;
    private int minDepth_;
    /// <summary>
    /// Minimum number of the channels in the feature extractor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinDepth {
      get { return minDepth_; }
      set {
        minDepth_ = value;
      }
    }

    /// <summary>Field number for the "conv_hyperparams" field.</summary>
    public const int ConvHyperparamsFieldNumber = 4;
    private global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams convHyperparams_;
    /// <summary>
    /// Hyperparameters that affect the layers of feature extractor added on top
    /// of the base feature extractor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams ConvHyperparams {
      get { return convHyperparams_; }
      set {
        convHyperparams_ = value;
      }
    }

    /// <summary>Field number for the "override_base_feature_extractor_hyperparams" field.</summary>
    public const int OverrideBaseFeatureExtractorHyperparamsFieldNumber = 9;
    private bool overrideBaseFeatureExtractorHyperparams_;
    /// <summary>
    /// Normally, SSD feature extractors are constructed by reusing an existing
    /// base feature extractor (that has its own hyperparams) and adding new layers
    /// on top of it. `conv_hyperparams` above normally applies only to the new
    /// layers while base feature extractor uses its own default hyperparams. If
    /// this value is set to true, the base feature extractor's hyperparams will be
    /// overridden with the `conv_hyperparams`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool OverrideBaseFeatureExtractorHyperparams {
      get { return overrideBaseFeatureExtractorHyperparams_; }
      set {
        overrideBaseFeatureExtractorHyperparams_ = value;
      }
    }

    /// <summary>Field number for the "pad_to_multiple" field.</summary>
    public const int PadToMultipleFieldNumber = 5;
    private int padToMultiple_;
    /// <summary>
    /// The nearest multiple to zero-pad the input height and width dimensions to.
    /// For example, if pad_to_multiple = 2, input dimensions are zero-padded
    /// until the resulting dimensions are even.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int PadToMultiple {
      get { return padToMultiple_; }
      set {
        padToMultiple_ = value;
      }
    }

    /// <summary>Field number for the "use_explicit_padding" field.</summary>
    public const int UseExplicitPaddingFieldNumber = 7;
    private bool useExplicitPadding_;
    /// <summary>
    /// Whether to use explicit padding when extracting SSD multiresolution
    /// features. This will also apply to the base feature extractor if a MobileNet
    /// architecture is used.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseExplicitPadding {
      get { return useExplicitPadding_; }
      set {
        useExplicitPadding_ = value;
      }
    }

    /// <summary>Field number for the "use_depthwise" field.</summary>
    public const int UseDepthwiseFieldNumber = 8;
    private bool useDepthwise_;
    /// <summary>
    /// Whether to use depthwise separable convolutions for to extract additional
    /// feature maps added by SSD.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseDepthwise {
      get { return useDepthwise_; }
      set {
        useDepthwise_ = value;
      }
    }

    /// <summary>Field number for the "fpn" field.</summary>
    public const int FpnFieldNumber = 10;
    private global::Tensorflow.Models.ObjectDetection.Protos.FeaturePyramidNetworks fpn_;
    /// <summary>
    /// Feature Pyramid Networks config.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.FeaturePyramidNetworks Fpn {
      get { return fpn_; }
      set {
        fpn_ = value;
      }
    }

    /// <summary>Field number for the "replace_preprocessor_with_placeholder" field.</summary>
    public const int ReplacePreprocessorWithPlaceholderFieldNumber = 11;
    private bool replacePreprocessorWithPlaceholder_;
    /// <summary>
    /// If true, replace preprocess function of feature extractor with a
    /// placeholder. This should only be used if all the image preprocessing steps
    /// happen outside the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool ReplacePreprocessorWithPlaceholder {
      get { return replacePreprocessorWithPlaceholder_; }
      set {
        replacePreprocessorWithPlaceholder_ = value;
      }
    }

    /// <summary>Field number for the "num_layers" field.</summary>
    public const int NumLayersFieldNumber = 12;
    private int numLayers_;
    /// <summary>
    /// The number of SSD layers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumLayers {
      get { return numLayers_; }
      set {
        numLayers_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SsdFeatureExtractor);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SsdFeatureExtractor other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Type != other.Type) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(DepthMultiplier, other.DepthMultiplier)) return false;
      if (MinDepth != other.MinDepth) return false;
      if (!object.Equals(ConvHyperparams, other.ConvHyperparams)) return false;
      if (OverrideBaseFeatureExtractorHyperparams != other.OverrideBaseFeatureExtractorHyperparams) return false;
      if (PadToMultiple != other.PadToMultiple) return false;
      if (UseExplicitPadding != other.UseExplicitPadding) return false;
      if (UseDepthwise != other.UseDepthwise) return false;
      if (!object.Equals(Fpn, other.Fpn)) return false;
      if (ReplacePreprocessorWithPlaceholder != other.ReplacePreprocessorWithPlaceholder) return false;
      if (NumLayers != other.NumLayers) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Type.Length != 0) hash ^= Type.GetHashCode();
      if (DepthMultiplier != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(DepthMultiplier);
      if (MinDepth != 0) hash ^= MinDepth.GetHashCode();
      if (convHyperparams_ != null) hash ^= ConvHyperparams.GetHashCode();
      if (OverrideBaseFeatureExtractorHyperparams != false) hash ^= OverrideBaseFeatureExtractorHyperparams.GetHashCode();
      if (PadToMultiple != 0) hash ^= PadToMultiple.GetHashCode();
      if (UseExplicitPadding != false) hash ^= UseExplicitPadding.GetHashCode();
      if (UseDepthwise != false) hash ^= UseDepthwise.GetHashCode();
      if (fpn_ != null) hash ^= Fpn.GetHashCode();
      if (ReplacePreprocessorWithPlaceholder != false) hash ^= ReplacePreprocessorWithPlaceholder.GetHashCode();
      if (NumLayers != 0) hash ^= NumLayers.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Type.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Type);
      }
      if (DepthMultiplier != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(DepthMultiplier);
      }
      if (MinDepth != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(MinDepth);
      }
      if (convHyperparams_ != null) {
        output.WriteRawTag(34);
        output.WriteMessage(ConvHyperparams);
      }
      if (PadToMultiple != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(PadToMultiple);
      }
      if (UseExplicitPadding != false) {
        output.WriteRawTag(56);
        output.WriteBool(UseExplicitPadding);
      }
      if (UseDepthwise != false) {
        output.WriteRawTag(64);
        output.WriteBool(UseDepthwise);
      }
      if (OverrideBaseFeatureExtractorHyperparams != false) {
        output.WriteRawTag(72);
        output.WriteBool(OverrideBaseFeatureExtractorHyperparams);
      }
      if (fpn_ != null) {
        output.WriteRawTag(82);
        output.WriteMessage(Fpn);
      }
      if (ReplacePreprocessorWithPlaceholder != false) {
        output.WriteRawTag(88);
        output.WriteBool(ReplacePreprocessorWithPlaceholder);
      }
      if (NumLayers != 0) {
        output.WriteRawTag(96);
        output.WriteInt32(NumLayers);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Type.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Type);
      }
      if (DepthMultiplier != 0F) {
        size += 1 + 4;
      }
      if (MinDepth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinDepth);
      }
      if (convHyperparams_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ConvHyperparams);
      }
      if (OverrideBaseFeatureExtractorHyperparams != false) {
        size += 1 + 1;
      }
      if (PadToMultiple != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PadToMultiple);
      }
      if (UseExplicitPadding != false) {
        size += 1 + 1;
      }
      if (UseDepthwise != false) {
        size += 1 + 1;
      }
      if (fpn_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Fpn);
      }
      if (ReplacePreprocessorWithPlaceholder != false) {
        size += 1 + 1;
      }
      if (NumLayers != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(NumLayers);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SsdFeatureExtractor other) {
      if (other == null) {
        return;
      }
      if (other.Type.Length != 0) {
        Type = other.Type;
      }
      if (other.DepthMultiplier != 0F) {
        DepthMultiplier = other.DepthMultiplier;
      }
      if (other.MinDepth != 0) {
        MinDepth = other.MinDepth;
      }
      if (other.convHyperparams_ != null) {
        if (convHyperparams_ == null) {
          convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
        }
        ConvHyperparams.MergeFrom(other.ConvHyperparams);
      }
      if (other.OverrideBaseFeatureExtractorHyperparams != false) {
        OverrideBaseFeatureExtractorHyperparams = other.OverrideBaseFeatureExtractorHyperparams;
      }
      if (other.PadToMultiple != 0) {
        PadToMultiple = other.PadToMultiple;
      }
      if (other.UseExplicitPadding != false) {
        UseExplicitPadding = other.UseExplicitPadding;
      }
      if (other.UseDepthwise != false) {
        UseDepthwise = other.UseDepthwise;
      }
      if (other.fpn_ != null) {
        if (fpn_ == null) {
          fpn_ = new global::Tensorflow.Models.ObjectDetection.Protos.FeaturePyramidNetworks();
        }
        Fpn.MergeFrom(other.Fpn);
      }
      if (other.ReplacePreprocessorWithPlaceholder != false) {
        ReplacePreprocessorWithPlaceholder = other.ReplacePreprocessorWithPlaceholder;
      }
      if (other.NumLayers != 0) {
        NumLayers = other.NumLayers;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            Type = input.ReadString();
            break;
          }
          case 21: {
            DepthMultiplier = input.ReadFloat();
            break;
          }
          case 24: {
            MinDepth = input.ReadInt32();
            break;
          }
          case 34: {
            if (convHyperparams_ == null) {
              convHyperparams_ = new global::Tensorflow.Models.ObjectDetection.Protos.Hyperparams();
            }
            input.ReadMessage(convHyperparams_);
            break;
          }
          case 40: {
            PadToMultiple = input.ReadInt32();
            break;
          }
          case 56: {
            UseExplicitPadding = input.ReadBool();
            break;
          }
          case 64: {
            UseDepthwise = input.ReadBool();
            break;
          }
          case 72: {
            OverrideBaseFeatureExtractorHyperparams = input.ReadBool();
            break;
          }
          case 82: {
            if (fpn_ == null) {
              fpn_ = new global::Tensorflow.Models.ObjectDetection.Protos.FeaturePyramidNetworks();
            }
            input.ReadMessage(fpn_);
            break;
          }
          case 88: {
            ReplacePreprocessorWithPlaceholder = input.ReadBool();
            break;
          }
          case 96: {
            NumLayers = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Configuration for Feature Pyramid Networks.
  /// </summary>
  public sealed partial class FeaturePyramidNetworks : pb::IMessage<FeaturePyramidNetworks> {
    private static readonly pb::MessageParser<FeaturePyramidNetworks> _parser = new pb::MessageParser<FeaturePyramidNetworks>(() => new FeaturePyramidNetworks());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FeaturePyramidNetworks> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.SsdReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeaturePyramidNetworks() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeaturePyramidNetworks(FeaturePyramidNetworks other) : this() {
      minLevel_ = other.minLevel_;
      maxLevel_ = other.maxLevel_;
      additionalLayerDepth_ = other.additionalLayerDepth_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FeaturePyramidNetworks Clone() {
      return new FeaturePyramidNetworks(this);
    }

    /// <summary>Field number for the "min_level" field.</summary>
    public const int MinLevelFieldNumber = 1;
    private int minLevel_;
    /// <summary>
    /// minimum level in feature pyramid
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinLevel {
      get { return minLevel_; }
      set {
        minLevel_ = value;
      }
    }

    /// <summary>Field number for the "max_level" field.</summary>
    public const int MaxLevelFieldNumber = 2;
    private int maxLevel_;
    /// <summary>
    /// maximum level in feature pyramid
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxLevel {
      get { return maxLevel_; }
      set {
        maxLevel_ = value;
      }
    }

    /// <summary>Field number for the "additional_layer_depth" field.</summary>
    public const int AdditionalLayerDepthFieldNumber = 3;
    private int additionalLayerDepth_;
    /// <summary>
    /// channel depth for additional coarse feature layers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int AdditionalLayerDepth {
      get { return additionalLayerDepth_; }
      set {
        additionalLayerDepth_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FeaturePyramidNetworks);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FeaturePyramidNetworks other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MinLevel != other.MinLevel) return false;
      if (MaxLevel != other.MaxLevel) return false;
      if (AdditionalLayerDepth != other.AdditionalLayerDepth) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinLevel != 0) hash ^= MinLevel.GetHashCode();
      if (MaxLevel != 0) hash ^= MaxLevel.GetHashCode();
      if (AdditionalLayerDepth != 0) hash ^= AdditionalLayerDepth.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinLevel != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(MinLevel);
      }
      if (MaxLevel != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(MaxLevel);
      }
      if (AdditionalLayerDepth != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(AdditionalLayerDepth);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinLevel);
      }
      if (MaxLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxLevel);
      }
      if (AdditionalLayerDepth != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(AdditionalLayerDepth);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FeaturePyramidNetworks other) {
      if (other == null) {
        return;
      }
      if (other.MinLevel != 0) {
        MinLevel = other.MinLevel;
      }
      if (other.MaxLevel != 0) {
        MaxLevel = other.MaxLevel;
      }
      if (other.AdditionalLayerDepth != 0) {
        AdditionalLayerDepth = other.AdditionalLayerDepth;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MinLevel = input.ReadInt32();
            break;
          }
          case 16: {
            MaxLevel = input.ReadInt32();
            break;
          }
          case 24: {
            AdditionalLayerDepth = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
