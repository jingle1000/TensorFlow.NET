// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: object_detection/protos/input_reader.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Models.ObjectDetection.Protos {

  /// <summary>Holder for reflection information generated from object_detection/protos/input_reader.proto</summary>
  public static partial class InputReaderReflection {

    #region Descriptor
    /// <summary>File descriptor for object_detection/protos/input_reader.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static InputReaderReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CipvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9pbnB1dF9yZWFkZXIucHJvdG8S",
            "F29iamVjdF9kZXRlY3Rpb24ucHJvdG9zIqsGCgtJbnB1dFJlYWRlchIMCgRu",
            "YW1lGBcgASgJEhYKDmxhYmVsX21hcF9wYXRoGAEgASgJEg8KB3NodWZmbGUY",
            "AiABKAgSGwoTc2h1ZmZsZV9idWZmZXJfc2l6ZRgLIAEoDRIlCh1maWxlbmFt",
            "ZXNfc2h1ZmZsZV9idWZmZXJfc2l6ZRgMIAEoDRISCgpudW1fZXBvY2hzGAUg",
            "ASgNEh4KFnNhbXBsZV8xX29mX25fZXhhbXBsZXMYFiABKA0SEwoLbnVtX3Jl",
            "YWRlcnMYBiABKA0SHAoUbnVtX3BhcmFsbGVsX2JhdGNoZXMYEyABKA0SHAoU",
            "bnVtX3ByZWZldGNoX2JhdGNoZXMYFCABKAUSFgoOcXVldWVfY2FwYWNpdHkY",
            "AyABKA0SGQoRbWluX2FmdGVyX2RlcXVldWUYBCABKA0SGQoRcmVhZF9ibG9j",
            "a19sZW5ndGgYDyABKA0SFQoNcHJlZmV0Y2hfc2l6ZRgNIAEoDRIeChZudW1f",
            "cGFyYWxsZWxfbWFwX2NhbGxzGA4gASgNEh8KF251bV9hZGRpdGlvbmFsX2No",
            "YW5uZWxzGBIgASgFEhUKDW51bV9rZXlwb2ludHMYECABKA0SGwoTbWF4X251",
            "bWJlcl9vZl9ib3hlcxgVIAEoBRIeChZsb2FkX211bHRpY2xhc3Nfc2NvcmVz",
            "GBggASgIEhsKE2xvYWRfaW5zdGFuY2VfbWFza3MYByABKAgSPAoJbWFza190",
            "eXBlGAogASgOMikub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuSW5zdGFuY2VN",
            "YXNrVHlwZRIYChB1c2VfZGlzcGxheV9uYW1lGBEgASgIEk4KFnRmX3JlY29y",
            "ZF9pbnB1dF9yZWFkZXIYCCABKAsyLC5vYmplY3RfZGV0ZWN0aW9uLnByb3Rv",
            "cy5URlJlY29yZElucHV0UmVhZGVySAASTQoVZXh0ZXJuYWxfaW5wdXRfcmVh",
            "ZGVyGAkgASgLMiwub2JqZWN0X2RldGVjdGlvbi5wcm90b3MuRXh0ZXJuYWxJ",
            "bnB1dFJlYWRlckgAQg4KDGlucHV0X3JlYWRlciIpChNURlJlY29yZElucHV0",
            "UmVhZGVyEhIKCmlucHV0X3BhdGgYASADKAkiFQoTRXh0ZXJuYWxJbnB1dFJl",
            "YWRlcipDChBJbnN0YW5jZU1hc2tUeXBlEgsKB0RFRkFVTFQQABITCg9OVU1F",
            "UklDQUxfTUFTS1MQARINCglQTkdfTUFTS1MQAmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::Tensorflow.Models.ObjectDetection.Protos.InstanceMaskType), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.InputReader), global::Tensorflow.Models.ObjectDetection.Protos.InputReader.Parser, new[]{ "Name", "LabelMapPath", "Shuffle", "ShuffleBufferSize", "FilenamesShuffleBufferSize", "NumEpochs", "Sample1OfNExamples", "NumReaders", "NumParallelBatches", "NumPrefetchBatches", "QueueCapacity", "MinAfterDequeue", "ReadBlockLength", "PrefetchSize", "NumParallelMapCalls", "NumAdditionalChannels", "NumKeypoints", "MaxNumberOfBoxes", "LoadMulticlassScores", "LoadInstanceMasks", "MaskType", "UseDisplayName", "TfRecordInputReader", "ExternalInputReader" }, new[]{ "InputReader" }, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.TFRecordInputReader), global::Tensorflow.Models.ObjectDetection.Protos.TFRecordInputReader.Parser, new[]{ "InputPath" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.ExternalInputReader), global::Tensorflow.Models.ObjectDetection.Protos.ExternalInputReader.Parser, null, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// Instance mask format. Note that PNG masks are much more space efficient.
  /// </summary>
  public enum InstanceMaskType {
    /// <summary>
    /// Default implementation, currently NUMERICAL_MASKS
    /// </summary>
    [pbr::OriginalName("DEFAULT")] Default = 0,
    /// <summary>
    /// [num_masks, H, W] float32 binary masks.
    /// </summary>
    [pbr::OriginalName("NUMERICAL_MASKS")] NumericalMasks = 1,
    /// <summary>
    /// Encoded PNG masks.
    /// </summary>
    [pbr::OriginalName("PNG_MASKS")] PngMasks = 2,
  }

  #endregion

  #region Messages
  /// <summary>
  /// Next id: 25
  /// </summary>
  public sealed partial class InputReader : pb::IMessage<InputReader> {
    private static readonly pb::MessageParser<InputReader> _parser = new pb::MessageParser<InputReader>(() => new InputReader());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<InputReader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.InputReaderReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InputReader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InputReader(InputReader other) : this() {
      name_ = other.name_;
      labelMapPath_ = other.labelMapPath_;
      shuffle_ = other.shuffle_;
      shuffleBufferSize_ = other.shuffleBufferSize_;
      filenamesShuffleBufferSize_ = other.filenamesShuffleBufferSize_;
      numEpochs_ = other.numEpochs_;
      sample1OfNExamples_ = other.sample1OfNExamples_;
      numReaders_ = other.numReaders_;
      numParallelBatches_ = other.numParallelBatches_;
      numPrefetchBatches_ = other.numPrefetchBatches_;
      queueCapacity_ = other.queueCapacity_;
      minAfterDequeue_ = other.minAfterDequeue_;
      readBlockLength_ = other.readBlockLength_;
      prefetchSize_ = other.prefetchSize_;
      numParallelMapCalls_ = other.numParallelMapCalls_;
      numAdditionalChannels_ = other.numAdditionalChannels_;
      numKeypoints_ = other.numKeypoints_;
      maxNumberOfBoxes_ = other.maxNumberOfBoxes_;
      loadMulticlassScores_ = other.loadMulticlassScores_;
      loadInstanceMasks_ = other.loadInstanceMasks_;
      maskType_ = other.maskType_;
      useDisplayName_ = other.useDisplayName_;
      switch (other.InputReaderCase) {
        case InputReaderOneofCase.TfRecordInputReader:
          TfRecordInputReader = other.TfRecordInputReader.Clone();
          break;
        case InputReaderOneofCase.ExternalInputReader:
          ExternalInputReader = other.ExternalInputReader.Clone();
          break;
      }

      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InputReader Clone() {
      return new InputReader(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 23;
    private string name_ = "";
    /// <summary>
    /// Name of input reader. Typically used to describe the dataset that is read
    /// by this input reader.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "label_map_path" field.</summary>
    public const int LabelMapPathFieldNumber = 1;
    private string labelMapPath_ = "";
    /// <summary>
    /// Path to StringIntLabelMap pbtxt file specifying the mapping from string
    /// labels to integer ids.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string LabelMapPath {
      get { return labelMapPath_; }
      set {
        labelMapPath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "shuffle" field.</summary>
    public const int ShuffleFieldNumber = 2;
    private bool shuffle_;
    /// <summary>
    /// Whether data should be processed in the order they are read in, or
    /// shuffled randomly.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Shuffle {
      get { return shuffle_; }
      set {
        shuffle_ = value;
      }
    }

    /// <summary>Field number for the "shuffle_buffer_size" field.</summary>
    public const int ShuffleBufferSizeFieldNumber = 11;
    private uint shuffleBufferSize_;
    /// <summary>
    /// Buffer size to be used when shuffling.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ShuffleBufferSize {
      get { return shuffleBufferSize_; }
      set {
        shuffleBufferSize_ = value;
      }
    }

    /// <summary>Field number for the "filenames_shuffle_buffer_size" field.</summary>
    public const int FilenamesShuffleBufferSizeFieldNumber = 12;
    private uint filenamesShuffleBufferSize_;
    /// <summary>
    /// Buffer size to be used when shuffling file names.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint FilenamesShuffleBufferSize {
      get { return filenamesShuffleBufferSize_; }
      set {
        filenamesShuffleBufferSize_ = value;
      }
    }

    /// <summary>Field number for the "num_epochs" field.</summary>
    public const int NumEpochsFieldNumber = 5;
    private uint numEpochs_;
    /// <summary>
    /// The number of times a data source is read. If set to zero, the data source
    /// will be reused indefinitely.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NumEpochs {
      get { return numEpochs_; }
      set {
        numEpochs_ = value;
      }
    }

    /// <summary>Field number for the "sample_1_of_n_examples" field.</summary>
    public const int Sample1OfNExamplesFieldNumber = 22;
    private uint sample1OfNExamples_;
    /// <summary>
    /// Integer representing how often an example should be sampled. To feed
    /// only 1/3 of your data into your model, set `sample_1_of_n_examples` to 3.
    /// This is particularly useful for evaluation, where you might not prefer to
    /// evaluate all of your samples.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint Sample1OfNExamples {
      get { return sample1OfNExamples_; }
      set {
        sample1OfNExamples_ = value;
      }
    }

    /// <summary>Field number for the "num_readers" field.</summary>
    public const int NumReadersFieldNumber = 6;
    private uint numReaders_;
    /// <summary>
    /// Number of file shards to read in parallel.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NumReaders {
      get { return numReaders_; }
      set {
        numReaders_ = value;
      }
    }

    /// <summary>Field number for the "num_parallel_batches" field.</summary>
    public const int NumParallelBatchesFieldNumber = 19;
    private uint numParallelBatches_;
    /// <summary>
    /// Number of batches to produce in parallel. If this is run on a 2x2 TPU set
    /// this to 8.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NumParallelBatches {
      get { return numParallelBatches_; }
      set {
        numParallelBatches_ = value;
      }
    }

    /// <summary>Field number for the "num_prefetch_batches" field.</summary>
    public const int NumPrefetchBatchesFieldNumber = 20;
    private int numPrefetchBatches_;
    /// <summary>
    /// Number of batches to prefetch. Prefetch decouples input pipeline and
    /// model so they can be pipelined resulting in higher throughput. Set this
    /// to a small constant and increment linearly until the improvements become
    /// marginal or you exceed your cpu memory budget. Setting this to -1,
    /// automatically tunes this value for you.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumPrefetchBatches {
      get { return numPrefetchBatches_; }
      set {
        numPrefetchBatches_ = value;
      }
    }

    /// <summary>Field number for the "queue_capacity" field.</summary>
    public const int QueueCapacityFieldNumber = 3;
    private uint queueCapacity_;
    /// <summary>
    /// Maximum number of records to keep in reader queue.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint QueueCapacity {
      get { return queueCapacity_; }
      set {
        queueCapacity_ = value;
      }
    }

    /// <summary>Field number for the "min_after_dequeue" field.</summary>
    public const int MinAfterDequeueFieldNumber = 4;
    private uint minAfterDequeue_;
    /// <summary>
    /// Minimum number of records to keep in reader queue. A large value is needed
    /// to generate a good random shuffle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint MinAfterDequeue {
      get { return minAfterDequeue_; }
      set {
        minAfterDequeue_ = value;
      }
    }

    /// <summary>Field number for the "read_block_length" field.</summary>
    public const int ReadBlockLengthFieldNumber = 15;
    private uint readBlockLength_;
    /// <summary>
    /// Number of records to read from each reader at once.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint ReadBlockLength {
      get { return readBlockLength_; }
      set {
        readBlockLength_ = value;
      }
    }

    /// <summary>Field number for the "prefetch_size" field.</summary>
    public const int PrefetchSizeFieldNumber = 13;
    private uint prefetchSize_;
    /// <summary>
    /// Number of decoded records to prefetch before batching.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint PrefetchSize {
      get { return prefetchSize_; }
      set {
        prefetchSize_ = value;
      }
    }

    /// <summary>Field number for the "num_parallel_map_calls" field.</summary>
    public const int NumParallelMapCallsFieldNumber = 14;
    private uint numParallelMapCalls_;
    /// <summary>
    /// Number of parallel decode ops to apply.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NumParallelMapCalls {
      get { return numParallelMapCalls_; }
      set {
        numParallelMapCalls_ = value;
      }
    }

    /// <summary>Field number for the "num_additional_channels" field.</summary>
    public const int NumAdditionalChannelsFieldNumber = 18;
    private int numAdditionalChannels_;
    /// <summary>
    /// If positive, TfExampleDecoder will try to decode rasters of additional
    /// channels from tf.Examples.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int NumAdditionalChannels {
      get { return numAdditionalChannels_; }
      set {
        numAdditionalChannels_ = value;
      }
    }

    /// <summary>Field number for the "num_keypoints" field.</summary>
    public const int NumKeypointsFieldNumber = 16;
    private uint numKeypoints_;
    /// <summary>
    /// Number of groundtruth keypoints per object.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public uint NumKeypoints {
      get { return numKeypoints_; }
      set {
        numKeypoints_ = value;
      }
    }

    /// <summary>Field number for the "max_number_of_boxes" field.</summary>
    public const int MaxNumberOfBoxesFieldNumber = 21;
    private int maxNumberOfBoxes_;
    /// <summary>
    /// Maximum number of boxes to pad to during training / evaluation.
    /// Set this to at least the maximum amount of boxes in the input data,
    /// otherwise some groundtruth boxes may be clipped.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxNumberOfBoxes {
      get { return maxNumberOfBoxes_; }
      set {
        maxNumberOfBoxes_ = value;
      }
    }

    /// <summary>Field number for the "load_multiclass_scores" field.</summary>
    public const int LoadMulticlassScoresFieldNumber = 24;
    private bool loadMulticlassScores_;
    /// <summary>
    /// Whether to load multiclass scores from the dataset.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool LoadMulticlassScores {
      get { return loadMulticlassScores_; }
      set {
        loadMulticlassScores_ = value;
      }
    }

    /// <summary>Field number for the "load_instance_masks" field.</summary>
    public const int LoadInstanceMasksFieldNumber = 7;
    private bool loadInstanceMasks_;
    /// <summary>
    /// Whether to load groundtruth instance masks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool LoadInstanceMasks {
      get { return loadInstanceMasks_; }
      set {
        loadInstanceMasks_ = value;
      }
    }

    /// <summary>Field number for the "mask_type" field.</summary>
    public const int MaskTypeFieldNumber = 10;
    private global::Tensorflow.Models.ObjectDetection.Protos.InstanceMaskType maskType_ = 0;
    /// <summary>
    /// Type of instance mask.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.InstanceMaskType MaskType {
      get { return maskType_; }
      set {
        maskType_ = value;
      }
    }

    /// <summary>Field number for the "use_display_name" field.</summary>
    public const int UseDisplayNameFieldNumber = 17;
    private bool useDisplayName_;
    /// <summary>
    /// Whether to use the display name when decoding examples. This is only used
    /// when mapping class text strings to integers.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool UseDisplayName {
      get { return useDisplayName_; }
      set {
        useDisplayName_ = value;
      }
    }

    /// <summary>Field number for the "tf_record_input_reader" field.</summary>
    public const int TfRecordInputReaderFieldNumber = 8;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.TFRecordInputReader TfRecordInputReader {
      get { return inputReaderCase_ == InputReaderOneofCase.TfRecordInputReader ? (global::Tensorflow.Models.ObjectDetection.Protos.TFRecordInputReader) inputReader_ : null; }
      set {
        inputReader_ = value;
        inputReaderCase_ = value == null ? InputReaderOneofCase.None : InputReaderOneofCase.TfRecordInputReader;
      }
    }

    /// <summary>Field number for the "external_input_reader" field.</summary>
    public const int ExternalInputReaderFieldNumber = 9;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::Tensorflow.Models.ObjectDetection.Protos.ExternalInputReader ExternalInputReader {
      get { return inputReaderCase_ == InputReaderOneofCase.ExternalInputReader ? (global::Tensorflow.Models.ObjectDetection.Protos.ExternalInputReader) inputReader_ : null; }
      set {
        inputReader_ = value;
        inputReaderCase_ = value == null ? InputReaderOneofCase.None : InputReaderOneofCase.ExternalInputReader;
      }
    }

    private object inputReader_;
    /// <summary>Enum of possible cases for the "input_reader" oneof.</summary>
    public enum InputReaderOneofCase {
      None = 0,
      TfRecordInputReader = 8,
      ExternalInputReader = 9,
    }
    private InputReaderOneofCase inputReaderCase_ = InputReaderOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public InputReaderOneofCase InputReaderCase {
      get { return inputReaderCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearInputReader() {
      inputReaderCase_ = InputReaderOneofCase.None;
      inputReader_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as InputReader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(InputReader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (LabelMapPath != other.LabelMapPath) return false;
      if (Shuffle != other.Shuffle) return false;
      if (ShuffleBufferSize != other.ShuffleBufferSize) return false;
      if (FilenamesShuffleBufferSize != other.FilenamesShuffleBufferSize) return false;
      if (NumEpochs != other.NumEpochs) return false;
      if (Sample1OfNExamples != other.Sample1OfNExamples) return false;
      if (NumReaders != other.NumReaders) return false;
      if (NumParallelBatches != other.NumParallelBatches) return false;
      if (NumPrefetchBatches != other.NumPrefetchBatches) return false;
      if (QueueCapacity != other.QueueCapacity) return false;
      if (MinAfterDequeue != other.MinAfterDequeue) return false;
      if (ReadBlockLength != other.ReadBlockLength) return false;
      if (PrefetchSize != other.PrefetchSize) return false;
      if (NumParallelMapCalls != other.NumParallelMapCalls) return false;
      if (NumAdditionalChannels != other.NumAdditionalChannels) return false;
      if (NumKeypoints != other.NumKeypoints) return false;
      if (MaxNumberOfBoxes != other.MaxNumberOfBoxes) return false;
      if (LoadMulticlassScores != other.LoadMulticlassScores) return false;
      if (LoadInstanceMasks != other.LoadInstanceMasks) return false;
      if (MaskType != other.MaskType) return false;
      if (UseDisplayName != other.UseDisplayName) return false;
      if (!object.Equals(TfRecordInputReader, other.TfRecordInputReader)) return false;
      if (!object.Equals(ExternalInputReader, other.ExternalInputReader)) return false;
      if (InputReaderCase != other.InputReaderCase) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (LabelMapPath.Length != 0) hash ^= LabelMapPath.GetHashCode();
      if (Shuffle != false) hash ^= Shuffle.GetHashCode();
      if (ShuffleBufferSize != 0) hash ^= ShuffleBufferSize.GetHashCode();
      if (FilenamesShuffleBufferSize != 0) hash ^= FilenamesShuffleBufferSize.GetHashCode();
      if (NumEpochs != 0) hash ^= NumEpochs.GetHashCode();
      if (Sample1OfNExamples != 0) hash ^= Sample1OfNExamples.GetHashCode();
      if (NumReaders != 0) hash ^= NumReaders.GetHashCode();
      if (NumParallelBatches != 0) hash ^= NumParallelBatches.GetHashCode();
      if (NumPrefetchBatches != 0) hash ^= NumPrefetchBatches.GetHashCode();
      if (QueueCapacity != 0) hash ^= QueueCapacity.GetHashCode();
      if (MinAfterDequeue != 0) hash ^= MinAfterDequeue.GetHashCode();
      if (ReadBlockLength != 0) hash ^= ReadBlockLength.GetHashCode();
      if (PrefetchSize != 0) hash ^= PrefetchSize.GetHashCode();
      if (NumParallelMapCalls != 0) hash ^= NumParallelMapCalls.GetHashCode();
      if (NumAdditionalChannels != 0) hash ^= NumAdditionalChannels.GetHashCode();
      if (NumKeypoints != 0) hash ^= NumKeypoints.GetHashCode();
      if (MaxNumberOfBoxes != 0) hash ^= MaxNumberOfBoxes.GetHashCode();
      if (LoadMulticlassScores != false) hash ^= LoadMulticlassScores.GetHashCode();
      if (LoadInstanceMasks != false) hash ^= LoadInstanceMasks.GetHashCode();
      if (MaskType != 0) hash ^= MaskType.GetHashCode();
      if (UseDisplayName != false) hash ^= UseDisplayName.GetHashCode();
      if (inputReaderCase_ == InputReaderOneofCase.TfRecordInputReader) hash ^= TfRecordInputReader.GetHashCode();
      if (inputReaderCase_ == InputReaderOneofCase.ExternalInputReader) hash ^= ExternalInputReader.GetHashCode();
      hash ^= (int) inputReaderCase_;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (LabelMapPath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(LabelMapPath);
      }
      if (Shuffle != false) {
        output.WriteRawTag(16);
        output.WriteBool(Shuffle);
      }
      if (QueueCapacity != 0) {
        output.WriteRawTag(24);
        output.WriteUInt32(QueueCapacity);
      }
      if (MinAfterDequeue != 0) {
        output.WriteRawTag(32);
        output.WriteUInt32(MinAfterDequeue);
      }
      if (NumEpochs != 0) {
        output.WriteRawTag(40);
        output.WriteUInt32(NumEpochs);
      }
      if (NumReaders != 0) {
        output.WriteRawTag(48);
        output.WriteUInt32(NumReaders);
      }
      if (LoadInstanceMasks != false) {
        output.WriteRawTag(56);
        output.WriteBool(LoadInstanceMasks);
      }
      if (inputReaderCase_ == InputReaderOneofCase.TfRecordInputReader) {
        output.WriteRawTag(66);
        output.WriteMessage(TfRecordInputReader);
      }
      if (inputReaderCase_ == InputReaderOneofCase.ExternalInputReader) {
        output.WriteRawTag(74);
        output.WriteMessage(ExternalInputReader);
      }
      if (MaskType != 0) {
        output.WriteRawTag(80);
        output.WriteEnum((int) MaskType);
      }
      if (ShuffleBufferSize != 0) {
        output.WriteRawTag(88);
        output.WriteUInt32(ShuffleBufferSize);
      }
      if (FilenamesShuffleBufferSize != 0) {
        output.WriteRawTag(96);
        output.WriteUInt32(FilenamesShuffleBufferSize);
      }
      if (PrefetchSize != 0) {
        output.WriteRawTag(104);
        output.WriteUInt32(PrefetchSize);
      }
      if (NumParallelMapCalls != 0) {
        output.WriteRawTag(112);
        output.WriteUInt32(NumParallelMapCalls);
      }
      if (ReadBlockLength != 0) {
        output.WriteRawTag(120);
        output.WriteUInt32(ReadBlockLength);
      }
      if (NumKeypoints != 0) {
        output.WriteRawTag(128, 1);
        output.WriteUInt32(NumKeypoints);
      }
      if (UseDisplayName != false) {
        output.WriteRawTag(136, 1);
        output.WriteBool(UseDisplayName);
      }
      if (NumAdditionalChannels != 0) {
        output.WriteRawTag(144, 1);
        output.WriteInt32(NumAdditionalChannels);
      }
      if (NumParallelBatches != 0) {
        output.WriteRawTag(152, 1);
        output.WriteUInt32(NumParallelBatches);
      }
      if (NumPrefetchBatches != 0) {
        output.WriteRawTag(160, 1);
        output.WriteInt32(NumPrefetchBatches);
      }
      if (MaxNumberOfBoxes != 0) {
        output.WriteRawTag(168, 1);
        output.WriteInt32(MaxNumberOfBoxes);
      }
      if (Sample1OfNExamples != 0) {
        output.WriteRawTag(176, 1);
        output.WriteUInt32(Sample1OfNExamples);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(186, 1);
        output.WriteString(Name);
      }
      if (LoadMulticlassScores != false) {
        output.WriteRawTag(192, 1);
        output.WriteBool(LoadMulticlassScores);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (LabelMapPath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(LabelMapPath);
      }
      if (Shuffle != false) {
        size += 1 + 1;
      }
      if (ShuffleBufferSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ShuffleBufferSize);
      }
      if (FilenamesShuffleBufferSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(FilenamesShuffleBufferSize);
      }
      if (NumEpochs != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumEpochs);
      }
      if (Sample1OfNExamples != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(Sample1OfNExamples);
      }
      if (NumReaders != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumReaders);
      }
      if (NumParallelBatches != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(NumParallelBatches);
      }
      if (NumPrefetchBatches != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(NumPrefetchBatches);
      }
      if (QueueCapacity != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(QueueCapacity);
      }
      if (MinAfterDequeue != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(MinAfterDequeue);
      }
      if (ReadBlockLength != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(ReadBlockLength);
      }
      if (PrefetchSize != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(PrefetchSize);
      }
      if (NumParallelMapCalls != 0) {
        size += 1 + pb::CodedOutputStream.ComputeUInt32Size(NumParallelMapCalls);
      }
      if (NumAdditionalChannels != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(NumAdditionalChannels);
      }
      if (NumKeypoints != 0) {
        size += 2 + pb::CodedOutputStream.ComputeUInt32Size(NumKeypoints);
      }
      if (MaxNumberOfBoxes != 0) {
        size += 2 + pb::CodedOutputStream.ComputeInt32Size(MaxNumberOfBoxes);
      }
      if (LoadMulticlassScores != false) {
        size += 2 + 1;
      }
      if (LoadInstanceMasks != false) {
        size += 1 + 1;
      }
      if (MaskType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) MaskType);
      }
      if (UseDisplayName != false) {
        size += 2 + 1;
      }
      if (inputReaderCase_ == InputReaderOneofCase.TfRecordInputReader) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TfRecordInputReader);
      }
      if (inputReaderCase_ == InputReaderOneofCase.ExternalInputReader) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(ExternalInputReader);
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(InputReader other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.LabelMapPath.Length != 0) {
        LabelMapPath = other.LabelMapPath;
      }
      if (other.Shuffle != false) {
        Shuffle = other.Shuffle;
      }
      if (other.ShuffleBufferSize != 0) {
        ShuffleBufferSize = other.ShuffleBufferSize;
      }
      if (other.FilenamesShuffleBufferSize != 0) {
        FilenamesShuffleBufferSize = other.FilenamesShuffleBufferSize;
      }
      if (other.NumEpochs != 0) {
        NumEpochs = other.NumEpochs;
      }
      if (other.Sample1OfNExamples != 0) {
        Sample1OfNExamples = other.Sample1OfNExamples;
      }
      if (other.NumReaders != 0) {
        NumReaders = other.NumReaders;
      }
      if (other.NumParallelBatches != 0) {
        NumParallelBatches = other.NumParallelBatches;
      }
      if (other.NumPrefetchBatches != 0) {
        NumPrefetchBatches = other.NumPrefetchBatches;
      }
      if (other.QueueCapacity != 0) {
        QueueCapacity = other.QueueCapacity;
      }
      if (other.MinAfterDequeue != 0) {
        MinAfterDequeue = other.MinAfterDequeue;
      }
      if (other.ReadBlockLength != 0) {
        ReadBlockLength = other.ReadBlockLength;
      }
      if (other.PrefetchSize != 0) {
        PrefetchSize = other.PrefetchSize;
      }
      if (other.NumParallelMapCalls != 0) {
        NumParallelMapCalls = other.NumParallelMapCalls;
      }
      if (other.NumAdditionalChannels != 0) {
        NumAdditionalChannels = other.NumAdditionalChannels;
      }
      if (other.NumKeypoints != 0) {
        NumKeypoints = other.NumKeypoints;
      }
      if (other.MaxNumberOfBoxes != 0) {
        MaxNumberOfBoxes = other.MaxNumberOfBoxes;
      }
      if (other.LoadMulticlassScores != false) {
        LoadMulticlassScores = other.LoadMulticlassScores;
      }
      if (other.LoadInstanceMasks != false) {
        LoadInstanceMasks = other.LoadInstanceMasks;
      }
      if (other.MaskType != 0) {
        MaskType = other.MaskType;
      }
      if (other.UseDisplayName != false) {
        UseDisplayName = other.UseDisplayName;
      }
      switch (other.InputReaderCase) {
        case InputReaderOneofCase.TfRecordInputReader:
          if (TfRecordInputReader == null) {
            TfRecordInputReader = new global::Tensorflow.Models.ObjectDetection.Protos.TFRecordInputReader();
          }
          TfRecordInputReader.MergeFrom(other.TfRecordInputReader);
          break;
        case InputReaderOneofCase.ExternalInputReader:
          if (ExternalInputReader == null) {
            ExternalInputReader = new global::Tensorflow.Models.ObjectDetection.Protos.ExternalInputReader();
          }
          ExternalInputReader.MergeFrom(other.ExternalInputReader);
          break;
      }

      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            LabelMapPath = input.ReadString();
            break;
          }
          case 16: {
            Shuffle = input.ReadBool();
            break;
          }
          case 24: {
            QueueCapacity = input.ReadUInt32();
            break;
          }
          case 32: {
            MinAfterDequeue = input.ReadUInt32();
            break;
          }
          case 40: {
            NumEpochs = input.ReadUInt32();
            break;
          }
          case 48: {
            NumReaders = input.ReadUInt32();
            break;
          }
          case 56: {
            LoadInstanceMasks = input.ReadBool();
            break;
          }
          case 66: {
            global::Tensorflow.Models.ObjectDetection.Protos.TFRecordInputReader subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.TFRecordInputReader();
            if (inputReaderCase_ == InputReaderOneofCase.TfRecordInputReader) {
              subBuilder.MergeFrom(TfRecordInputReader);
            }
            input.ReadMessage(subBuilder);
            TfRecordInputReader = subBuilder;
            break;
          }
          case 74: {
            global::Tensorflow.Models.ObjectDetection.Protos.ExternalInputReader subBuilder = new global::Tensorflow.Models.ObjectDetection.Protos.ExternalInputReader();
            if (inputReaderCase_ == InputReaderOneofCase.ExternalInputReader) {
              subBuilder.MergeFrom(ExternalInputReader);
            }
            input.ReadMessage(subBuilder);
            ExternalInputReader = subBuilder;
            break;
          }
          case 80: {
            maskType_ = (global::Tensorflow.Models.ObjectDetection.Protos.InstanceMaskType) input.ReadEnum();
            break;
          }
          case 88: {
            ShuffleBufferSize = input.ReadUInt32();
            break;
          }
          case 96: {
            FilenamesShuffleBufferSize = input.ReadUInt32();
            break;
          }
          case 104: {
            PrefetchSize = input.ReadUInt32();
            break;
          }
          case 112: {
            NumParallelMapCalls = input.ReadUInt32();
            break;
          }
          case 120: {
            ReadBlockLength = input.ReadUInt32();
            break;
          }
          case 128: {
            NumKeypoints = input.ReadUInt32();
            break;
          }
          case 136: {
            UseDisplayName = input.ReadBool();
            break;
          }
          case 144: {
            NumAdditionalChannels = input.ReadInt32();
            break;
          }
          case 152: {
            NumParallelBatches = input.ReadUInt32();
            break;
          }
          case 160: {
            NumPrefetchBatches = input.ReadInt32();
            break;
          }
          case 168: {
            MaxNumberOfBoxes = input.ReadInt32();
            break;
          }
          case 176: {
            Sample1OfNExamples = input.ReadUInt32();
            break;
          }
          case 186: {
            Name = input.ReadString();
            break;
          }
          case 192: {
            LoadMulticlassScores = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// An input reader that reads TF Example protos from local TFRecord files.
  /// </summary>
  public sealed partial class TFRecordInputReader : pb::IMessage<TFRecordInputReader> {
    private static readonly pb::MessageParser<TFRecordInputReader> _parser = new pb::MessageParser<TFRecordInputReader>(() => new TFRecordInputReader());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TFRecordInputReader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.InputReaderReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TFRecordInputReader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TFRecordInputReader(TFRecordInputReader other) : this() {
      inputPath_ = other.inputPath_.Clone();
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TFRecordInputReader Clone() {
      return new TFRecordInputReader(this);
    }

    /// <summary>Field number for the "input_path" field.</summary>
    public const int InputPathFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_inputPath_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> inputPath_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Path(s) to `TFRecordFile`s.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> InputPath {
      get { return inputPath_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TFRecordInputReader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TFRecordInputReader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!inputPath_.Equals(other.inputPath_)) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= inputPath_.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      inputPath_.WriteTo(output, _repeated_inputPath_codec);
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += inputPath_.CalculateSize(_repeated_inputPath_codec);
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TFRecordInputReader other) {
      if (other == null) {
        return;
      }
      inputPath_.Add(other.inputPath_);
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 10: {
            inputPath_.AddEntriesFrom(input, _repeated_inputPath_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// An externally defined input reader. Users may define an extension to this
  /// proto to interface their own input readers.
  /// </summary>
  public sealed partial class ExternalInputReader : pb::IMessage<ExternalInputReader> {
    private static readonly pb::MessageParser<ExternalInputReader> _parser = new pb::MessageParser<ExternalInputReader>(() => new ExternalInputReader());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ExternalInputReader> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.InputReaderReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalInputReader() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalInputReader(ExternalInputReader other) : this() {
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ExternalInputReader Clone() {
      return new ExternalInputReader(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ExternalInputReader);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ExternalInputReader other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ExternalInputReader other) {
      if (other == null) {
        return;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
