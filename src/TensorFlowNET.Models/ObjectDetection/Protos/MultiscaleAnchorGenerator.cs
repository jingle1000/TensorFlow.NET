// <auto-generated>
//     Generated by the protocol buffer compiler.  DO NOT EDIT!
//     source: object_detection/protos/multiscale_anchor_generator.proto
// </auto-generated>
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace Tensorflow.Models.ObjectDetection.Protos {

  /// <summary>Holder for reflection information generated from object_detection/protos/multiscale_anchor_generator.proto</summary>
  public static partial class MultiscaleAnchorGeneratorReflection {

    #region Descriptor
    /// <summary>File descriptor for object_detection/protos/multiscale_anchor_generator.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static MultiscaleAnchorGeneratorReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CjlvYmplY3RfZGV0ZWN0aW9uL3Byb3Rvcy9tdWx0aXNjYWxlX2FuY2hvcl9n",
            "ZW5lcmF0b3IucHJvdG8SF29iamVjdF9kZXRlY3Rpb24ucHJvdG9zIqgBChlN",
            "dWx0aXNjYWxlQW5jaG9yR2VuZXJhdG9yEhEKCW1pbl9sZXZlbBgBIAEoBRIR",
            "CgltYXhfbGV2ZWwYAiABKAUSFAoMYW5jaG9yX3NjYWxlGAMgASgCEhUKDWFz",
            "cGVjdF9yYXRpb3MYBCADKAISGQoRc2NhbGVzX3Blcl9vY3RhdmUYBSABKAUS",
            "HQoVbm9ybWFsaXplX2Nvb3JkaW5hdGVzGAYgASgIYgZwcm90bzM="));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(null, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::Tensorflow.Models.ObjectDetection.Protos.MultiscaleAnchorGenerator), global::Tensorflow.Models.ObjectDetection.Protos.MultiscaleAnchorGenerator.Parser, new[]{ "MinLevel", "MaxLevel", "AnchorScale", "AspectRatios", "ScalesPerOctave", "NormalizeCoordinates" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Messages
  /// <summary>
  /// Configuration proto for RetinaNet anchor generator described in
  /// https://arxiv.org/abs/1708.02002. See
  /// anchor_generators/multiscale_grid_anchor_generator.py for details.
  /// </summary>
  public sealed partial class MultiscaleAnchorGenerator : pb::IMessage<MultiscaleAnchorGenerator> {
    private static readonly pb::MessageParser<MultiscaleAnchorGenerator> _parser = new pb::MessageParser<MultiscaleAnchorGenerator>(() => new MultiscaleAnchorGenerator());
    private pb::UnknownFieldSet _unknownFields;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<MultiscaleAnchorGenerator> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::Tensorflow.Models.ObjectDetection.Protos.MultiscaleAnchorGeneratorReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MultiscaleAnchorGenerator() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MultiscaleAnchorGenerator(MultiscaleAnchorGenerator other) : this() {
      minLevel_ = other.minLevel_;
      maxLevel_ = other.maxLevel_;
      anchorScale_ = other.anchorScale_;
      aspectRatios_ = other.aspectRatios_.Clone();
      scalesPerOctave_ = other.scalesPerOctave_;
      normalizeCoordinates_ = other.normalizeCoordinates_;
      _unknownFields = pb::UnknownFieldSet.Clone(other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public MultiscaleAnchorGenerator Clone() {
      return new MultiscaleAnchorGenerator(this);
    }

    /// <summary>Field number for the "min_level" field.</summary>
    public const int MinLevelFieldNumber = 1;
    private int minLevel_;
    /// <summary>
    /// minimum level in feature pyramid
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MinLevel {
      get { return minLevel_; }
      set {
        minLevel_ = value;
      }
    }

    /// <summary>Field number for the "max_level" field.</summary>
    public const int MaxLevelFieldNumber = 2;
    private int maxLevel_;
    /// <summary>
    /// maximum level in feature pyramid
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int MaxLevel {
      get { return maxLevel_; }
      set {
        maxLevel_ = value;
      }
    }

    /// <summary>Field number for the "anchor_scale" field.</summary>
    public const int AnchorScaleFieldNumber = 3;
    private float anchorScale_;
    /// <summary>
    /// Scale of anchor to feature stride
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float AnchorScale {
      get { return anchorScale_; }
      set {
        anchorScale_ = value;
      }
    }

    /// <summary>Field number for the "aspect_ratios" field.</summary>
    public const int AspectRatiosFieldNumber = 4;
    private static readonly pb::FieldCodec<float> _repeated_aspectRatios_codec
        = pb::FieldCodec.ForFloat(34);
    private readonly pbc::RepeatedField<float> aspectRatios_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// Aspect ratios for anchors at each grid point.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> AspectRatios {
      get { return aspectRatios_; }
    }

    /// <summary>Field number for the "scales_per_octave" field.</summary>
    public const int ScalesPerOctaveFieldNumber = 5;
    private int scalesPerOctave_;
    /// <summary>
    /// Number of intermediate scale each scale octave
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int ScalesPerOctave {
      get { return scalesPerOctave_; }
      set {
        scalesPerOctave_ = value;
      }
    }

    /// <summary>Field number for the "normalize_coordinates" field.</summary>
    public const int NormalizeCoordinatesFieldNumber = 6;
    private bool normalizeCoordinates_;
    /// <summary>
    /// Whether to produce anchors in normalized coordinates.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool NormalizeCoordinates {
      get { return normalizeCoordinates_; }
      set {
        normalizeCoordinates_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as MultiscaleAnchorGenerator);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(MultiscaleAnchorGenerator other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (MinLevel != other.MinLevel) return false;
      if (MaxLevel != other.MaxLevel) return false;
      if (!pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.Equals(AnchorScale, other.AnchorScale)) return false;
      if(!aspectRatios_.Equals(other.aspectRatios_)) return false;
      if (ScalesPerOctave != other.ScalesPerOctave) return false;
      if (NormalizeCoordinates != other.NormalizeCoordinates) return false;
      return Equals(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (MinLevel != 0) hash ^= MinLevel.GetHashCode();
      if (MaxLevel != 0) hash ^= MaxLevel.GetHashCode();
      if (AnchorScale != 0F) hash ^= pbc::ProtobufEqualityComparers.BitwiseSingleEqualityComparer.GetHashCode(AnchorScale);
      hash ^= aspectRatios_.GetHashCode();
      if (ScalesPerOctave != 0) hash ^= ScalesPerOctave.GetHashCode();
      if (NormalizeCoordinates != false) hash ^= NormalizeCoordinates.GetHashCode();
      if (_unknownFields != null) {
        hash ^= _unknownFields.GetHashCode();
      }
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (MinLevel != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(MinLevel);
      }
      if (MaxLevel != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(MaxLevel);
      }
      if (AnchorScale != 0F) {
        output.WriteRawTag(29);
        output.WriteFloat(AnchorScale);
      }
      aspectRatios_.WriteTo(output, _repeated_aspectRatios_codec);
      if (ScalesPerOctave != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(ScalesPerOctave);
      }
      if (NormalizeCoordinates != false) {
        output.WriteRawTag(48);
        output.WriteBool(NormalizeCoordinates);
      }
      if (_unknownFields != null) {
        _unknownFields.WriteTo(output);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (MinLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MinLevel);
      }
      if (MaxLevel != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(MaxLevel);
      }
      if (AnchorScale != 0F) {
        size += 1 + 4;
      }
      size += aspectRatios_.CalculateSize(_repeated_aspectRatios_codec);
      if (ScalesPerOctave != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ScalesPerOctave);
      }
      if (NormalizeCoordinates != false) {
        size += 1 + 1;
      }
      if (_unknownFields != null) {
        size += _unknownFields.CalculateSize();
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(MultiscaleAnchorGenerator other) {
      if (other == null) {
        return;
      }
      if (other.MinLevel != 0) {
        MinLevel = other.MinLevel;
      }
      if (other.MaxLevel != 0) {
        MaxLevel = other.MaxLevel;
      }
      if (other.AnchorScale != 0F) {
        AnchorScale = other.AnchorScale;
      }
      aspectRatios_.Add(other.aspectRatios_);
      if (other.ScalesPerOctave != 0) {
        ScalesPerOctave = other.ScalesPerOctave;
      }
      if (other.NormalizeCoordinates != false) {
        NormalizeCoordinates = other.NormalizeCoordinates;
      }
      _unknownFields = pb::UnknownFieldSet.MergeFrom(_unknownFields, other._unknownFields);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            _unknownFields = pb::UnknownFieldSet.MergeFieldFrom(_unknownFields, input);
            break;
          case 8: {
            MinLevel = input.ReadInt32();
            break;
          }
          case 16: {
            MaxLevel = input.ReadInt32();
            break;
          }
          case 29: {
            AnchorScale = input.ReadFloat();
            break;
          }
          case 34:
          case 37: {
            aspectRatios_.AddEntriesFrom(input, _repeated_aspectRatios_codec);
            break;
          }
          case 40: {
            ScalesPerOctave = input.ReadInt32();
            break;
          }
          case 48: {
            NormalizeCoordinates = input.ReadBool();
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
